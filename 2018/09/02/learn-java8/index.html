<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Learn Java8 · Android杂文 - yydcdut</title><meta name="description" content="Learn Java8 - yydcdut"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yydcdut.com/atom.xml" title="Android杂文 - yydcdut"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut/yydcdut.github.io/issues" target="_blank" class="nav-list-link">COMMENT</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Learn Java8</h1><div class="post-info">2018年9月2日</div><div class="post-content"><p>Java8 学习笔记，PPT 备忘录~</p>
<a id="more"></a>
<h1 id="Java-发展史"><a href="#Java-发展史" class="headerlink" title="Java 发展史"></a>Java 发展史</h1><h3 id="JDK-5"><a href="#JDK-5" class="headerlink" title="JDK 5"></a>JDK 5</h3><p><img src="http://yydcdut.github.io/img/jdk5.jpeg" alt="jdk5"></p>
<h3 id="JDK-6"><a href="#JDK-6" class="headerlink" title="JDK 6"></a>JDK 6</h3><p><img src="http://yydcdut.qiniudn.com/jdk6.jpeg" alt="jdk6"></p>
<h3 id="JDK-7"><a href="#JDK-7" class="headerlink" title="JDK 7"></a>JDK 7</h3><p><img src="http://yydcdut.qiniudn.com/jdk7.jpeg" alt="jdk7"></p>
<h3 id="JDK-8"><a href="#JDK-8" class="headerlink" title="JDK 8"></a>JDK 8</h3><p><img src="http://yydcdut.qiniudn.com/jdk8.jpeg" alt="jdk8"></p>
<h1 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h1><p>默认方法让接口<strong>增加新方法</strong>的同时又能保证对使用这个接口的<strong>老版本代码的兼容</strong></p>
<p><img src="http://yydcdut.qiniudn.com/default_method.gif" alt="default_method.gif"></p>
<p>如果在面向接口编程里面，功能 1 要新增一个方法，在接口中添加了该方法，则实现该接口的其他类都得再去实现这个方法</p>
<ul>
<li>如果改接口的实现类有很多，那么一个个类的去做实现很麻烦</li>
<li>该方法对某些类来说是没有意义的</li>
<li>如果这个接口是对外发布的，其他用户自己还去实现了该接口，当发布新版本的时候，其他用户会很蒙</li>
</ul>
<p>所以在 Java8 中新增了接口默认方法，默认方法让接口<strong>增加新方法</strong>的同时又能保证对使用这个接口的<strong>老版本代码的兼容</strong></p>
<h3 id="二进制兼容"><a href="#二进制兼容" class="headerlink" title="二进制兼容"></a>二进制兼容</h3><p><img src="http://yydcdut.qiniudn.com/binary-compatible.gif" alt="binary-compatible.gif"></p>
<p>假设 gif 中的 <code>Exoplayer</code>、<code>Exoplayer  Wrapper</code> 和 <code>app</code> 是分别三个团队，当 <code>app</code> 发现一个 bug 后一层层往上报，最终发现是 <code>Exoplayer</code> 团队的 bug，那么 <code>Exoplayer</code> 团队将 bug fix 了，发布了 <code>Exoplayer 2.0</code> :</p>
<ul>
<li>如果  <code>Exoplayer 2.0</code>  不是二进行兼容的，那么 <code>Exoplayer Wrapper</code> 也需要重新编译发布 2.0 版本</li>
<li>如果   <code>Exoplayer 2.0</code>  是二进行兼容的，那么 <code>Exoplayer Wrapper</code> 无需重新编译， <code>app</code> 直接引用  <code>Exoplayer 2.0</code> 边行</li>
</ul>
<p><strong>『二进制兼容指在升级 (bug fix) 库文件的时候，不必重新编译使用这个库的可执行文件或使用这个库的其他库文件，程序的功能不被破坏』</strong></p>
<p><em>接口的修改是二进制兼容的，但是如果这样修改了的话会让程序出现不可控的异常</em></p>
<p><img src="http://yydcdut.qiniudn.com/interface-binary-compatible.gif" alt="interface-binary-compatible.gif"></p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><img src="http://yydcdut.qiniudn.com/default-method-default.jpeg" alt="default-method-default.jpeg"></p>
<ul>
<li>必须得有关键字 <code>default</code> 修饰</li>
<li>实现类可以复写接口的默认方法</li>
</ul>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>一个类只能<strong>继承一个</strong>父类，可以<strong>实现多个</strong>接口</p>
<p>但是加了默认方法之后，在默认方法的使用上出现了一些冲突</p>
<p><img src="http://yydcdut.qiniudn.com/default-method-conflict.gif" alt="default-method-conflict.gif"></p>
<ul>
<li><strong>类中的方法优先级最高</strong>：<ul>
<li>类或父类中声明的方法的优先级高于任何声明为默认方法的优先级</li>
<li>如果父类中的该方法是抽象的，子类如果不是抽象类则必须实现该方法</li>
</ul>
</li>
<li><strong>子接口优先级更高</strong></li>
<li><strong>如果实现两个接口中的默认方法相同，需要显示解决冲突</strong>：<em>Error: class B inherits unrelated defaults for hello() from types A and C</em></li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>开头以关键字 <code>default</code> 修饰，方法体与常规的类相同</li>
<li>帮助库设计者以向后兼容的方式演进 API</li>
<li>可以用于创建可选方法和行为的多继承</li>
<li>能够解决多继承的冲突</li>
</ul>
<h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p><strong>Optional</strong> 是 Java 8 提供的为了解决 null 安全问题的一个 API</p>
<ul>
<li>NullPointerException 是程序中最典型的异常</li>
<li>让代码充斥着深度嵌套 null 检查 / 代码可读性差</li>
<li>null 某种程度上来说是没有任何意义的</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def path = mManagerData?.getData()?.getInfo()?.getPath() : getDefaultPath();</span><br></pre></td></tr></table></figure>
<p>Java 8 为啥不引入<code>安全操作符</code> 呢？先来看看 <code>Optional</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(mManagerData)</span><br><span class="line">            .map(ManagerData::getData)</span><br><span class="line">            .map(Data::getInfo)</span><br><span class="line">            .map(Info::getPath).orElse(getDefaultPath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个样式结构跟 <code>Stream</code> 很相似，当然搭配着 <code>Stream</code> 食用味道更佳</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;ManagerData&gt; <span class="title">getFirstDraftData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedHashMap&lt;Long, String&gt; linkedHashMap = mDB.getFirst();</span><br><span class="line">    <span class="keyword">if</span> (linkedHashMap.size() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;ManagerData&gt; dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ManagerData data = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, String&gt; entry : linkedHashMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">long</span> id = entry.getKey();</span><br><span class="line">        String content = entry.getValue();</span><br><span class="line">        getDirtyOrCleanDraft(dataList, id, content);</span><br><span class="line">        <span class="keyword">if</span> (dataList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            data = dataList.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是对外提供功能，返回值是一个 <code>Optional</code> 的话更能让调用者知道该怎么操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(mManagerData)</span><br><span class="line">            .map(ManagerData::getData)</span><br><span class="line">            .map(Data::getInfo)</span><br><span class="line">            .map(Info::getPath).orElseGet(() -&gt; getDefaultPath())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>orElse</code> 方法的延时调用版 <code>orElesGet</code> ：如果是 <code>orElse</code> 默认情况下会先去初始化失败情况下的值，如果是 <code>orElesGet</code> 的话，只有失败了的情况才会走其中的方法</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>对缺失的变量值进行建模</li>
<li>提供了丰富的 API，与 Stream 十分相似</li>
<li>更好的设计 API ，调用方只需要看一下返回类型就知道该怎么操作</li>
</ul>
<h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><p>用更简洁流畅的代码完成一个功能</p>
<h3 id="举栗"><a href="#举栗" class="headerlink" title="举栗"></a>举栗</h3><h4 id="版本-1"><a href="#版本-1" class="headerlink" title="版本 1"></a>版本 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterGreenApples</span><span class="params">(List&lt;Apple&gt; list)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"green"</span>.equals(apple.color)) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个版本，需要将绿颜色的苹果给挑选出来</p>
<h4 id="版本-2"><a href="#版本-2" class="headerlink" title="版本 2"></a>版本 2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterColorApples</span><span class="params">(List&lt;Apple&gt; list, String color)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color.equals(apple.color)) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过第一个版本后，需求改了，颜色可能是各种各样的，那么<strong>将颜色作为参数传进来</strong>的方式来满足需求</p>
<p>####版本 3</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterColorOrWeightApples</span><span class="params">(List&lt;Apple&gt; list, String color, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color.equals(apple.color) || weight &gt; apple.weight) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又经过一个版本，判断条件可能不止颜色，还有重量，那么再将重量作为参数传进来；但是这样的做法会<strong>显得越来越笨拙</strong></p>
<h4 id="版本-4"><a href="#版本-4" class="headerlink" title="版本 4"></a>版本 4</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filter</span><span class="params">(List&lt;Apple&gt; list, Filter filter)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter.satisfied(apple)) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">satisfied</span><span class="params">(Apple apple)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么优化一下，通过类似策略模式的方式，放入不同的算法来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeightFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">satisfied</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple.weight &gt; <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">satisfied</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"red"</span>.equals(apple.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list = filter(list, <span class="keyword">new</span> WeightFilter());</span><br><span class="line">list = filter(list, <span class="keyword">new</span> ColorFilter());</span><br></pre></td></tr></table></figure>
<p>这样就把行为抽象出来了，代码适应了需求的变化，但是这个过程很<strong>啰嗦</strong>，因为需要声明很多只需要实例化一次的类</p>
<h4 id="版本-5"><a href="#版本-5" class="headerlink" title="版本 5"></a>版本 5</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list = filter(list, <span class="keyword">new</span> Filter() &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">satisfied</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple.weight &gt; <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>再优化一下上个版本的问题，改为用匿名内部类，虽然上个版本的问题解决了，但是匿名内部类看起来很笨重，占用空间多，除此之外，有时候看起来还特别费力</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> weight = <span class="number">100</span>;</span><br><span class="line">list = filter(list, <span class="keyword">new</span> Filter() &#123;</span><br><span class="line">    <span class="keyword">int</span> weight = <span class="number">200</span>;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">satisfied</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple.weight &gt; weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>此时的 <code>weight</code> 看起来就比较费力，到底引用的是外部的还是内部的呢</p>
<h4 id="版本-6"><a href="#版本-6" class="headerlink" title="版本 6"></a>版本 6</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list = filter(list, apple -&gt; apple.weight &gt; <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>通过 lambda 的方式，再来解决匿名内部类带来的问题</p>
<h3 id="Lambda-结构"><a href="#Lambda-结构" class="headerlink" title="Lambda 结构"></a>Lambda 结构</h3><p><img src="http://yydcdut.qiniudn.com/lambda-explain.jpeg" alt="lambda-explain.jpeg"></p>
<p> <img src="http://yydcdut.qiniudn.com/lambda-explain2.jpeg" alt="lambda-explain2.jpeg"></p>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>只定义了一个抽象方法的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>如果再往 <code>Runnable</code> 中加方法，会导致编译失败</em></p>
<h3 id="占用字节码更少"><a href="#占用字节码更少" class="headerlink" title="占用字节码更少"></a>占用字节码更少</h3><p><img src="http://yydcdut.qiniudn.com/lambda-bytecode.jpeg" alt="lambda-bytecode.jpeg"></p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul>
<li>更简洁的传递代码</li>
<li>函数式接口就是只有一个抽象方法的接口</li>
<li>只有在函数式接口的地方才能使用 Lambda</li>
<li>方法引用可以复用现有的方法实现并直接传递</li>
</ul>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>Stream 可以更好的、更为流畅的、更为语义化的操作集合</p>
<p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言 + 多核时代综合影响的产物。</p>
<p><img src="http://yydcdut.qiniudn.com/stream_part.gif" alt="stream_part.gif"></p>
<p>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p>
<ul>
<li><p>数据操作又可以分为无状态的 (Stateless) 和有状态的 (Stateful) ，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果</p>
</li>
<li><p>终端操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如找到第一个满足条件的元素</p>
</li>
</ul>
<h3 id="Stream-举栗"><a href="#Stream-举栗" class="headerlink" title="Stream 举栗"></a>Stream 举栗</h3><p>结构图，栗子中要用到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line">    String type;<span class="comment">//小吃，素菜，荤菜</span></span><br><span class="line">    String name;<span class="comment">//名字</span></span><br><span class="line">    <span class="keyword">int</span> price;<span class="comment">//钱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从菜单中挑选出 荤菜 且 菜名带『肉』字 且 价格最贵的 3 个</p>
<h4 id="申明式"><a href="#申明式" class="headerlink" title="申明式"></a>申明式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;String&gt; <span class="title">filter</span><span class="params">(List&lt;Dish&gt; list)</span> </span>&#123;</span><br><span class="line">    List&lt;Dish&gt; typeResult = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span> (Dish dish : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"荤菜"</span>.equals(dish.type)) &#123;</span><br><span class="line">            typeResult.add(dish);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Dish&gt; meatResult = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Dish dish : typeResult) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dish.name.contains(<span class="string">"肉"</span>)) &#123;</span><br><span class="line">            meatResult.add(dish);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Collections.sort(meatResult, <span class="keyword">new</span> Comparator&lt;Dish&gt;() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dish o1, Dish o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.price - o2.price;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; nameList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (meatResult.size() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        count = meatResult.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        nameList.add(meatResult.get(i).name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nameList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Stream-1"><a href="#Stream-1" class="headerlink" title="Stream"></a>Stream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;String&gt; <span class="title">filter2</span><span class="params">(List&lt;Dish&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.stream().filter(dish -&gt; <span class="string">"荤菜"</span>.equals(dish.type))</span><br><span class="line">            .filter(dish -&gt; dish.name.contains(<span class="string">"肉"</span>))</span><br><span class="line">            .sorted(Comparator.comparingInt(o -&gt; o.price))</span><br><span class="line">            .limit(<span class="number">3</span>)</span><br><span class="line">            .map(dish -&gt; dish.name)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有无状态举栗"><a href="#有无状态举栗" class="headerlink" title="有无状态举栗"></a>有无状态举栗</h3><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p><img src="http://yydcdut.qiniudn.com/stream_stateless.gif" alt="stream_stateless.gif"></p>
<h4 id="有状态"><a href="#有状态" class="headerlink" title="有状态"></a>有状态</h4><p><img src="http://yydcdut.qiniudn.com/stream_stateful.gif" alt="stream_stateful.gif"></p>
<h3 id="短路非短路举栗"><a href="#短路非短路举栗" class="headerlink" title="短路非短路举栗"></a>短路非短路举栗</h3><h4 id="非短路"><a href="#非短路" class="headerlink" title="非短路"></a>非短路</h4><p><img src="http://yydcdut.qiniudn.com/stream-none-short-circuiting.gif" alt="stream-none-short-circuiting.gif"></p>
<h4 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h4><p><img src="http://yydcdut.qiniudn.com/stream-short-circuiting.gif" alt="stream-short-circuiting.gif"></p>
<h3 id="内部迭代"><a href="#内部迭代" class="headerlink" title="内部迭代"></a>内部迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;String&gt; <span class="title">filter2</span><span class="params">(List&lt;Dish&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.stream().filter(dish -&gt; <span class="string">"荤菜"</span>.equals(dish.type))</span><br><span class="line">            .filter(dish -&gt; dish.name.contains(<span class="string">"肉"</span>))</span><br><span class="line">            .sorted(Comparator.comparingInt(o -&gt; o.price))</span><br><span class="line">            .limit(<span class="number">3</span>)</span><br><span class="line">            .map(dish -&gt; dish.name)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像 SQL，像 builder 构建者模式</p>
<h3 id="流水线（管道）"><a href="#流水线（管道）" class="headerlink" title="流水线（管道）"></a>流水线（管道）</h3><p><img src="http://yydcdut.qiniudn.com/stream-pipeline.gif" alt="stream-pipeline.gif"></p>
<p>集合是一种数据结构；它的主要关注点是在内存中组织数据，而且集合会在一段时间内持久存在。集合通常可用作流管道的来源或目标，但流的关注点是计算，而不是数据；每个中间操作都返回流，让整个流能串起来</p>
<h3 id="自动并行"><a href="#自动并行" class="headerlink" title="自动并行"></a>自动并行</h3><p><img src="http://yydcdut.qiniudn.com/stream-parallel.gif" alt="stream-parallel.gif"></p>
<p>自动并行是采用的 Fork / Join 框架</p>
<h4 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h4><p><img src="http://yydcdut.qiniudn.com/stream-parellel-fork-join.jpeg" alt="stream-parellel-fork-join.jpeg"></p>
<p>把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果</p>
<h4 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a>工作窃取</h4><p><img src="http://yydcdut.qiniudn.com/stream-job-steal.gif" alt="stream-job-steal.gif"></p>
<p>线程 1 负责处理 4 个任务，线程 2 负责处理 4 个任务，当线程 1 任务处理完了，但线程 2 还在处理任务。干完活的线程与其闲着，不如去帮其他线程干活。于是它就去其他线程的队里里窃取一个任务来执行。在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务之间的竞争，通过会使用双端队列，被窃取任务线程永远从双端队列的头部执行任务，而窃取任务线程用于从双端队列的尾部拿任务。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul>
<li>Stream API 能够表达打杂的数据处理查询</li>
<li>对于装箱拆箱提供了对应 API</li>
<li>内部迭代可以透明的实现并行流处理</li>
<li>并不是任何情况都适合并行处理</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/04/28/gradle-recipes-for-android/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yydcdut.com">yydcdut</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>