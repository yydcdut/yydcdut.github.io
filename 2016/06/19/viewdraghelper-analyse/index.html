<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ViewDragHelper源码解析 | Android杂文 - yydcdut</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="分析版本：support-v4-23.3.0

ViewDragHelper 封装了许多手势拖动操作，在某些条件下使用 ViewDragHelper 开发可提高效率。">
<meta property="og:type" content="article">
<meta property="og:title" content="ViewDragHelper源码解析">
<meta property="og:url" content="http://yydcdut.com/2016/06/19/viewdraghelper-analyse/index.html">
<meta property="og:site_name" content="Android杂文 - yydcdut">
<meta property="og:description" content="分析版本：support-v4-23.3.0

ViewDragHelper 封装了许多手势拖动操作，在某些条件下使用 ViewDragHelper 开发可提高效率。">
<meta property="og:updated_time" content="2016-10-08T09:08:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ViewDragHelper源码解析">
<meta name="twitter:description" content="分析版本：support-v4-23.3.0

ViewDragHelper 封装了许多手势拖动操作，在某些条件下使用 ViewDragHelper 开发可提高效率。">
  
    <link rel="alternative" href="/atom.xml" title="Android杂文 - yydcdut" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" type="text/css">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: true
      }
  </script>
  
      <script>
          var _hmt = _hmt || [];
          (function() {
              var hm = document.createElement("script");
              hm.src = "//hm.baidu.com/hm.js?ca0d2d2e8c8246e6ac0e8f9cb04e5833";
              var s = document.getElementsByTagName("script")[0]; 
              s.parentNode.insertBefore(hm, s);
          })();
      </script>
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/avatar.png" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">yydcdut</a></h1>
        </hgroup>

        
        <p class="header-subtitle">每周一篇好文章</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/me/">关于我</a></li>
                        
                            <li><a href="/note/">开源App</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:yydcdut@qq.com" title="Email"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/yydcdut" title="新浪微博"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/yydcdut" title="GitHub"></a></li>
                            
                                <li id="StackOverflow"><a class="StackOverflow" target="_blank" href="http://stackoverflow.com/users/4364595/yydcdut" title="StackOverflow"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Android图像处理/" style="font-size: 10px;">Android图像处理</a> <a href="/tags/AsyncTask/" style="font-size: 10px;">AsyncTask</a> <a href="/tags/Dex/" style="font-size: 13.33px;">Dex</a> <a href="/tags/ElasticScrollView/" style="font-size: 10px;">ElasticScrollView</a> <a href="/tags/EventBus/" style="font-size: 10px;">EventBus</a> <a href="/tags/ExplosionField/" style="font-size: 10px;">ExplosionField</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/ListView/" style="font-size: 13.33px;">ListView</a> <a href="/tags/SwipeBack/" style="font-size: 10px;">SwipeBack</a> <a href="/tags/TextView/" style="font-size: 10px;">TextView</a> <a href="/tags/UI/" style="font-size: 10px;">UI</a> <a href="/tags/Volley/" style="font-size: 10px;">Volley</a> <a href="/tags/drag/" style="font-size: 10px;">drag</a> <a href="/tags/support-v4/" style="font-size: 13.33px;">support-v4</a> <a href="/tags/传感器/" style="font-size: 10px;">传感器</a> <a href="/tags/动画/" style="font-size: 10px;">动画</a> <a href="/tags/扯蛋/" style="font-size: 10px;">扯蛋</a> <a href="/tags/权限/" style="font-size: 10px;">权限</a> <a href="/tags/流程/" style="font-size: 10px;">流程</a> <a href="/tags/源码/" style="font-size: 20px;">源码</a> <a href="/tags/粒子爆炸/" style="font-size: 10px;">粒子爆炸</a> <a href="/tags/自定义控件/" style="font-size: 16.67px;">自定义控件</a>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">yydcdut</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/avatar.png" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">yydcdut</a></h1>
            </hgroup>
            
            <p class="header-subtitle">每周一篇好文章</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/me/">关于我</a></li>
                
                    <li><a href="/note/">开源App</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:yydcdut@qq.com" title="Email"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/yydcdut" title="新浪微博"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/yydcdut" title="GitHub"></a></li>
                            
                                <li id="StackOverflow"><a class="StackOverflow" target="_blank" href="http://stackoverflow.com/users/4364595/yydcdut" title="StackOverflow"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-viewdraghelper-analyse" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/19/viewdraghelper-analyse/" class="article-date">
      <time datetime="2016-06-19T11:10:31.000Z" itemprop="datePublished">2016-06-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ViewDragHelper源码解析
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/support-v4/">support-v4</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p> 分析版本：support-v4-23.3.0</p>
</blockquote>
<p>ViewDragHelper 封装了许多手势拖动操作，在某些条件下使用 ViewDragHelper 开发可提高效率。</p>
<a id="more"></a>
<h2 id="ViewDragHelper"><a href="#ViewDragHelper" class="headerlink" title="ViewDragHelper"></a>ViewDragHelper</h2><p>大家应该都知道 DrawerLayout 吧，该控件有一个手势操作就是将 Menu 从屏幕边缘位置滑动出来，而这部分的手势操作是交给 ViewDragHelper 去处理的。ViewDragHelper 并不是第一个用于分析手势处理的类，Gesturedetector 也是，但是在和拖动相关的手势分析方面 ViewDragHelper 更胜一筹。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>ViewDragHelper 可以检测到是否触及到边缘</li>
<li>ViewDragHelper 并不是直接作用于要被拖动的 View，而是使其控制的视图容器中的子 View 可以被拖动</li>
<li>ViewDragHelper.Callback 是连接 ViewDragHelper 与 View 之间的桥梁</li>
<li>ViewDragHelper 的本质其实是分析 onInterceptTouchEvent 和 onTouchEvent 的 MotionEvent 参数，然后根据分析的结果去改变一个容器中被拖动子 View 的位置</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VDHLayout</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ViewDragHelper mDragger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VDHLayout</span><span class="params">(Context context, AttributeSet attrs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="comment">//第二个参数就是滑动灵敏度的意思</span></span><br><span class="line">        mDragger = ViewDragHelper.create(<span class="keyword">this</span>, <span class="number">1.0f</span>, <span class="keyword">new</span> ViewDragHelper.Callback()&#123;</span><br><span class="line">            <span class="comment">//这个地方实际上函数返回值为true就代表可以滑动 为false 则不能滑动</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryCaptureView</span><span class="params">(View child, <span class="keyword">int</span> pointerId)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这个地方实际上left就代表 你将要移动到的位置的坐标。返回值就是最终确定的移动的位置。</span></span><br><span class="line">            <span class="comment">//我们要让view滑动的范围在我们的layout之内</span></span><br><span class="line">            <span class="comment">//实际上就是判断如果这个坐标在layout之内 那我们就返回这个坐标值。</span></span><br><span class="line">            <span class="comment">//如果这个坐标在layout的边界处 那我们就只能返回边界的坐标给他。不能让他超出这个范围</span></span><br><span class="line">            <span class="comment">//除此之外就是如果你的layout设置了padding的话，也可以让子view的活动范围在padding之内的.</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionHorizontal</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> dx)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionVertical</span><span class="params">(View child, <span class="keyword">int</span> top, <span class="keyword">int</span> dy)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> top;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDragger.shouldInterceptTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line">        mDragger.processTouchEvent(event);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>onInterceptTouchEvent</code> 中通过使用 <code>mDragger.shouldInterceptTouchEvent(event)</code> 来决定我们是否应该拦截当前的事件。<code>onTouchEvent</code> 中通过 <code>mDragger.processTouchEvent(event)</code> 处理事件。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="ViewDragHelper-1"><a href="#ViewDragHelper-1" class="headerlink" title="ViewDragHelper"></a>ViewDragHelper</h3><p>从创建开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewDragHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ViewGroup mParentView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callback mCallback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mEdgeSize;<span class="comment">//边缘距离，当在边缘的这个距离内算触发边缘</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTouchSlop;<span class="comment">//最小移动距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mMaxVelocity;<span class="comment">//最大移动速度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mMinVelocity;<span class="comment">//最小移动速度</span></span><br><span class="line">    <span class="keyword">private</span> ScrollerCompat mScroller;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Factory method to create a new ViewDragHelper.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> forParent Parent view to monitor</span><br><span class="line">     * <span class="doctag">@param</span> cb Callback to provide information and receive events</span><br><span class="line">     * <span class="doctag">@return</span> a new ViewDragHelper instance</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(ViewGroup forParent, Callback cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ViewDragHelper(forParent.getContext(), forParent, cb);</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Factory method to create a new ViewDragHelper.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> forParent Parent view to monitor</span><br><span class="line">     * <span class="doctag">@param</span> sensitivity Multiplier for how sensitive the helper should be about detecting</span><br><span class="line">     *                    the start of a drag. Larger values are more sensitive. 1.0f is normal.</span><br><span class="line">     * <span class="doctag">@param</span> cb Callback to provide information and receive events</span><br><span class="line">     * <span class="doctag">@return</span> a new ViewDragHelper instance</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(ViewGroup forParent, <span class="keyword">float</span> sensitivity, Callback cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ViewDragHelper helper = create(forParent, cb);</span><br><span class="line">        helper.mTouchSlop = (<span class="keyword">int</span>) (helper.mTouchSlop * (<span class="number">1</span> / sensitivity));</span><br><span class="line">        <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Apps should use ViewDragHelper.create() to get a new instance.</span><br><span class="line">     * This will allow VDH to use internal compatibility implementations for different</span><br><span class="line">     * platform versions.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> context Context to initialize config-dependent params from</span><br><span class="line">     * <span class="doctag">@param</span> forParent Parent view to monitor</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ViewDragHelper</span><span class="params">(Context context, ViewGroup forParent, Callback cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (forParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Parent view may not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cb == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Callback may not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mParentView = forParent;</span><br><span class="line">        mCallback = cb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ViewConfiguration vc = ViewConfiguration.get(context);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> density = context.getResources().getDisplayMetrics().density;</span><br><span class="line">        mEdgeSize = (<span class="keyword">int</span>) (EDGE_SIZE * density + <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">        mTouchSlop = vc.getScaledTouchSlop();</span><br><span class="line">        mMaxVelocity = vc.getScaledMaximumFlingVelocity();</span><br><span class="line">        mMinVelocity = vc.getScaledMinimumFlingVelocity();</span><br><span class="line">        mScroller = ScrollerCompat.create(context, sInterpolator);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Interpolator defining the animation curve for mScroller</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Interpolator sInterpolator = <span class="keyword">new</span> Interpolator() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getInterpolation</span><span class="params">(<span class="keyword">float</span> t)</span> </span>&#123;</span><br><span class="line">            t -= <span class="number">1.0f</span>;</span><br><span class="line">            <span class="keyword">return</span> t * t * t * t * t + <span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造函数是私有的，也是仅有的构造函数，所以外部只能通过 <code>create()</code> 工厂方法来创建 ViewDragHelper 实例了。 这里要求了我们传递的自定义 ViewGroup 和回调对象不能为空，否则会直接抛出异常中断程序。在这里也初始化了一些触摸滑动需要的参考值和辅助类。</p>
<ul>
<li>mParentView 和 mCallback 分别保存传递过来的对应参数</li>
<li>ViewConfiguration 类里定义了 View 相关的一系列时间、大小、距离等常量</li>
<li>mEdgeSize 表示边缘触摸的范围。例如 mEdgeSize 为 20dp 并且用户注册监听了左侧边缘触摸时，触摸点的 x 坐标小于 mParentView.getLeft() + mEdgeSize 时（即触摸点在容器左边界往右 20dp 内）就算做是左侧的边缘触摸</li>
<li>mTouchSlop 是一个很小的距离值，只有在前后两次触摸点的距离超过 mTouchSlop 的值时，我们才把这两次触摸算作是『滑动』，我们只在此时进行滑动处理，否则任何微小的距离的变化我们都要处理的话会显得太频繁，如果处理过程又比较复杂耗时就会使界面产生卡顿</li>
<li>mMaxVelocity 、mMinVelocity 是 fling 时的最大、最小速率，单位是像素每秒</li>
<li>mScroller 是 View 滚动的辅助类</li>
<li>还有个 sensitivity ，是用来调节 mTouchSlop 的值。sensitivity 越大，mTouchSlop 越小，对滑动的检测就越敏感。 例如 sensitivity 为 1 时，前后触摸点距离超过 20dp 才进行滑动处理，现在 sensitivity 为 2 的话，前后触摸点距离超过 10dp 就进行处理了</li>
</ul>
<h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewDragHelper</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">     * A Callback is used as a communication channel with the ViewDragHelper back to the</span><br><span class="line">     * parent view using it. &lt;code&gt;on*&lt;/code&gt;methods are invoked on siginficant events and several</span><br><span class="line">     * accessor methods are expected to provide the ViewDragHelper with more information</span><br><span class="line">     * about the state of the parent view upon request. The callback also makes decisions</span><br><span class="line">     * governing the range and draggability of child views.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called when the drag state changes. See the &lt;code&gt;STATE_*&lt;/code&gt; constants</span><br><span class="line">         * for more information.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> state The new drag state</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@see</span> #STATE_IDLE</span><br><span class="line">         * <span class="doctag">@see</span> #STATE_DRAGGING</span><br><span class="line">         * <span class="doctag">@see</span> #STATE_SETTLING</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDragStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called when the captured view's position changes as the result of a drag or settle.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> changedView View whose position changed</span><br><span class="line">         * <span class="doctag">@param</span> left New X coordinate of the left edge of the view</span><br><span class="line">         * <span class="doctag">@param</span> top New Y coordinate of the top edge of the view</span><br><span class="line">         * <span class="doctag">@param</span> dx Change in X position from the last call</span><br><span class="line">         * <span class="doctag">@param</span> dy Change in Y position from the last call</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewPositionChanged</span><span class="params">(View changedView, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called when a child view is captured for dragging or settling. The ID of the pointer</span><br><span class="line">         * currently dragging the captured view is supplied. If activePointerId is</span><br><span class="line">         * identified as &#123;<span class="doctag">@link</span> #INVALID_POINTER&#125; the capture is programmatic instead of</span><br><span class="line">         * pointer-initiated.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> capturedChild Child view that was captured</span><br><span class="line">         * <span class="doctag">@param</span> activePointerId Pointer id tracking the child capture</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCaptured</span><span class="params">(View capturedChild, <span class="keyword">int</span> activePointerId)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called when the child view is no longer being actively dragged.</span><br><span class="line">         * The fling velocity is also supplied, if relevant. The velocity values may</span><br><span class="line">         * be clamped to system minimums or maximums.</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;Calling code may decide to fling or otherwise release the view to let it</span><br><span class="line">         * settle into place. It should do so using &#123;<span class="doctag">@link</span> #settleCapturedViewAt(int, int)&#125;</span><br><span class="line">         * or &#123;<span class="doctag">@link</span> #flingCapturedView(int, int, int, int)&#125;. If the Callback invokes</span><br><span class="line">         * one of these methods, the ViewDragHelper will enter &#123;<span class="doctag">@link</span> #STATE_SETTLING&#125;</span><br><span class="line">         * and the view capture will not fully end until it comes to a complete stop.</span><br><span class="line">         * If neither of these methods is invoked before &lt;code&gt;onViewReleased&lt;/code&gt; returns,</span><br><span class="line">         * the view will stop in place and the ViewDragHelper will return to</span><br><span class="line">         * &#123;<span class="doctag">@link</span> #STATE_IDLE&#125;.&lt;/p&gt;</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> releasedChild The captured child view now being released</span><br><span class="line">         * <span class="doctag">@param</span> xvel X velocity of the pointer as it left the screen in pixels per second.</span><br><span class="line">         * <span class="doctag">@param</span> yvel Y velocity of the pointer as it left the screen in pixels per second.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewReleased</span><span class="params">(View releasedChild, <span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called when one of the subscribed edges in the parent view has been touched</span><br><span class="line">         * by the user while no child view is currently captured.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> edgeFlags A combination of edge flags describing the edge(s) currently touched</span><br><span class="line">         * <span class="doctag">@param</span> pointerId ID of the pointer touching the described edge(s)</span><br><span class="line">         * <span class="doctag">@see</span> #EDGE_LEFT</span><br><span class="line">         * <span class="doctag">@see</span> #EDGE_TOP</span><br><span class="line">         * <span class="doctag">@see</span> #EDGE_RIGHT</span><br><span class="line">         * <span class="doctag">@see</span> #EDGE_BOTTOM</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEdgeTouched</span><span class="params">(<span class="keyword">int</span> edgeFlags, <span class="keyword">int</span> pointerId)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called when the given edge may become locked. This can happen if an edge drag</span><br><span class="line">         * was preliminarily rejected before beginning, but after &#123;<span class="doctag">@link</span> #onEdgeTouched(int, int)&#125;</span><br><span class="line">         * was called. This method should return true to lock this edge or false to leave it</span><br><span class="line">         * unlocked. The default behavior is to leave edges unlocked.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> edgeFlags A combination of edge flags describing the edge(s) locked</span><br><span class="line">         * <span class="doctag">@return</span> true to lock the edge, false to leave it unlocked</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onEdgeLock</span><span class="params">(<span class="keyword">int</span> edgeFlags)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called when the user has started a deliberate drag away from one</span><br><span class="line">         * of the subscribed edges in the parent view while no child view is currently captured.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> edgeFlags A combination of edge flags describing the edge(s) dragged</span><br><span class="line">         * <span class="doctag">@param</span> pointerId ID of the pointer touching the described edge(s)</span><br><span class="line">         * <span class="doctag">@see</span> #EDGE_LEFT</span><br><span class="line">         * <span class="doctag">@see</span> #EDGE_TOP</span><br><span class="line">         * <span class="doctag">@see</span> #EDGE_RIGHT</span><br><span class="line">         * <span class="doctag">@see</span> #EDGE_BOTTOM</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEdgeDragStarted</span><span class="params">(<span class="keyword">int</span> edgeFlags, <span class="keyword">int</span> pointerId)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called to determine the Z-order of child views.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> index the ordered position to query for</span><br><span class="line">         * <span class="doctag">@return</span> index of the view that should be ordered at position &lt;code&gt;index&lt;/code&gt;</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrderedChildIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Return the magnitude of a draggable child view's horizontal range of motion in pixels.</span><br><span class="line">         * This method should return 0 for views that cannot move horizontally.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> child Child view to check</span><br><span class="line">         * <span class="doctag">@return</span> range of horizontal motion in pixels</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewHorizontalDragRange</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Return the magnitude of a draggable child view's vertical range of motion in pixels.</span><br><span class="line">         * This method should return 0 for views that cannot move vertically.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> child Child view to check</span><br><span class="line">         * <span class="doctag">@return</span> range of vertical motion in pixels</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewVerticalDragRange</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called when the user's input indicates that they want to capture the given child view</span><br><span class="line">         * with the pointer indicated by pointerId. The callback should return true if the user</span><br><span class="line">         * is permitted to drag the given view with the indicated pointer.</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;ViewDragHelper may call this method multiple times for the same view even if</span><br><span class="line">         * the view is already captured; this indicates that a new pointer is trying to take</span><br><span class="line">         * control of the view.&lt;/p&gt;</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;If this method returns true, a call to &#123;<span class="doctag">@link</span> #onViewCaptured(android.view.View, int)&#125;</span><br><span class="line">         * will follow if the capture is successful.&lt;/p&gt;</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> child Child the user is attempting to capture</span><br><span class="line">         * <span class="doctag">@param</span> pointerId ID of the pointer attempting the capture</span><br><span class="line">         * <span class="doctag">@return</span> true if capture should be allowed, false otherwise</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">tryCaptureView</span><span class="params">(View child, <span class="keyword">int</span> pointerId)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Restrict the motion of the dragged child view along the horizontal axis.</span><br><span class="line">         * The default implementation does not allow horizontal motion; the extending</span><br><span class="line">         * class must override this method and provide the desired clamping.</span><br><span class="line">         *</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> child Child view being dragged</span><br><span class="line">         * <span class="doctag">@param</span> left Attempted motion along the X axis</span><br><span class="line">         * <span class="doctag">@param</span> dx Proposed change in position for left</span><br><span class="line">         * <span class="doctag">@return</span> The new clamped position for left</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionHorizontal</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> dx)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Restrict the motion of the dragged child view along the vertical axis.</span><br><span class="line">         * The default implementation does not allow vertical motion; the extending</span><br><span class="line">         * class must override this method and provide the desired clamping.</span><br><span class="line">         *</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> child Child view being dragged</span><br><span class="line">         * <span class="doctag">@param</span> top Attempted motion along the Y axis</span><br><span class="line">         * <span class="doctag">@param</span> dy Proposed change in position for top</span><br><span class="line">         * <span class="doctag">@return</span> The new clamped position for top</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionVertical</span><span class="params">(View child, <span class="keyword">int</span> top, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>onViewCaptured</strong>  （当 captureView 被捕获时回调）</li>
<li><strong>tryCaptureView</strong>   （是否需要 capture 这个 View）</li>
<li><strong>clampViewPositionHorizontal</strong> （横向移动的时候回调）</li>
<li><strong>clampViewPositionVertical</strong>  （纵向移动的时候回调）</li>
<li><strong>onViewDragStateChanged</strong>  （当ViewDragHelper状态发生变化时回调（IDLE,DRAGGING,SETTING[自动滚动时]））</li>
<li><strong>onViewPositionChanged</strong>  （当 captureView 的位置发生改变时回调）</li>
<li><strong>onEdgeTouched</strong>  （当触摸到边界时回调）</li>
<li><strong>onEdgeLock</strong>  （true 的时候会锁住当前的边界，false 则 unLock ）</li>
<li><strong>onEdgeDragStarted</strong> （边界拖动开始的时候回调）</li>
<li><strong>getOrderedChildIndex</strong>  （改变同一个坐标（ x , y ）去寻找 captureView 位置的方法）</li>
<li><strong>getViewHorizontalDragRange</strong> （最大横滑动的滑动距离）</li>
<li><strong>getViewVerticalDragRange</strong>  （最大纵向滑动的距离）</li>
<li><strong>onViewReleased</strong>  （当 captureView 被释放的时候回调）</li>
</ul>
<h3 id="shouldInterceptTouchEvent"><a href="#shouldInterceptTouchEvent" class="headerlink" title="shouldInterceptTouchEvent"></a>shouldInterceptTouchEvent</h3><p>在 <code>onInterceptTouchEvent</code> 中的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewDragHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * A null/invalid pointer ID.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVALID_POINTER = -<span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span><br><span class="line">     * Edge flag indicating that the left edge should be affected.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_LEFT = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Edge flag indicating that the right edge should be affected.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_RIGHT = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Edge flag indicating that the top edge should be affected.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_TOP = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Edge flag indicating that the bottom edge should be affected.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_BOTTOM = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Edge flag set indicating all edges should be affected.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_ALL = EDGE_LEFT | EDGE_TOP | EDGE_RIGHT | EDGE_BOTTOM;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * A view is not currently being dragged or animating as a result of a fling/snap.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_IDLE = <span class="number">0</span>;<span class="comment">//静止空闲状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * A view is currently being dragged. The position is currently changing as a result</span><br><span class="line">     * of user input or simulated user input.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_DRAGGING = <span class="number">1</span>;<span class="comment">//正在被拖动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * A view is currently settling into place as a result of a fling or</span><br><span class="line">     * predefined non-interactive motion.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_SETTLING = <span class="number">2</span>;<span class="comment">//正在安置状态中（用户并没有交互操作），就是自动滚动的过程中</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mActivePointerId = INVALID_POINTER;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Current drag state; idle, dragging or settling</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mDragState;<span class="comment">//当前drag状态</span></span><br><span class="line">    <span class="keyword">private</span> View mCapturedView;<span class="comment">//正在被drag的view</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Last known position/pointer tracking</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mActivePointerId = INVALID_POINTER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] mInitialMotionX;<span class="comment">//一开始的X坐标，数组代表多手指的情况，index就是手指id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] mInitialMotionY;<span class="comment">//一开始的Y坐标，数组代表多手指的情况，index就是手指id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] mLastMotionX;<span class="comment">//随时更新的的X坐标，数组代表多手指的情况，index就是手指id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] mLastMotionY;<span class="comment">//随时更新的的Y坐标，数组代表多手指的情况，index就是手指id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mInitialEdgesTouched;<span class="comment">//刚触摸的时候触摸的边缘位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mEdgeDragsInProgress;<span class="comment">//记录边缘拖动</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mEdgeDragsLocked;<span class="comment">//记录锁定的边缘</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mPointersDown;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> VelocityTracker mVelocityTracker;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTrackingEdges;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Check if this event as provided to the parent view's onInterceptTouchEvent should</span><br><span class="line">     * cause the parent to intercept the touch event stream.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> ev MotionEvent provided to onInterceptTouchEvent</span><br><span class="line">     * <span class="doctag">@return</span> true if the parent view should return true from onInterceptTouchEvent</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);<span class="comment">//当前action</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(ev);<span class="comment">//当前actionIndex</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// Reset things for a new event stream, just in case we didn't get</span></span><br><span class="line">            <span class="comment">// the whole previous stream.</span></span><br><span class="line">            cancel();<span class="comment">//归位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化mVelocityTracker并添加事件</span></span><br><span class="line">        <span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">        &#125;</span><br><span class="line">        mVelocityTracker.addMovement(ev);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);<span class="comment">//手指id</span></span><br><span class="line">                saveInitialMotion(x, y, pointerId);<span class="comment">//保存手指id对应的信息</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);<span class="comment">//找到该坐标上的最上面的那个view</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Catch a settling view if possible.</span></span><br><span class="line">                <span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123;<span class="comment">//释放后正在进行动画的时候马上又去drag</span></span><br><span class="line">                    tryCaptureViewForDrag(toCapture, pointerId);<span class="comment">//去drag</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];<span class="comment">//得到当前边缘触摸</span></span><br><span class="line">                <span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;<span class="comment">//mTrackingEdges为是否开启某边缘的触摸drag</span></span><br><span class="line">                    mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);<span class="comment">//回调</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEventCompat.ACTION_POINTER_DOWN: &#123;<span class="comment">//多手指</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, actionIndex);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, actionIndex);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, actionIndex);</span><br><span class="line"></span><br><span class="line">                saveInitialMotion(x, y, pointerId);<span class="comment">//保存手指id对应的信息</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// A ViewDragHelper can only manipulate one view at a time.</span></span><br><span class="line">                <span class="keyword">if</span> (mDragState == STATE_IDLE) &#123;<span class="comment">//如果当前状态是STATE_IDLE</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];<span class="comment">//得到当前边缘触摸</span></span><br><span class="line">                    <span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;<span class="comment">//边缘是否能够滑动</span></span><br><span class="line">                        mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mDragState == STATE_SETTLING) &#123;<span class="comment">//手指放开，返回的状态</span></span><br><span class="line">                    <span class="comment">// Catch a settling view if possible.</span></span><br><span class="line">                    <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">                    <span class="keyword">if</span> (toCapture == mCapturedView) &#123;</span><br><span class="line">                        tryCaptureViewForDrag(toCapture, pointerId);<span class="comment">//去drag</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInitialMotionX == <span class="keyword">null</span> || mInitialMotionY == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// First to cross a touch slop over a draggable view wins. Also report edge drags.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);<span class="comment">//得到当前手指个数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);<span class="comment">//得到id</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// If pointer is invalid then skip the ACTION_MOVE.</span></span><br><span class="line">                    <span class="keyword">if</span> (!isValidPointerForActionMove(pointerId)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);<span class="comment">//得到X</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);<span class="comment">//得到Y</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];<span class="comment">//算出移动的X方向距离</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];<span class="comment">//算出移动的Y方向距离</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> pastSlop = toCapture != <span class="keyword">null</span> &amp;&amp; checkTouchSlop(toCapture, dx, dy);<span class="comment">//是否可以滑动</span></span><br><span class="line">                    <span class="keyword">if</span> (pastSlop) &#123;</span><br><span class="line">                        <span class="comment">// check the callback's</span></span><br><span class="line">                        <span class="comment">// getView[Horizontal|Vertical]DragRange methods to know</span></span><br><span class="line">                        <span class="comment">// if you can move at all along an axis, then see if it</span></span><br><span class="line">                        <span class="comment">// would clamp to the same value. If you can't move at</span></span><br><span class="line">                        <span class="comment">// all in every dimension with a nonzero range, bail.</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> oldLeft = toCapture.getLeft();</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> targetLeft = oldLeft + (<span class="keyword">int</span>) dx;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> newLeft = mCallback.clampViewPositionHorizontal(toCapture,</span><br><span class="line">                                targetLeft, (<span class="keyword">int</span>) dx);<span class="comment">//通过回调得到新的left的值</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> oldTop = toCapture.getTop();</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> targetTop = oldTop + (<span class="keyword">int</span>) dy;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> newTop = mCallback.clampViewPositionVertical(toCapture, targetTop,<span class="comment">//通过回调得到新的top的值</span></span><br><span class="line">                                (<span class="keyword">int</span>) dy);</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> horizontalDragRange = mCallback.getViewHorizontalDragRange(</span><br><span class="line">                                toCapture);<span class="comment">//通过回调得到横向拖动的范围</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> verticalDragRange = mCallback.getViewVerticalDragRange(toCapture);<span class="comment">//通过回调得到纵向拖动的范围</span></span><br><span class="line">                        <span class="keyword">if</span> ((horizontalDragRange == <span class="number">0</span> || horizontalDragRange &gt; <span class="number">0</span></span><br><span class="line">                                &amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == <span class="number">0</span></span><br><span class="line">                                || verticalDragRange &gt; <span class="number">0</span> &amp;&amp; newTop == oldTop)) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    reportNewEdgeDrags(dx, dy, pointerId);<span class="comment">//经过计算之后回调结果出去</span></span><br><span class="line">                    <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">                        <span class="comment">// Callback might have started an edge drag</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                saveLastMotion(ev);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEventCompat.ACTION_POINTER_UP: &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, actionIndex);</span><br><span class="line">                clearMotionHistory(pointerId);<span class="comment">//清除数据</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">                cancel();<span class="comment">//清除数据</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mDragState == STATE_DRAGGING;<span class="comment">//如果是dragging状态，就拦截手势事件</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * The result of a call to this method is equivalent to</span><br><span class="line">     * &#123;<span class="doctag">@link</span> #processTouchEvent(android.view.MotionEvent)&#125; receiving an ACTION_CANCEL event.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mActivePointerId = INVALID_POINTER;</span><br><span class="line">        clearMotionHistory();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mVelocityTracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mVelocityTracker.recycle();</span><br><span class="line">            mVelocityTracker = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearMotionHistory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mInitialMotionX == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.fill(mInitialMotionX, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(mInitialMotionY, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(mLastMotionX, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(mLastMotionY, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(mInitialEdgesTouched, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(mEdgeDragsInProgress, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(mEdgeDragsLocked, <span class="number">0</span>);</span><br><span class="line">        mPointersDown = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveInitialMotion</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">        ensureMotionHistorySizeForId(pointerId);</span><br><span class="line">        mInitialMotionX[pointerId] = mLastMotionX[pointerId] = x;<span class="comment">//赋最开始的值</span></span><br><span class="line">        mInitialMotionY[pointerId] = mLastMotionY[pointerId] = y;<span class="comment">//赋最开始的值</span></span><br><span class="line">        mInitialEdgesTouched[pointerId] = getEdgesTouched((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);<span class="comment">//赋值边缘值</span></span><br><span class="line">        mPointersDown |= <span class="number">1</span> &lt;&lt; pointerId;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureMotionHistorySizeForId</span><span class="params">(<span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mInitialMotionX == <span class="keyword">null</span> || mInitialMotionX.length &lt;= pointerId) &#123;</span><br><span class="line">            <span class="keyword">float</span>[] imx = <span class="keyword">new</span> <span class="keyword">float</span>[pointerId + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">float</span>[] imy = <span class="keyword">new</span> <span class="keyword">float</span>[pointerId + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">float</span>[] lmx = <span class="keyword">new</span> <span class="keyword">float</span>[pointerId + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">float</span>[] lmy = <span class="keyword">new</span> <span class="keyword">float</span>[pointerId + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span>[] iit = <span class="keyword">new</span> <span class="keyword">int</span>[pointerId + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span>[] edip = <span class="keyword">new</span> <span class="keyword">int</span>[pointerId + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span>[] edl = <span class="keyword">new</span> <span class="keyword">int</span>[pointerId + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mInitialMotionX != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.arraycopy(mInitialMotionX, <span class="number">0</span>, imx, <span class="number">0</span>, mInitialMotionX.length);</span><br><span class="line">                System.arraycopy(mInitialMotionY, <span class="number">0</span>, imy, <span class="number">0</span>, mInitialMotionY.length);</span><br><span class="line">                System.arraycopy(mLastMotionX, <span class="number">0</span>, lmx, <span class="number">0</span>, mLastMotionX.length);</span><br><span class="line">                System.arraycopy(mLastMotionY, <span class="number">0</span>, lmy, <span class="number">0</span>, mLastMotionY.length);</span><br><span class="line">                System.arraycopy(mInitialEdgesTouched, <span class="number">0</span>, iit, <span class="number">0</span>, mInitialEdgesTouched.length);</span><br><span class="line">                System.arraycopy(mEdgeDragsInProgress, <span class="number">0</span>, edip, <span class="number">0</span>, mEdgeDragsInProgress.length);</span><br><span class="line">                System.arraycopy(mEdgeDragsLocked, <span class="number">0</span>, edl, <span class="number">0</span>, mEdgeDragsLocked.length);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mInitialMotionX = imx;</span><br><span class="line">            mInitialMotionY = imy;</span><br><span class="line">            mLastMotionX = lmx;</span><br><span class="line">            mLastMotionY = lmy;</span><br><span class="line">            mInitialEdgesTouched = iit;</span><br><span class="line">            mEdgeDragsInProgress = edip;</span><br><span class="line">            mEdgeDragsLocked = edl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 判断是否在边缘，且返回是哪里的边缘</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getEdgesTouched</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt; mParentView.getLeft() + mEdgeSize) result |= EDGE_LEFT;</span><br><span class="line">        <span class="keyword">if</span> (y &lt; mParentView.getTop() + mEdgeSize) result |= EDGE_TOP;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; mParentView.getRight() - mEdgeSize) result |= EDGE_RIGHT;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; mParentView.getBottom() - mEdgeSize) result |= EDGE_BOTTOM;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Find the topmost child under the given point within the parent view's coordinate system.</span><br><span class="line">     * The child order is determined using &#123;<span class="doctag">@link</span> Callback#getOrderedChildIndex(int)&#125;.</span><br><span class="line">     * 找到该坐标上的最上面的那个view</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> x X position to test in the parent's coordinate system</span><br><span class="line">     * <span class="doctag">@param</span> y Y position to test in the parent's coordinate system</span><br><span class="line">     * <span class="doctag">@return</span> The topmost child view under (x, y) or null if none found.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">findTopChildUnder</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = mParentView.getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = childCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i));</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= child.getLeft() &amp;&amp; x &lt; child.getRight() &amp;&amp;</span><br><span class="line">                    y &gt;= child.getTop() &amp;&amp; y &lt; child.getBottom()) &#123;</span><br><span class="line">                <span class="keyword">return</span> child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Attempt to capture the view with the given pointer ID. The callback will be involved.</span><br><span class="line">     * This will put us into the "dragging" state. If we've already captured this view with</span><br><span class="line">     * this pointer this method will immediately return true without consulting the callback.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> toCapture View to capture</span><br><span class="line">     * <span class="doctag">@param</span> pointerId Pointer to capture with</span><br><span class="line">     * <span class="doctag">@return</span> true if capture was successful</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryCaptureViewForDrag</span><span class="params">(View toCapture, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mActivePointerId == pointerId) &#123;<span class="comment">//当前有正在被drag的View且是同一个且还是同一个手指</span></span><br><span class="line">            <span class="comment">// Already done!</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (toCapture != <span class="keyword">null</span> &amp;&amp; mCallback.tryCaptureView(toCapture, pointerId)) &#123;<span class="comment">//回调返回TRUE，表示要drag这个toCapture这个View</span></span><br><span class="line">            mActivePointerId = pointerId;</span><br><span class="line">            captureChildView(toCapture, pointerId);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Capture a specific child view for dragging within the parent. The callback will be notified</span><br><span class="line">     * but &#123;<span class="doctag">@link</span> Callback#tryCaptureView(android.view.View, int)&#125; will not be asked permission to</span><br><span class="line">     * capture this view.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> childView Child view to capture</span><br><span class="line">     * <span class="doctag">@param</span> activePointerId ID of the pointer that is dragging the captured child view</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">captureChildView</span><span class="params">(View childView, <span class="keyword">int</span> activePointerId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (childView.getParent() != mParentView) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"captureChildView: parameter must be a descendant "</span> +</span><br><span class="line">                    <span class="string">"of the ViewDragHelper's tracked parent view ("</span> + mParentView + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCapturedView = childView;<span class="comment">//记录mCaptureView</span></span><br><span class="line">        mActivePointerId = activePointerId;<span class="comment">//记录手指id</span></span><br><span class="line">        mCallback.onViewCaptured(childView, activePointerId);<span class="comment">//回调</span></span><br><span class="line">        setDragState(STATE_DRAGGING);<span class="comment">//设置drag状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDragState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        mParentView.removeCallbacks(mSetIdleRunnable);</span><br><span class="line">        <span class="keyword">if</span> (mDragState != state) &#123;</span><br><span class="line">            mDragState = state;<span class="comment">//设置新的状态</span></span><br><span class="line">            mCallback.onViewDragStateChanged(state);<span class="comment">//回调</span></span><br><span class="line">            <span class="keyword">if</span> (mDragState == STATE_IDLE) &#123;</span><br><span class="line">                mCapturedView = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mSetIdleRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            setDragState(STATE_IDLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidPointerForActionMove</span><span class="params">(<span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPointerDown(pointerId)) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Ignoring pointerId="</span> + pointerId + <span class="string">" because ACTION_DOWN was not received "</span></span><br><span class="line">                    + <span class="string">"for this pointer before ACTION_MOVE. It likely happened because "</span></span><br><span class="line">                    + <span class="string">" ViewDragHelper did not receive all the events in the event stream."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPointerDown</span><span class="params">(<span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (mPointersDown &amp; <span class="number">1</span> &lt;&lt; pointerId) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Check if we've crossed a reasonable touch slop for the given child view.</span><br><span class="line">     * If the child cannot be dragged along the horizontal or vertical axis, motion</span><br><span class="line">     * along that axis will not count toward the slop check.</span><br><span class="line">     * 检查手指移动的距离有没有超过触发处理移动事件的最短距离</span><br><span class="line">     * </span><br><span class="line">     * <span class="doctag">@param</span> child Child to check</span><br><span class="line">     * <span class="doctag">@param</span> dx Motion since initial position along X axis</span><br><span class="line">     * <span class="doctag">@param</span> dy Motion since initial position along Y axis</span><br><span class="line">     * <span class="doctag">@return</span> true if the touch slop has been crossed</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkTouchSlop</span><span class="params">(View child, <span class="keyword">float</span> dx, <span class="keyword">float</span> dy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> checkHorizontal = mCallback.getViewHorizontalDragRange(child) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> checkVertical = mCallback.getViewVerticalDragRange(child) &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkHorizontal &amp;&amp; checkVertical) &#123;</span><br><span class="line">            <span class="keyword">return</span> dx * dx + dy * dy &gt; mTouchSlop * mTouchSlop;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkHorizontal) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(dx) &gt; mTouchSlop;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkVertical) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(dy) &gt; mTouchSlop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 对四个边缘都做了一次检查，检查是否在某些边缘产生拖动了，如果有拖动，就将有拖动的边缘记录在mEdgeDragsInProgress中，再调用Callback的onEdgeDragStarted(int edgeFlags, int pointerId)通知某个边缘开始产生拖动了。虽然reportNewEdgeDrags()会被调用很多次</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportNewEdgeDrags</span><span class="params">(<span class="keyword">float</span> dx, <span class="keyword">float</span> dy, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dragsStarted = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)) &#123;</span><br><span class="line">            dragsStarted |= EDGE_LEFT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkNewEdgeDrag(dy, dx, pointerId, EDGE_TOP)) &#123;</span><br><span class="line">            dragsStarted |= EDGE_TOP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkNewEdgeDrag(dx, dy, pointerId, EDGE_RIGHT)) &#123;</span><br><span class="line">            dragsStarted |= EDGE_RIGHT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkNewEdgeDrag(dy, dx, pointerId, EDGE_BOTTOM)) &#123;</span><br><span class="line">            dragsStarted |= EDGE_BOTTOM;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dragsStarted != <span class="number">0</span>) &#123;</span><br><span class="line">            mEdgeDragsInProgress[pointerId] |= dragsStarted;</span><br><span class="line">            mCallback.onEdgeDragStarted(dragsStarted, pointerId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 返回true表示在指定的边缘开始产生拖动了</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkNewEdgeDrag</span><span class="params">(<span class="keyword">float</span> delta, <span class="keyword">float</span> odelta, <span class="keyword">int</span> pointerId, <span class="keyword">int</span> edge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> absDelta = Math.abs(delta);<span class="comment">//主要监测的方向上的变化</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> absODelta = Math.abs(odelta);<span class="comment">//另外一个方向上的变化</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//1.如果ACTION_DOWN发生时没有触摸到边缘，或者触摸到的边缘不是指定的edge，就直接返回false</span></span><br><span class="line">      	<span class="comment">//2.mTrackingEdges是由setEdgeTrackingEnabled(int edgeFlags)设置的</span></span><br><span class="line">      	<span class="comment">//3.锁定的边缘</span></span><br><span class="line">		<span class="comment">//4.mEdgeDragsInProgress是保存已发生过拖动事件的边缘的</span></span><br><span class="line">        <span class="comment">//5.检查本次移动的距离是不是太小了，太小就不处理了</span></span><br><span class="line">        <span class="keyword">if</span> ((mInitialEdgesTouched[pointerId] &amp; edge) != edge  || (mTrackingEdges &amp; edge) == <span class="number">0</span> ||</span><br><span class="line">                (mEdgeDragsLocked[pointerId] &amp; edge) == edge ||</span><br><span class="line">                (mEdgeDragsInProgress[pointerId] &amp; edge) == edge ||</span><br><span class="line">                (absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (absDelta &lt; absODelta * <span class="number">0.5f</span> &amp;&amp; mCallback.onEdgeLock(edge)) &#123;<span class="comment">//次要方向上移动的距离是否远超过主要方向上移动的距离</span></span><br><span class="line">            mEdgeDragsLocked[pointerId] |= edge;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (mEdgeDragsInProgress[pointerId] &amp; edge) == <span class="number">0</span> &amp;&amp; absDelta &gt; mTouchSlop;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveLastMotion</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">            mLastMotionX[pointerId] = x;</span><br><span class="line">            mLastMotionY[pointerId] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findTopChildUnder()</code> 方法是获得 View，如果在同一个位置有两个子 View 重叠，想要让下层的子 View 被选中， 那么就要实现 Callback 里的 <code>getOrderedChildIndex(int index)</code> 方法来改变查找子View的顺序；例如 topView（ 上层View ）的 index 是 4， bottomView（下层View）的 index 是 3，按照正常的遍历查找方式（ getOrderedChildIndex() 默认直接返回 index ），会选择到 topView ， 要想让 bottomView 被选中就得这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrderedChildIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> indexTop = mParentView.indexOfChild(topView);</span><br><span class="line">    <span class="keyword">int</span> indexBottom = mParentView.indexOfChild(bottomView);</span><br><span class="line">    <span class="keyword">if</span> (index == indexTop) &#123;</span><br><span class="line">        <span class="keyword">return</span> indexBottom;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>shouldInterceptTouchEvent()</code> 方法中，一开始进入的是 <code>ACTION_DOWN</code> ，mCapturedView 默认为 null ，所以一开始会进到 <code>tryCaptureViewForDrag()</code> 里面，当条件 <code>tryCaptureView()</code> 满足的时候会回调 <code>onViewCaptured()</code> 出去，同时设置状态为 <code>STATE_DRAGGING</code> ，之后再回调 <code>onEdgeTouched()</code> 。<code>ACTION_DOWN</code> 部分处理完了，跳过 switch 语句块，剩下的代码就只有 <code>return mDragState == STATE_DRAGGING;</code> ，此时如果状态为 dragging 的话，就反会的 true ，那么表示手势事件被拦截了；在 <code>ACTION_DOWN</code> 部分没有对 mDragState 进行赋值，其默认值为 <code>STATE_IDLE</code> ，所以此处返回 false ，此时会将手势事件传递给子 View 。如果子 View 没有消耗手势事件，那么会进到 <code>ViewDragHelper#processTouchEvent()</code> 中；如果子 View 消耗了手势事件，那么父 View 的 <code>onTouchEvent()</code> 收不到 <code>ACTION_DOWN</code>  事件，<strong>不过只要子 View 没有调用过 <code>requestDisallowInterceptTouchEvent(true)</code>，父 View 的 <code>onInterceptTouchEvent()</code> 的 <code>ACTION_MOVE</code> 部分还是会执行的， 如果在此时返回了 true 拦截了<code>ACTION_MOVE</code> 事件，<code>processTouchEvent()</code> 里的 <code>ACTION_MOVE</code> 部分也就会正常执行，拖动也就没问题了。</strong></p>
<p>如果有多个手指触摸到屏幕上了，对每个触摸点都检查一下，看当前触摸的地方是否需要捕获某个 View。这里先用 <code>findTopChildUnder(int x, int y)</code> 寻找触摸点处的子 View，再用 <code>checkTouchSlop(View child, float dx, float dy)</code> 检查当前触摸点到 <code>ACTION_DOWN</code> 触摸点的距离是否达到了 mTouchSlop，达到了才会去捕获 View。</p>
<h3 id="processTouchEvent"><a href="#processTouchEvent" class="headerlink" title="processTouchEvent"></a>processTouchEvent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewDragHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Process a touch event received by the parent view. This method will dispatch callback events</span><br><span class="line">     * as needed before returning. The parent view's onTouchEvent implementation should call this.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> ev The touch event received by the parent view</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);<span class="comment">//当前action</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(ev);<span class="comment">//当前actionIndex</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// Reset things for a new event stream, just in case we didn't get</span></span><br><span class="line">            <span class="comment">// the whole previous stream.</span></span><br><span class="line">            cancel();<span class="comment">//归位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化mVelocityTracker并添加事件</span></span><br><span class="line">        <span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">        &#125;</span><br><span class="line">        mVelocityTracker.addMovement(ev);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);<span class="comment">//手指id</span></span><br><span class="line">                <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line"></span><br><span class="line">                saveInitialMotion(x, y, pointerId);<span class="comment">//保存手指id对应的信息</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Since the parent is already directly processing this touch event,</span></span><br><span class="line">                <span class="comment">// there is no reason to delay for a slop before dragging.</span></span><br><span class="line">                <span class="comment">// Start immediately if possible.</span></span><br><span class="line">                tryCaptureViewForDrag(toCapture, pointerId);<span class="comment">//去drag</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];<span class="comment">//得到当前边缘触摸</span></span><br><span class="line">                <span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;<span class="comment">//mTrackingEdges为是否开启某边缘的触摸drag</span></span><br><span class="line">                    mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);<span class="comment">//回调</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEventCompat.ACTION_POINTER_DOWN: &#123;<span class="comment">//多手指</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, actionIndex);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, actionIndex);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, actionIndex);</span><br><span class="line"></span><br><span class="line">                saveInitialMotion(x, y, pointerId);;<span class="comment">//保存手指id对应的信息</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// A ViewDragHelper can only manipulate one view at a time.</span></span><br><span class="line">                <span class="keyword">if</span> (mDragState == STATE_IDLE) &#123;</span><br><span class="line">                    <span class="comment">// If we're idle we can do anything! Treat it like a normal down event.</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);<span class="comment">//找到View</span></span><br><span class="line">                    tryCaptureViewForDrag(toCapture, pointerId);<span class="comment">//回调</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];<span class="comment">//得到边缘</span></span><br><span class="line">                    <span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;<span class="comment">//是否能够触发边缘drag</span></span><br><span class="line">                        mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);<span class="comment">//回调</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCapturedViewUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y)) &#123;</span><br><span class="line">                    <span class="comment">// We're still tracking a captured view. If the same view is under this</span></span><br><span class="line">                    <span class="comment">// point, we'll swap to controlling it with this pointer instead.</span></span><br><span class="line">                    <span class="comment">// (This will still work if we're "catching" a settling view.)</span></span><br><span class="line"></span><br><span class="line">                    tryCaptureViewForDrag(mCapturedView, pointerId);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;<span class="comment">//正在拖动</span></span><br><span class="line">                    <span class="comment">// If pointer is invalid then skip the ACTION_MOVE.</span></span><br><span class="line">                    <span class="keyword">if</span> (!isValidPointerForActionMove(mActivePointerId)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, index);<span class="comment">//得到X</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, index);<span class="comment">//得到Y</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (x - mLastMotionX[mActivePointerId]);<span class="comment">//算出移动的X方向距离</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> idy = (<span class="keyword">int</span>) (y - mLastMotionY[mActivePointerId]);<span class="comment">//算出移动的Y方向距离</span></span><br><span class="line"></span><br><span class="line">                    dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);<span class="comment">//移动</span></span><br><span class="line"></span><br><span class="line">                    saveLastMotion(ev);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Check to see if any pointer is now over a draggable view.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If pointer is invalid then skip the ACTION_MOVE.</span></span><br><span class="line">                        <span class="keyword">if</span> (!isValidPointerForActionMove(pointerId)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];</span><br><span class="line"></span><br><span class="line">                        reportNewEdgeDrags(dx, dy, pointerId);<span class="comment">//经过计算之后回调结果出去</span></span><br><span class="line">                        <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">                            <span class="comment">// Callback might have started an edge drag.</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">                        <span class="keyword">if</span> (checkTouchSlop(toCapture, dx, dy) &amp;&amp;</span><br><span class="line">                                tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    saveLastMotion(ev);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEventCompat.ACTION_POINTER_UP: &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, actionIndex);</span><br><span class="line">                <span class="keyword">if</span> (mDragState == STATE_DRAGGING &amp;&amp; pointerId == mActivePointerId) &#123;</span><br><span class="line">                    <span class="comment">// Try to find another pointer that's still holding on to the captured view.</span></span><br><span class="line">                    <span class="keyword">int</span> newActivePointer = INVALID_POINTER;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> id = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line">                        <span class="keyword">if</span> (id == mActivePointerId) &#123;</span><br><span class="line">                            <span class="comment">// This one's going away, skip.</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">                        <span class="keyword">if</span> (findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y) == mCapturedView &amp;&amp;</span><br><span class="line">                                tryCaptureViewForDrag(mCapturedView, id)) &#123;</span><br><span class="line">                            newActivePointer = mActivePointerId;<span class="comment">//更新手指id</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (newActivePointer == INVALID_POINTER) &#123;</span><br><span class="line">                        <span class="comment">// We didn't find another pointer still touching the view, release it.</span></span><br><span class="line">                        releaseViewForPointerUp();<span class="comment">//释放</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                clearMotionHistory(pointerId);<span class="comment">//清除数据</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">                    releaseViewForPointerUp();<span class="comment">//释放</span></span><br><span class="line">                &#125;</span><br><span class="line">                cancel();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">                    dispatchViewReleased(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">//释放</span></span><br><span class="line">                &#125;</span><br><span class="line">                cancel();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dragTo</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;、、参数dx和dy是前后两次ACTION_MOVE移动的距离</span><br><span class="line">        <span class="keyword">int</span> clampedX = left;</span><br><span class="line">        <span class="keyword">int</span> clampedY = top;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldLeft = mCapturedView.getLeft();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldTop = mCapturedView.getTop();</span><br><span class="line">        <span class="keyword">if</span> (dx != <span class="number">0</span>) &#123;</span><br><span class="line">            clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);<span class="comment">//回调</span></span><br><span class="line">            ViewCompat.offsetLeftAndRight(mCapturedView, clampedX - oldLeft);<span class="comment">//移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">            clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);<span class="comment">//回调</span></span><br><span class="line">            ViewCompat.offsetTopAndBottom(mCapturedView, clampedY - oldTop);<span class="comment">//移动</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dx != <span class="number">0</span> || dy != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> clampedDx = clampedX - oldLeft;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> clampedDy = clampedY - oldTop;</span><br><span class="line">            mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY,</span><br><span class="line">                    clampedDx, clampedDy);<span class="comment">//回调</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseViewForPointerUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mVelocityTracker.computeCurrentVelocity(<span class="number">1000</span>, mMaxVelocity);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> xvel = clampMag(</span><br><span class="line">                VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">                mMinVelocity, mMaxVelocity);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> yvel = clampMag(</span><br><span class="line">                VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">                mMinVelocity, mMaxVelocity);</span><br><span class="line">        dispatchViewReleased(xvel, yvel);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Clamp the magnitude of value for absMin and absMax.</span><br><span class="line">     * If the value is below the minimum, it will be clamped to zero.</span><br><span class="line">     * If the value is above the maximum, it will be clamped to the maximum.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> value Value to clamp</span><br><span class="line">     * <span class="doctag">@param</span> absMin Absolute value of the minimum significant value to return</span><br><span class="line">     * <span class="doctag">@param</span> absMax Absolute value of the maximum value to return</span><br><span class="line">     * <span class="doctag">@return</span> The clamped value with the same sign as &lt;code&gt;value&lt;/code&gt;</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">clampMag</span><span class="params">(<span class="keyword">float</span> value, <span class="keyword">float</span> absMin, <span class="keyword">float</span> absMax)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> absValue = Math.abs(value);</span><br><span class="line">        <span class="keyword">if</span> (absValue &lt; absMin) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (absValue &gt; absMax) <span class="keyword">return</span> value &gt; <span class="number">0</span> ? absMax : -absMax;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Like all callback events this must happen on the UI thread, but release</span><br><span class="line">     * involves some extra semantics. During a release (mReleaseInProgress)</span><br><span class="line">     * is the only time it is valid to call &#123;<span class="doctag">@link</span> #settleCapturedViewAt(int, int)&#125;</span><br><span class="line">     * or &#123;<span class="doctag">@link</span> #flingCapturedView(int, int, int, int)&#125;.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchViewReleased</span><span class="params">(<span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;</span><br><span class="line">        mReleaseInProgress = <span class="keyword">true</span>;</span><br><span class="line">        mCallback.onViewReleased(mCapturedView, xvel, yvel);</span><br><span class="line">        mReleaseInProgress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">            <span class="comment">// onViewReleased didn't call a method that would have changed this. Go idle.</span></span><br><span class="line">            setDragState(STATE_IDLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ACTION_DOWN</code> 与 <code>shouldInterceptTouchEvent</code> 中的差不多。当进入到 <code>ACTION_MOVE</code> 的时候，先判断 mDragState 是否为 <code>STATE_DRAGGING</code> ，而唯一调用 <code>setDragState(STATE_DRAGGING)</code> 的地方就是 <code>tryCaptureViewForDrag()</code> 了， 刚才在 <code>ACTION_DOWN</code> 里调用过 <code>tryCaptureViewForDrag()</code> 。当为 <code>STATE_DRAGGING</code> 的时候，开始不停的调用 <code>dragTo()</code> 对 mCaptureView 进行真正拖动了。而 <code>dragTo()</code> 通过调用 <code>offsetLeftAndRight()</code> 和 <code>offsetTopAndBottom()</code> 来完成对 mCapturedView 移动。在 <code>dispatchViewReleased()</code> 的注释里面有介绍了两个方法，<code>settleCapturedViewAt(int, int)</code> 和 <code>flingCapturedView(int, int, int, int)</code> ：</p>
<h3 id="settleCapturedViewAt-amp-amp-flingCapturedView"><a href="#settleCapturedViewAt-amp-amp-flingCapturedView" class="headerlink" title="settleCapturedViewAt &amp;&amp; flingCapturedView"></a>settleCapturedViewAt &amp;&amp; flingCapturedView</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewDragHelper</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Settle the captured view at the given (left, top) position.</span><br><span class="line">     * The appropriate velocity from prior motion will be taken into account.</span><br><span class="line">     * If this method returns true, the caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125;</span><br><span class="line">     * on each subsequent frame to continue the motion until it returns false. If this method</span><br><span class="line">     * returns false there is no further work to do to complete the movement.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> finalLeft Settled left edge position for the captured view</span><br><span class="line">     * <span class="doctag">@param</span> finalTop Settled top edge position for the captured view</span><br><span class="line">     * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">settleCapturedViewAt</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mReleaseInProgress) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot settleCapturedViewAt outside of a call to "</span> +</span><br><span class="line">                    <span class="string">"Callback#onViewReleased"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> forceSettleCapturedViewAt(finalLeft, finalTop,</span><br><span class="line">                (<span class="keyword">int</span>) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">                (<span class="keyword">int</span>) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Settle the captured view at the given (left, top) position.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> finalLeft Target left position for the captured view</span><br><span class="line">     * <span class="doctag">@param</span> finalTop Target top position for the captured view</span><br><span class="line">     * <span class="doctag">@param</span> xvel Horizontal velocity</span><br><span class="line">     * <span class="doctag">@param</span> yvel Vertical velocity</span><br><span class="line">     * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">forceSettleCapturedViewAt</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop, <span class="keyword">int</span> xvel, <span class="keyword">int</span> yvel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> startLeft = mCapturedView.getLeft();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> startTop = mCapturedView.getTop();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dx = finalLeft - startLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dy = finalTop - startTop;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dx == <span class="number">0</span> &amp;&amp; dy == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Nothing to do. Send callbacks, be done.</span></span><br><span class="line">            mScroller.abortAnimation();</span><br><span class="line">            setDragState(STATE_IDLE);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> duration = computeSettleDuration(mCapturedView, dx, dy, xvel, yvel);</span><br><span class="line">        mScroller.startScroll(startLeft, startTop, dx, dy, duration);<span class="comment">//靠Scroll类完成</span></span><br><span class="line"></span><br><span class="line">        setDragState(STATE_SETTLING);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeSettleDuration</span><span class="params">(View child, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> xvel, <span class="keyword">int</span> yvel)</span> </span>&#123;</span><br><span class="line">        xvel = clampMag(xvel, (<span class="keyword">int</span>) mMinVelocity, (<span class="keyword">int</span>) mMaxVelocity);</span><br><span class="line">        yvel = clampMag(yvel, (<span class="keyword">int</span>) mMinVelocity, (<span class="keyword">int</span>) mMaxVelocity);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> absDx = Math.abs(dx);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> absDy = Math.abs(dy);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> absXVel = Math.abs(xvel);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> absYVel = Math.abs(yvel);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> addedVel = absXVel + absYVel;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> addedDistance = absDx + absDy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> xweight = xvel != <span class="number">0</span> ? (<span class="keyword">float</span>) absXVel / addedVel :</span><br><span class="line">                (<span class="keyword">float</span>) absDx / addedDistance;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> yweight = yvel != <span class="number">0</span> ? (<span class="keyword">float</span>) absYVel / addedVel :</span><br><span class="line">                (<span class="keyword">float</span>) absDy / addedDistance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> xduration = computeAxisDuration(dx, xvel, mCallback.getViewHorizontalDragRange(child));</span><br><span class="line">        <span class="keyword">int</span> yduration = computeAxisDuration(dy, yvel, mCallback.getViewVerticalDragRange(child));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (xduration * xweight + yduration * yweight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeAxisDuration</span><span class="params">(<span class="keyword">int</span> delta, <span class="keyword">int</span> velocity, <span class="keyword">int</span> motionRange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果给定的速率velocity不为0，就通过距离除以速率来算出时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> width = mParentView.getWidth();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfWidth = width / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> distanceRatio = Math.min(<span class="number">1f</span>, (<span class="keyword">float</span>) Math.abs(delta) / width);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> distance = halfWidth + halfWidth *</span><br><span class="line">                distanceInfluenceForSnapDuration(distanceRatio);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> duration;</span><br><span class="line">        velocity = Math.abs(velocity);</span><br><span class="line">        <span class="keyword">if</span> (velocity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            duration = <span class="number">4</span> * Math.round(<span class="number">1000</span> * Math.abs(distance / velocity));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> range = (<span class="keyword">float</span>) Math.abs(delta) / motionRange;</span><br><span class="line">            duration = (<span class="keyword">int</span>) ((range + <span class="number">1</span>) * BASE_SETTLE_DURATION);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(duration, MAX_SETTLE_DURATION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Clamp the magnitude of value for absMin and absMax.</span><br><span class="line">     * If the value is below the minimum, it will be clamped to zero.</span><br><span class="line">     * If the value is above the maximum, it will be clamped to the maximum.</span><br><span class="line">     * 确保参数中给定的速率在正常范围之内</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> value Value to clamp</span><br><span class="line">     * <span class="doctag">@param</span> absMin Absolute value of the minimum significant value to return</span><br><span class="line">     * <span class="doctag">@param</span> absMax Absolute value of the maximum value to return</span><br><span class="line">     * <span class="doctag">@return</span> The clamped value with the same sign as &lt;code&gt;value&lt;/code&gt;</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">clampMag</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> absMin, <span class="keyword">int</span> absMax)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> absValue = Math.abs(value);</span><br><span class="line">        <span class="keyword">if</span> (absValue &lt; absMin) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (absValue &gt; absMax) <span class="keyword">return</span> value &gt; <span class="number">0</span> ? absMax : -absMax;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Settle the captured view based on standard free-moving fling behavior.</span><br><span class="line">     * The caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; on each subsequent frame</span><br><span class="line">     * to continue the motion until it returns false.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> minLeft Minimum X position for the view's left edge</span><br><span class="line">     * <span class="doctag">@param</span> minTop Minimum Y position for the view's top edge</span><br><span class="line">     * <span class="doctag">@param</span> maxLeft Maximum X position for the view's left edge</span><br><span class="line">     * <span class="doctag">@param</span> maxTop Maximum Y position for the view's top edge</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flingCapturedView</span><span class="params">(<span class="keyword">int</span> minLeft, <span class="keyword">int</span> minTop, <span class="keyword">int</span> maxLeft, <span class="keyword">int</span> maxTop)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mReleaseInProgress) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot flingCapturedView outside of a call to "</span> +</span><br><span class="line">                    <span class="string">"Callback#onViewReleased"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mScroller.fling(mCapturedView.getLeft(), mCapturedView.getTop(),</span><br><span class="line">                (<span class="keyword">int</span>) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">                (<span class="keyword">int</span>) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">                minLeft, maxLeft, minTop, maxTop);</span><br><span class="line"></span><br><span class="line">        setDragState(STATE_SETTLING);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法里一开始都会判断 mReleaseInProgress 为 false ，如果为 false 就会抛一个 IllegalStateException 异常， 而 mReleaseInProgress 唯一为true的时候就是在 <code>dispatchViewReleased()</code> 里调用 <code>onViewReleased()</code> 的时候。<code>settleCapturedViewAt(int finalLeft, int finalTop)</code> 以松手前的滑动速度为初速动，让捕获到的 View 自动滚动到指定位置。只能在 Callback 的 <code>onViewReleased()</code> 中调用。<code>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)</code>  以松手前的滑动速度为初速动，让捕获到的 View 在指定范围内 fling ，也只能在 Callback 的 <code>onViewReleased()</code> 中调用。</p>
<h3 id="smoothSlideViewTo"><a href="#smoothSlideViewTo" class="headerlink" title="smoothSlideViewTo"></a>smoothSlideViewTo</h3><p>ViewDragHelper 还有一个移动 View 的方法是 smoothSlideViewTo(View child, int finalLeft, int finalTop)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewDragHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Animate the view &lt;code&gt;child&lt;/code&gt; to the given (left, top) position.</span><br><span class="line">     * If this method returns true, the caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125;</span><br><span class="line">     * on each subsequent frame to continue the motion until it returns false. If this method</span><br><span class="line">     * returns false there is no further work to do to complete the movement.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This operation does not count as a capture event, though &#123;<span class="doctag">@link</span> #getCapturedView()&#125;</span><br><span class="line">     * will still report the sliding view while the slide is in progress.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> child Child view to capture and animate</span><br><span class="line">     * <span class="doctag">@param</span> finalLeft Final left position of child</span><br><span class="line">     * <span class="doctag">@param</span> finalTop Final top position of child</span><br><span class="line">     * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">smoothSlideViewTo</span><span class="params">(View child, <span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">        mCapturedView = child;</span><br><span class="line">        mActivePointerId = INVALID_POINTER;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> continueSliding = forceSettleCapturedViewAt(finalLeft, finalTop, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!continueSliding &amp;&amp; mDragState == STATE_IDLE &amp;&amp; mCapturedView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If we're in an IDLE state to begin with and aren't moving anywhere, we</span></span><br><span class="line">            <span class="comment">// end up having a non-null capturedView with an IDLE dragState</span></span><br><span class="line">            mCapturedView = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> continueSliding;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它不受 mReleaseInProgress 的限制，所以可以在任何地方调用，效果和 <code>settleCapturedViewAt()</code> 类似，因为它们最终都调用了 <code>forceSettleCapturedViewAt()</code> 来启动自动滚动，区别在于 <code>settleCapturedViewAt()</code> 会以最后松手前的滑动速率为初速度将 View 滚动到最终位置，而 <code>smoothSlideViewTo()</code> 滚动的初速度是0。 <code>smoothSlideViewTo(View child, int finalLeft, int finalTop)</code> 指定某个 View 自动滚动到指定的位置，初速度为 0 ，可在任何地方调用。</p>

        
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2016/06/19/viewdraghelper-analyse/">ViewDragHelper源码解析</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 yydcdut 的个人博客">yydcdut</a></p>
        <p><span>发布时间:</span>2016年06月19日 - 19时10分</p>
        <p><span>最后更新:</span>2016年10月08日 - 17时08分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2016/06/19/viewdraghelper-analyse/" title="ViewDragHelper源码解析">http://yydcdut.com/2016/06/19/viewdraghelper-analyse/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yydcdut.com/2016/06/19/viewdraghelper-analyse/　　作者: yydcdut" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/07/27/rxmarkdown/">
                    RxMarkdown介绍
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/06/05/arraymap-analyse/">
                    ArrayMap源码解析
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ViewDragHelper"><span class="toc-number">1.</span> <span class="toc-text">ViewDragHelper</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特点"><span class="toc-number">1.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用"><span class="toc-number">1.2.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码分析"><span class="toc-number">2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ViewDragHelper-1"><span class="toc-number">2.1.</span> <span class="toc-text">ViewDragHelper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callback"><span class="toc-number">2.2.</span> <span class="toc-text">Callback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shouldInterceptTouchEvent"><span class="toc-number">2.3.</span> <span class="toc-text">shouldInterceptTouchEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#processTouchEvent"><span class="toc-number">2.4.</span> <span class="toc-text">processTouchEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#settleCapturedViewAt-amp-amp-flingCapturedView"><span class="toc-number">2.5.</span> <span class="toc-text">settleCapturedViewAt && flingCapturedView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#smoothSlideViewTo"><span class="toc-number">2.6.</span> <span class="toc-text">smoothSlideViewTo</span></a></li></ol></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>




    <div class="share">
    <div class="bdsharebuttonbox">
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
    <a href="#" class="bds_copy" data-cmd="copy" title="复制网址"></a>
    <a href="#" class="bds_mail" data-cmd="mail" title="通过邮件分享"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
    </div>
    <script>
        window._bd_share_config={
            "common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>
</div>



    
      <div class="duoshuo" id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="2016/06/19/viewdraghelper-analyse/" data-title="ViewDragHelper源码解析" data-url="http://yydcdut.com/2016/06/19/viewdraghelper-analyse/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"yydcdut"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- 多说公共JS代码 end -->
</div>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/07/27/rxmarkdown/" title="上一篇: RxMarkdown介绍">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/06/05/arraymap-analyse/" title="下一篇: ArrayMap源码解析">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/10/ui-optimize/">Android UI优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/01/the-flow-of-animation-and-animator-analyse/">Animation和Animator流程分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/06/hashmap-analyse/">HashMap源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/25/dexknifeplugin-analyse/">DexKnifePlugin源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/parallax-layer-layout-analyse/">Parallax-Layer-Layout源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/21/logger-analyse/">Logger源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/27/rxmarkdown/">RxMarkdown介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/19/viewdraghelper-analyse/">ViewDragHelper源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/05/arraymap-analyse/">ArrayMap源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/29/android-grag-square-analyse/">android-drag-square源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/22/swipemenulistview-analyse/">SwipeMenuListview源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/15/drawee-text-view-analyse/">Bilibili-drawee-text-view源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/08/swipebacklayout-analyse/">SwipeBackLayout源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/02/asynctask-analyse/">AsyncTask源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/24/easypermissions-analyse/">Google-EasyPermissions源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/17/android-crop-analyse/">android-crop源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/10/explosionfield-analyse/">ExplosionField源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/27/elasticscrollview-analyse/">ElasticScrollView源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/20/split-dex/">Android Dex分包之旅</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/13/volley-code-analyse/">Volley源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/07/eventbus3-code-analyse/">EventBus3.0源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/28/listview-optimize/">ListView优化总结</a></li></ul>
    <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2017 yydcdut
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的静态博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减双栏 Hexo 博客主题">Yelee</a> by MOxFIVE
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

    <style>
        body {
          background: lightgray;
        }
        #container .left-col {
          background: white;
        }
        .article-inner {
          background: white;
          margin-bottom: 1em;
        }
        .post-nav-button {
          background: #ececec;
        }
        #header .header-nav .social #GitHub {
          background-color: #bfd3ec;
        }
        #post-nav-button a {
          background: rgba(215, 216, 215, .2);
        }
        .post-list {
          background: white;
        }
    </style>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>