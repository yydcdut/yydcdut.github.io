<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ViewDragHelper源码解析 · Android杂文 - yydcdut</title><meta name="description" content="ViewDragHelper源码解析 - yydcdut"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yydcdut.com/atom.xml" title="Android杂文 - yydcdut"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut/yydcdut.github.io/issues" target="_blank" class="nav-list-link">COMMENT</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ViewDragHelper源码解析</h1><div class="post-info">2016年6月19日</div><div class="post-content"><blockquote>
<p> 分析版本：support-v4-23.3.0</p>
</blockquote>
<p>ViewDragHelper 封装了许多手势拖动操作，在某些条件下使用 ViewDragHelper 开发可提高效率。</p>
<a id="more"></a>
<h2 id="ViewDragHelper"><a href="#ViewDragHelper" class="headerlink" title="ViewDragHelper"></a>ViewDragHelper</h2><p>大家应该都知道 DrawerLayout 吧，该控件有一个手势操作就是将 Menu 从屏幕边缘位置滑动出来，而这部分的手势操作是交给 ViewDragHelper 去处理的。ViewDragHelper 并不是第一个用于分析手势处理的类，Gesturedetector 也是，但是在和拖动相关的手势分析方面 ViewDragHelper 更胜一筹。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>ViewDragHelper 可以检测到是否触及到边缘</li>
<li>ViewDragHelper 并不是直接作用于要被拖动的 View，而是使其控制的视图容器中的子 View 可以被拖动</li>
<li>ViewDragHelper.Callback 是连接 ViewDragHelper 与 View 之间的桥梁</li>
<li>ViewDragHelper 的本质其实是分析 onInterceptTouchEvent 和 onTouchEvent 的 MotionEvent 参数，然后根据分析的结果去改变一个容器中被拖动子 View 的位置</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VDHLayout</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ViewDragHelper mDragger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VDHLayout</span><span class="params">(Context context, AttributeSet attrs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="comment">//第二个参数就是滑动灵敏度的意思</span></span><br><span class="line">        mDragger = ViewDragHelper.create(<span class="keyword">this</span>, <span class="number">1.0f</span>, <span class="keyword">new</span> ViewDragHelper.Callback()&#123;</span><br><span class="line">            <span class="comment">//这个地方实际上函数返回值为true就代表可以滑动 为false 则不能滑动</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryCaptureView</span><span class="params">(View child, <span class="keyword">int</span> pointerId)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这个地方实际上left就代表 你将要移动到的位置的坐标。返回值就是最终确定的移动的位置。</span></span><br><span class="line">            <span class="comment">//我们要让view滑动的范围在我们的layout之内</span></span><br><span class="line">            <span class="comment">//实际上就是判断如果这个坐标在layout之内 那我们就返回这个坐标值。</span></span><br><span class="line">            <span class="comment">//如果这个坐标在layout的边界处 那我们就只能返回边界的坐标给他。不能让他超出这个范围</span></span><br><span class="line">            <span class="comment">//除此之外就是如果你的layout设置了padding的话，也可以让子view的活动范围在padding之内的.</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionHorizontal</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> dx)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionVertical</span><span class="params">(View child, <span class="keyword">int</span> top, <span class="keyword">int</span> dy)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> top;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDragger.shouldInterceptTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line">        mDragger.processTouchEvent(event);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>onInterceptTouchEvent</code> 中通过使用 <code>mDragger.shouldInterceptTouchEvent(event)</code> 来决定我们是否应该拦截当前的事件。<code>onTouchEvent</code> 中通过 <code>mDragger.processTouchEvent(event)</code> 处理事件。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="ViewDragHelper-1"><a href="#ViewDragHelper-1" class="headerlink" title="ViewDragHelper"></a>ViewDragHelper</h3><p>从创建开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewDragHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ViewGroup mParentView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callback mCallback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mEdgeSize;<span class="comment">//边缘距离，当在边缘的这个距离内算触发边缘</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTouchSlop;<span class="comment">//最小移动距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mMaxVelocity;<span class="comment">//最大移动速度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mMinVelocity;<span class="comment">//最小移动速度</span></span><br><span class="line">    <span class="keyword">private</span> ScrollerCompat mScroller;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Factory method to create a new ViewDragHelper.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> forParent Parent view to monitor</span><br><span class="line">     * <span class="doctag">@param</span> cb Callback to provide information and receive events</span><br><span class="line">     * <span class="doctag">@return</span> a new ViewDragHelper instance</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(ViewGroup forParent, Callback cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ViewDragHelper(forParent.getContext(), forParent, cb);</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Factory method to create a new ViewDragHelper.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> forParent Parent view to monitor</span><br><span class="line">     * <span class="doctag">@param</span> sensitivity Multiplier for how sensitive the helper should be about detecting</span><br><span class="line">     *                    the start of a drag. Larger values are more sensitive. 1.0f is normal.</span><br><span class="line">     * <span class="doctag">@param</span> cb Callback to provide information and receive events</span><br><span class="line">     * <span class="doctag">@return</span> a new ViewDragHelper instance</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewDragHelper <span class="title">create</span><span class="params">(ViewGroup forParent, <span class="keyword">float</span> sensitivity, Callback cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ViewDragHelper helper = create(forParent, cb);</span><br><span class="line">        helper.mTouchSlop = (<span class="keyword">int</span>) (helper.mTouchSlop * (<span class="number">1</span> / sensitivity));</span><br><span class="line">        <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Apps should use ViewDragHelper.create() to get a new instance.</span><br><span class="line">     * This will allow VDH to use internal compatibility implementations for different</span><br><span class="line">     * platform versions.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> context Context to initialize config-dependent params from</span><br><span class="line">     * <span class="doctag">@param</span> forParent Parent view to monitor</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ViewDragHelper</span><span class="params">(Context context, ViewGroup forParent, Callback cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (forParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Parent view may not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cb == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Callback may not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mParentView = forParent;</span><br><span class="line">        mCallback = cb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ViewConfiguration vc = ViewConfiguration.get(context);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> density = context.getResources().getDisplayMetrics().density;</span><br><span class="line">        mEdgeSize = (<span class="keyword">int</span>) (EDGE_SIZE * density + <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">        mTouchSlop = vc.getScaledTouchSlop();</span><br><span class="line">        mMaxVelocity = vc.getScaledMaximumFlingVelocity();</span><br><span class="line">        mMinVelocity = vc.getScaledMinimumFlingVelocity();</span><br><span class="line">        mScroller = ScrollerCompat.create(context, sInterpolator);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Interpolator defining the animation curve for mScroller</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Interpolator sInterpolator = <span class="keyword">new</span> Interpolator() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getInterpolation</span><span class="params">(<span class="keyword">float</span> t)</span> </span>&#123;</span><br><span class="line">            t -= <span class="number">1.0f</span>;</span><br><span class="line">            <span class="keyword">return</span> t * t * t * t * t + <span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造函数是私有的，也是仅有的构造函数，所以外部只能通过 <code>create()</code> 工厂方法来创建 ViewDragHelper 实例了。 这里要求了我们传递的自定义 ViewGroup 和回调对象不能为空，否则会直接抛出异常中断程序。在这里也初始化了一些触摸滑动需要的参考值和辅助类。</p>
<ul>
<li>mParentView 和 mCallback 分别保存传递过来的对应参数</li>
<li>ViewConfiguration 类里定义了 View 相关的一系列时间、大小、距离等常量</li>
<li>mEdgeSize 表示边缘触摸的范围。例如 mEdgeSize 为 20dp 并且用户注册监听了左侧边缘触摸时，触摸点的 x 坐标小于 mParentView.getLeft() + mEdgeSize 时（即触摸点在容器左边界往右 20dp 内）就算做是左侧的边缘触摸</li>
<li>mTouchSlop 是一个很小的距离值，只有在前后两次触摸点的距离超过 mTouchSlop 的值时，我们才把这两次触摸算作是『滑动』，我们只在此时进行滑动处理，否则任何微小的距离的变化我们都要处理的话会显得太频繁，如果处理过程又比较复杂耗时就会使界面产生卡顿</li>
<li>mMaxVelocity 、mMinVelocity 是 fling 时的最大、最小速率，单位是像素每秒</li>
<li>mScroller 是 View 滚动的辅助类</li>
<li>还有个 sensitivity ，是用来调节 mTouchSlop 的值。sensitivity 越大，mTouchSlop 越小，对滑动的检测就越敏感。 例如 sensitivity 为 1 时，前后触摸点距离超过 20dp 才进行滑动处理，现在 sensitivity 为 2 的话，前后触摸点距离超过 10dp 就进行处理了</li>
</ul>
<h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewDragHelper</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">     * A Callback is used as a communication channel with the ViewDragHelper back to the</span><br><span class="line">     * parent view using it. &lt;code&gt;on*&lt;/code&gt;methods are invoked on siginficant events and several</span><br><span class="line">     * accessor methods are expected to provide the ViewDragHelper with more information</span><br><span class="line">     * about the state of the parent view upon request. The callback also makes decisions</span><br><span class="line">     * governing the range and draggability of child views.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called when the drag state changes. See the &lt;code&gt;STATE_*&lt;/code&gt; constants</span><br><span class="line">         * for more information.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> state The new drag state</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@see</span> #STATE_IDLE</span><br><span class="line">         * <span class="doctag">@see</span> #STATE_DRAGGING</span><br><span class="line">         * <span class="doctag">@see</span> #STATE_SETTLING</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDragStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called when the captured view's position changes as the result of a drag or settle.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> changedView View whose position changed</span><br><span class="line">         * <span class="doctag">@param</span> left New X coordinate of the left edge of the view</span><br><span class="line">         * <span class="doctag">@param</span> top New Y coordinate of the top edge of the view</span><br><span class="line">         * <span class="doctag">@param</span> dx Change in X position from the last call</span><br><span class="line">         * <span class="doctag">@param</span> dy Change in Y position from the last call</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewPositionChanged</span><span class="params">(View changedView, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called when a child view is captured for dragging or settling. The ID of the pointer</span><br><span class="line">         * currently dragging the captured view is supplied. If activePointerId is</span><br><span class="line">         * identified as &#123;<span class="doctag">@link</span> #INVALID_POINTER&#125; the capture is programmatic instead of</span><br><span class="line">         * pointer-initiated.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> capturedChild Child view that was captured</span><br><span class="line">         * <span class="doctag">@param</span> activePointerId Pointer id tracking the child capture</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCaptured</span><span class="params">(View capturedChild, <span class="keyword">int</span> activePointerId)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called when the child view is no longer being actively dragged.</span><br><span class="line">         * The fling velocity is also supplied, if relevant. The velocity values may</span><br><span class="line">         * be clamped to system minimums or maximums.</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;Calling code may decide to fling or otherwise release the view to let it</span><br><span class="line">         * settle into place. It should do so using &#123;<span class="doctag">@link</span> #settleCapturedViewAt(int, int)&#125;</span><br><span class="line">         * or &#123;<span class="doctag">@link</span> #flingCapturedView(int, int, int, int)&#125;. If the Callback invokes</span><br><span class="line">         * one of these methods, the ViewDragHelper will enter &#123;<span class="doctag">@link</span> #STATE_SETTLING&#125;</span><br><span class="line">         * and the view capture will not fully end until it comes to a complete stop.</span><br><span class="line">         * If neither of these methods is invoked before &lt;code&gt;onViewReleased&lt;/code&gt; returns,</span><br><span class="line">         * the view will stop in place and the ViewDragHelper will return to</span><br><span class="line">         * &#123;<span class="doctag">@link</span> #STATE_IDLE&#125;.&lt;/p&gt;</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> releasedChild The captured child view now being released</span><br><span class="line">         * <span class="doctag">@param</span> xvel X velocity of the pointer as it left the screen in pixels per second.</span><br><span class="line">         * <span class="doctag">@param</span> yvel Y velocity of the pointer as it left the screen in pixels per second.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewReleased</span><span class="params">(View releasedChild, <span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called when one of the subscribed edges in the parent view has been touched</span><br><span class="line">         * by the user while no child view is currently captured.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> edgeFlags A combination of edge flags describing the edge(s) currently touched</span><br><span class="line">         * <span class="doctag">@param</span> pointerId ID of the pointer touching the described edge(s)</span><br><span class="line">         * <span class="doctag">@see</span> #EDGE_LEFT</span><br><span class="line">         * <span class="doctag">@see</span> #EDGE_TOP</span><br><span class="line">         * <span class="doctag">@see</span> #EDGE_RIGHT</span><br><span class="line">         * <span class="doctag">@see</span> #EDGE_BOTTOM</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEdgeTouched</span><span class="params">(<span class="keyword">int</span> edgeFlags, <span class="keyword">int</span> pointerId)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called when the given edge may become locked. This can happen if an edge drag</span><br><span class="line">         * was preliminarily rejected before beginning, but after &#123;<span class="doctag">@link</span> #onEdgeTouched(int, int)&#125;</span><br><span class="line">         * was called. This method should return true to lock this edge or false to leave it</span><br><span class="line">         * unlocked. The default behavior is to leave edges unlocked.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> edgeFlags A combination of edge flags describing the edge(s) locked</span><br><span class="line">         * <span class="doctag">@return</span> true to lock the edge, false to leave it unlocked</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onEdgeLock</span><span class="params">(<span class="keyword">int</span> edgeFlags)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called when the user has started a deliberate drag away from one</span><br><span class="line">         * of the subscribed edges in the parent view while no child view is currently captured.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> edgeFlags A combination of edge flags describing the edge(s) dragged</span><br><span class="line">         * <span class="doctag">@param</span> pointerId ID of the pointer touching the described edge(s)</span><br><span class="line">         * <span class="doctag">@see</span> #EDGE_LEFT</span><br><span class="line">         * <span class="doctag">@see</span> #EDGE_TOP</span><br><span class="line">         * <span class="doctag">@see</span> #EDGE_RIGHT</span><br><span class="line">         * <span class="doctag">@see</span> #EDGE_BOTTOM</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEdgeDragStarted</span><span class="params">(<span class="keyword">int</span> edgeFlags, <span class="keyword">int</span> pointerId)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called to determine the Z-order of child views.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> index the ordered position to query for</span><br><span class="line">         * <span class="doctag">@return</span> index of the view that should be ordered at position &lt;code&gt;index&lt;/code&gt;</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrderedChildIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Return the magnitude of a draggable child view's horizontal range of motion in pixels.</span><br><span class="line">         * This method should return 0 for views that cannot move horizontally.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> child Child view to check</span><br><span class="line">         * <span class="doctag">@return</span> range of horizontal motion in pixels</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewHorizontalDragRange</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Return the magnitude of a draggable child view's vertical range of motion in pixels.</span><br><span class="line">         * This method should return 0 for views that cannot move vertically.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> child Child view to check</span><br><span class="line">         * <span class="doctag">@return</span> range of vertical motion in pixels</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewVerticalDragRange</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Called when the user's input indicates that they want to capture the given child view</span><br><span class="line">         * with the pointer indicated by pointerId. The callback should return true if the user</span><br><span class="line">         * is permitted to drag the given view with the indicated pointer.</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;ViewDragHelper may call this method multiple times for the same view even if</span><br><span class="line">         * the view is already captured; this indicates that a new pointer is trying to take</span><br><span class="line">         * control of the view.&lt;/p&gt;</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;If this method returns true, a call to &#123;<span class="doctag">@link</span> #onViewCaptured(android.view.View, int)&#125;</span><br><span class="line">         * will follow if the capture is successful.&lt;/p&gt;</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> child Child the user is attempting to capture</span><br><span class="line">         * <span class="doctag">@param</span> pointerId ID of the pointer attempting the capture</span><br><span class="line">         * <span class="doctag">@return</span> true if capture should be allowed, false otherwise</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">tryCaptureView</span><span class="params">(View child, <span class="keyword">int</span> pointerId)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Restrict the motion of the dragged child view along the horizontal axis.</span><br><span class="line">         * The default implementation does not allow horizontal motion; the extending</span><br><span class="line">         * class must override this method and provide the desired clamping.</span><br><span class="line">         *</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> child Child view being dragged</span><br><span class="line">         * <span class="doctag">@param</span> left Attempted motion along the X axis</span><br><span class="line">         * <span class="doctag">@param</span> dx Proposed change in position for left</span><br><span class="line">         * <span class="doctag">@return</span> The new clamped position for left</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionHorizontal</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> dx)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Restrict the motion of the dragged child view along the vertical axis.</span><br><span class="line">         * The default implementation does not allow vertical motion; the extending</span><br><span class="line">         * class must override this method and provide the desired clamping.</span><br><span class="line">         *</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> child Child view being dragged</span><br><span class="line">         * <span class="doctag">@param</span> top Attempted motion along the Y axis</span><br><span class="line">         * <span class="doctag">@param</span> dy Proposed change in position for top</span><br><span class="line">         * <span class="doctag">@return</span> The new clamped position for top</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionVertical</span><span class="params">(View child, <span class="keyword">int</span> top, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>onViewCaptured</strong>  （当 captureView 被捕获时回调）</li>
<li><strong>tryCaptureView</strong>   （是否需要 capture 这个 View）</li>
<li><strong>clampViewPositionHorizontal</strong> （横向移动的时候回调）</li>
<li><strong>clampViewPositionVertical</strong>  （纵向移动的时候回调）</li>
<li><strong>onViewDragStateChanged</strong>  （当ViewDragHelper状态发生变化时回调（IDLE,DRAGGING,SETTING[自动滚动时]））</li>
<li><strong>onViewPositionChanged</strong>  （当 captureView 的位置发生改变时回调）</li>
<li><strong>onEdgeTouched</strong>  （当触摸到边界时回调）</li>
<li><strong>onEdgeLock</strong>  （true 的时候会锁住当前的边界，false 则 unLock ）</li>
<li><strong>onEdgeDragStarted</strong> （边界拖动开始的时候回调）</li>
<li><strong>getOrderedChildIndex</strong>  （改变同一个坐标（ x , y ）去寻找 captureView 位置的方法）</li>
<li><strong>getViewHorizontalDragRange</strong> （最大横滑动的滑动距离）</li>
<li><strong>getViewVerticalDragRange</strong>  （最大纵向滑动的距离）</li>
<li><strong>onViewReleased</strong>  （当 captureView 被释放的时候回调）</li>
</ul>
<h3 id="shouldInterceptTouchEvent"><a href="#shouldInterceptTouchEvent" class="headerlink" title="shouldInterceptTouchEvent"></a>shouldInterceptTouchEvent</h3><p>在 <code>onInterceptTouchEvent</code> 中的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewDragHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * A null/invalid pointer ID.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVALID_POINTER = -<span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span><br><span class="line">     * Edge flag indicating that the left edge should be affected.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_LEFT = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Edge flag indicating that the right edge should be affected.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_RIGHT = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Edge flag indicating that the top edge should be affected.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_TOP = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Edge flag indicating that the bottom edge should be affected.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_BOTTOM = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Edge flag set indicating all edges should be affected.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EDGE_ALL = EDGE_LEFT | EDGE_TOP | EDGE_RIGHT | EDGE_BOTTOM;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * A view is not currently being dragged or animating as a result of a fling/snap.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_IDLE = <span class="number">0</span>;<span class="comment">//静止空闲状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * A view is currently being dragged. The position is currently changing as a result</span><br><span class="line">     * of user input or simulated user input.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_DRAGGING = <span class="number">1</span>;<span class="comment">//正在被拖动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * A view is currently settling into place as a result of a fling or</span><br><span class="line">     * predefined non-interactive motion.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_SETTLING = <span class="number">2</span>;<span class="comment">//正在安置状态中（用户并没有交互操作），就是自动滚动的过程中</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mActivePointerId = INVALID_POINTER;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Current drag state; idle, dragging or settling</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mDragState;<span class="comment">//当前drag状态</span></span><br><span class="line">    <span class="keyword">private</span> View mCapturedView;<span class="comment">//正在被drag的view</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Last known position/pointer tracking</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mActivePointerId = INVALID_POINTER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] mInitialMotionX;<span class="comment">//一开始的X坐标，数组代表多手指的情况，index就是手指id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] mInitialMotionY;<span class="comment">//一开始的Y坐标，数组代表多手指的情况，index就是手指id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] mLastMotionX;<span class="comment">//随时更新的的X坐标，数组代表多手指的情况，index就是手指id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] mLastMotionY;<span class="comment">//随时更新的的Y坐标，数组代表多手指的情况，index就是手指id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mInitialEdgesTouched;<span class="comment">//刚触摸的时候触摸的边缘位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mEdgeDragsInProgress;<span class="comment">//记录边缘拖动</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mEdgeDragsLocked;<span class="comment">//记录锁定的边缘</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mPointersDown;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> VelocityTracker mVelocityTracker;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTrackingEdges;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Check if this event as provided to the parent view's onInterceptTouchEvent should</span><br><span class="line">     * cause the parent to intercept the touch event stream.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> ev MotionEvent provided to onInterceptTouchEvent</span><br><span class="line">     * <span class="doctag">@return</span> true if the parent view should return true from onInterceptTouchEvent</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);<span class="comment">//当前action</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(ev);<span class="comment">//当前actionIndex</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// Reset things for a new event stream, just in case we didn't get</span></span><br><span class="line">            <span class="comment">// the whole previous stream.</span></span><br><span class="line">            cancel();<span class="comment">//归位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化mVelocityTracker并添加事件</span></span><br><span class="line">        <span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">        &#125;</span><br><span class="line">        mVelocityTracker.addMovement(ev);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);<span class="comment">//手指id</span></span><br><span class="line">                saveInitialMotion(x, y, pointerId);<span class="comment">//保存手指id对应的信息</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);<span class="comment">//找到该坐标上的最上面的那个view</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Catch a settling view if possible.</span></span><br><span class="line">                <span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123;<span class="comment">//释放后正在进行动画的时候马上又去drag</span></span><br><span class="line">                    tryCaptureViewForDrag(toCapture, pointerId);<span class="comment">//去drag</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];<span class="comment">//得到当前边缘触摸</span></span><br><span class="line">                <span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;<span class="comment">//mTrackingEdges为是否开启某边缘的触摸drag</span></span><br><span class="line">                    mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);<span class="comment">//回调</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEventCompat.ACTION_POINTER_DOWN: &#123;<span class="comment">//多手指</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, actionIndex);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, actionIndex);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, actionIndex);</span><br><span class="line"></span><br><span class="line">                saveInitialMotion(x, y, pointerId);<span class="comment">//保存手指id对应的信息</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// A ViewDragHelper can only manipulate one view at a time.</span></span><br><span class="line">                <span class="keyword">if</span> (mDragState == STATE_IDLE) &#123;<span class="comment">//如果当前状态是STATE_IDLE</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];<span class="comment">//得到当前边缘触摸</span></span><br><span class="line">                    <span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;<span class="comment">//边缘是否能够滑动</span></span><br><span class="line">                        mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mDragState == STATE_SETTLING) &#123;<span class="comment">//手指放开，返回的状态</span></span><br><span class="line">                    <span class="comment">// Catch a settling view if possible.</span></span><br><span class="line">                    <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">                    <span class="keyword">if</span> (toCapture == mCapturedView) &#123;</span><br><span class="line">                        tryCaptureViewForDrag(toCapture, pointerId);<span class="comment">//去drag</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInitialMotionX == <span class="keyword">null</span> || mInitialMotionY == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// First to cross a touch slop over a draggable view wins. Also report edge drags.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);<span class="comment">//得到当前手指个数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);<span class="comment">//得到id</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// If pointer is invalid then skip the ACTION_MOVE.</span></span><br><span class="line">                    <span class="keyword">if</span> (!isValidPointerForActionMove(pointerId)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);<span class="comment">//得到X</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);<span class="comment">//得到Y</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];<span class="comment">//算出移动的X方向距离</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];<span class="comment">//算出移动的Y方向距离</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> pastSlop = toCapture != <span class="keyword">null</span> &amp;&amp; checkTouchSlop(toCapture, dx, dy);<span class="comment">//是否可以滑动</span></span><br><span class="line">                    <span class="keyword">if</span> (pastSlop) &#123;</span><br><span class="line">                        <span class="comment">// check the callback's</span></span><br><span class="line">                        <span class="comment">// getView[Horizontal|Vertical]DragRange methods to know</span></span><br><span class="line">                        <span class="comment">// if you can move at all along an axis, then see if it</span></span><br><span class="line">                        <span class="comment">// would clamp to the same value. If you can't move at</span></span><br><span class="line">                        <span class="comment">// all in every dimension with a nonzero range, bail.</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> oldLeft = toCapture.getLeft();</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> targetLeft = oldLeft + (<span class="keyword">int</span>) dx;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> newLeft = mCallback.clampViewPositionHorizontal(toCapture,</span><br><span class="line">                                targetLeft, (<span class="keyword">int</span>) dx);<span class="comment">//通过回调得到新的left的值</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> oldTop = toCapture.getTop();</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> targetTop = oldTop + (<span class="keyword">int</span>) dy;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> newTop = mCallback.clampViewPositionVertical(toCapture, targetTop,<span class="comment">//通过回调得到新的top的值</span></span><br><span class="line">                                (<span class="keyword">int</span>) dy);</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> horizontalDragRange = mCallback.getViewHorizontalDragRange(</span><br><span class="line">                                toCapture);<span class="comment">//通过回调得到横向拖动的范围</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> verticalDragRange = mCallback.getViewVerticalDragRange(toCapture);<span class="comment">//通过回调得到纵向拖动的范围</span></span><br><span class="line">                        <span class="keyword">if</span> ((horizontalDragRange == <span class="number">0</span> || horizontalDragRange &gt; <span class="number">0</span></span><br><span class="line">                                &amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == <span class="number">0</span></span><br><span class="line">                                || verticalDragRange &gt; <span class="number">0</span> &amp;&amp; newTop == oldTop)) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    reportNewEdgeDrags(dx, dy, pointerId);<span class="comment">//经过计算之后回调结果出去</span></span><br><span class="line">                    <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">                        <span class="comment">// Callback might have started an edge drag</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                saveLastMotion(ev);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEventCompat.ACTION_POINTER_UP: &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, actionIndex);</span><br><span class="line">                clearMotionHistory(pointerId);<span class="comment">//清除数据</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">                cancel();<span class="comment">//清除数据</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mDragState == STATE_DRAGGING;<span class="comment">//如果是dragging状态，就拦截手势事件</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * The result of a call to this method is equivalent to</span><br><span class="line">     * &#123;<span class="doctag">@link</span> #processTouchEvent(android.view.MotionEvent)&#125; receiving an ACTION_CANCEL event.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mActivePointerId = INVALID_POINTER;</span><br><span class="line">        clearMotionHistory();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mVelocityTracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mVelocityTracker.recycle();</span><br><span class="line">            mVelocityTracker = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearMotionHistory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mInitialMotionX == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.fill(mInitialMotionX, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(mInitialMotionY, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(mLastMotionX, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(mLastMotionY, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(mInitialEdgesTouched, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(mEdgeDragsInProgress, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(mEdgeDragsLocked, <span class="number">0</span>);</span><br><span class="line">        mPointersDown = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveInitialMotion</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">        ensureMotionHistorySizeForId(pointerId);</span><br><span class="line">        mInitialMotionX[pointerId] = mLastMotionX[pointerId] = x;<span class="comment">//赋最开始的值</span></span><br><span class="line">        mInitialMotionY[pointerId] = mLastMotionY[pointerId] = y;<span class="comment">//赋最开始的值</span></span><br><span class="line">        mInitialEdgesTouched[pointerId] = getEdgesTouched((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);<span class="comment">//赋值边缘值</span></span><br><span class="line">        mPointersDown |= <span class="number">1</span> &lt;&lt; pointerId;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureMotionHistorySizeForId</span><span class="params">(<span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mInitialMotionX == <span class="keyword">null</span> || mInitialMotionX.length &lt;= pointerId) &#123;</span><br><span class="line">            <span class="keyword">float</span>[] imx = <span class="keyword">new</span> <span class="keyword">float</span>[pointerId + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">float</span>[] imy = <span class="keyword">new</span> <span class="keyword">float</span>[pointerId + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">float</span>[] lmx = <span class="keyword">new</span> <span class="keyword">float</span>[pointerId + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">float</span>[] lmy = <span class="keyword">new</span> <span class="keyword">float</span>[pointerId + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span>[] iit = <span class="keyword">new</span> <span class="keyword">int</span>[pointerId + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span>[] edip = <span class="keyword">new</span> <span class="keyword">int</span>[pointerId + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span>[] edl = <span class="keyword">new</span> <span class="keyword">int</span>[pointerId + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mInitialMotionX != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.arraycopy(mInitialMotionX, <span class="number">0</span>, imx, <span class="number">0</span>, mInitialMotionX.length);</span><br><span class="line">                System.arraycopy(mInitialMotionY, <span class="number">0</span>, imy, <span class="number">0</span>, mInitialMotionY.length);</span><br><span class="line">                System.arraycopy(mLastMotionX, <span class="number">0</span>, lmx, <span class="number">0</span>, mLastMotionX.length);</span><br><span class="line">                System.arraycopy(mLastMotionY, <span class="number">0</span>, lmy, <span class="number">0</span>, mLastMotionY.length);</span><br><span class="line">                System.arraycopy(mInitialEdgesTouched, <span class="number">0</span>, iit, <span class="number">0</span>, mInitialEdgesTouched.length);</span><br><span class="line">                System.arraycopy(mEdgeDragsInProgress, <span class="number">0</span>, edip, <span class="number">0</span>, mEdgeDragsInProgress.length);</span><br><span class="line">                System.arraycopy(mEdgeDragsLocked, <span class="number">0</span>, edl, <span class="number">0</span>, mEdgeDragsLocked.length);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mInitialMotionX = imx;</span><br><span class="line">            mInitialMotionY = imy;</span><br><span class="line">            mLastMotionX = lmx;</span><br><span class="line">            mLastMotionY = lmy;</span><br><span class="line">            mInitialEdgesTouched = iit;</span><br><span class="line">            mEdgeDragsInProgress = edip;</span><br><span class="line">            mEdgeDragsLocked = edl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 判断是否在边缘，且返回是哪里的边缘</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getEdgesTouched</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt; mParentView.getLeft() + mEdgeSize) result |= EDGE_LEFT;</span><br><span class="line">        <span class="keyword">if</span> (y &lt; mParentView.getTop() + mEdgeSize) result |= EDGE_TOP;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; mParentView.getRight() - mEdgeSize) result |= EDGE_RIGHT;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; mParentView.getBottom() - mEdgeSize) result |= EDGE_BOTTOM;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Find the topmost child under the given point within the parent view's coordinate system.</span><br><span class="line">     * The child order is determined using &#123;<span class="doctag">@link</span> Callback#getOrderedChildIndex(int)&#125;.</span><br><span class="line">     * 找到该坐标上的最上面的那个view</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> x X position to test in the parent's coordinate system</span><br><span class="line">     * <span class="doctag">@param</span> y Y position to test in the parent's coordinate system</span><br><span class="line">     * <span class="doctag">@return</span> The topmost child view under (x, y) or null if none found.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">findTopChildUnder</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = mParentView.getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = childCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i));</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= child.getLeft() &amp;&amp; x &lt; child.getRight() &amp;&amp;</span><br><span class="line">                    y &gt;= child.getTop() &amp;&amp; y &lt; child.getBottom()) &#123;</span><br><span class="line">                <span class="keyword">return</span> child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Attempt to capture the view with the given pointer ID. The callback will be involved.</span><br><span class="line">     * This will put us into the "dragging" state. If we've already captured this view with</span><br><span class="line">     * this pointer this method will immediately return true without consulting the callback.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> toCapture View to capture</span><br><span class="line">     * <span class="doctag">@param</span> pointerId Pointer to capture with</span><br><span class="line">     * <span class="doctag">@return</span> true if capture was successful</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryCaptureViewForDrag</span><span class="params">(View toCapture, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (toCapture == mCapturedView &amp;&amp; mActivePointerId == pointerId) &#123;<span class="comment">//当前有正在被drag的View且是同一个且还是同一个手指</span></span><br><span class="line">            <span class="comment">// Already done!</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (toCapture != <span class="keyword">null</span> &amp;&amp; mCallback.tryCaptureView(toCapture, pointerId)) &#123;<span class="comment">//回调返回TRUE，表示要drag这个toCapture这个View</span></span><br><span class="line">            mActivePointerId = pointerId;</span><br><span class="line">            captureChildView(toCapture, pointerId);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Capture a specific child view for dragging within the parent. The callback will be notified</span><br><span class="line">     * but &#123;<span class="doctag">@link</span> Callback#tryCaptureView(android.view.View, int)&#125; will not be asked permission to</span><br><span class="line">     * capture this view.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> childView Child view to capture</span><br><span class="line">     * <span class="doctag">@param</span> activePointerId ID of the pointer that is dragging the captured child view</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">captureChildView</span><span class="params">(View childView, <span class="keyword">int</span> activePointerId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (childView.getParent() != mParentView) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"captureChildView: parameter must be a descendant "</span> +</span><br><span class="line">                    <span class="string">"of the ViewDragHelper's tracked parent view ("</span> + mParentView + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCapturedView = childView;<span class="comment">//记录mCaptureView</span></span><br><span class="line">        mActivePointerId = activePointerId;<span class="comment">//记录手指id</span></span><br><span class="line">        mCallback.onViewCaptured(childView, activePointerId);<span class="comment">//回调</span></span><br><span class="line">        setDragState(STATE_DRAGGING);<span class="comment">//设置drag状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDragState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        mParentView.removeCallbacks(mSetIdleRunnable);</span><br><span class="line">        <span class="keyword">if</span> (mDragState != state) &#123;</span><br><span class="line">            mDragState = state;<span class="comment">//设置新的状态</span></span><br><span class="line">            mCallback.onViewDragStateChanged(state);<span class="comment">//回调</span></span><br><span class="line">            <span class="keyword">if</span> (mDragState == STATE_IDLE) &#123;</span><br><span class="line">                mCapturedView = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mSetIdleRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            setDragState(STATE_IDLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidPointerForActionMove</span><span class="params">(<span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPointerDown(pointerId)) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Ignoring pointerId="</span> + pointerId + <span class="string">" because ACTION_DOWN was not received "</span></span><br><span class="line">                    + <span class="string">"for this pointer before ACTION_MOVE. It likely happened because "</span></span><br><span class="line">                    + <span class="string">" ViewDragHelper did not receive all the events in the event stream."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPointerDown</span><span class="params">(<span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (mPointersDown &amp; <span class="number">1</span> &lt;&lt; pointerId) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Check if we've crossed a reasonable touch slop for the given child view.</span><br><span class="line">     * If the child cannot be dragged along the horizontal or vertical axis, motion</span><br><span class="line">     * along that axis will not count toward the slop check.</span><br><span class="line">     * 检查手指移动的距离有没有超过触发处理移动事件的最短距离</span><br><span class="line">     * </span><br><span class="line">     * <span class="doctag">@param</span> child Child to check</span><br><span class="line">     * <span class="doctag">@param</span> dx Motion since initial position along X axis</span><br><span class="line">     * <span class="doctag">@param</span> dy Motion since initial position along Y axis</span><br><span class="line">     * <span class="doctag">@return</span> true if the touch slop has been crossed</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkTouchSlop</span><span class="params">(View child, <span class="keyword">float</span> dx, <span class="keyword">float</span> dy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> checkHorizontal = mCallback.getViewHorizontalDragRange(child) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> checkVertical = mCallback.getViewVerticalDragRange(child) &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkHorizontal &amp;&amp; checkVertical) &#123;</span><br><span class="line">            <span class="keyword">return</span> dx * dx + dy * dy &gt; mTouchSlop * mTouchSlop;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkHorizontal) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(dx) &gt; mTouchSlop;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkVertical) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(dy) &gt; mTouchSlop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 对四个边缘都做了一次检查，检查是否在某些边缘产生拖动了，如果有拖动，就将有拖动的边缘记录在mEdgeDragsInProgress中，再调用Callback的onEdgeDragStarted(int edgeFlags, int pointerId)通知某个边缘开始产生拖动了。虽然reportNewEdgeDrags()会被调用很多次</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportNewEdgeDrags</span><span class="params">(<span class="keyword">float</span> dx, <span class="keyword">float</span> dy, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dragsStarted = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)) &#123;</span><br><span class="line">            dragsStarted |= EDGE_LEFT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkNewEdgeDrag(dy, dx, pointerId, EDGE_TOP)) &#123;</span><br><span class="line">            dragsStarted |= EDGE_TOP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkNewEdgeDrag(dx, dy, pointerId, EDGE_RIGHT)) &#123;</span><br><span class="line">            dragsStarted |= EDGE_RIGHT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkNewEdgeDrag(dy, dx, pointerId, EDGE_BOTTOM)) &#123;</span><br><span class="line">            dragsStarted |= EDGE_BOTTOM;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dragsStarted != <span class="number">0</span>) &#123;</span><br><span class="line">            mEdgeDragsInProgress[pointerId] |= dragsStarted;</span><br><span class="line">            mCallback.onEdgeDragStarted(dragsStarted, pointerId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 返回true表示在指定的边缘开始产生拖动了</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkNewEdgeDrag</span><span class="params">(<span class="keyword">float</span> delta, <span class="keyword">float</span> odelta, <span class="keyword">int</span> pointerId, <span class="keyword">int</span> edge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> absDelta = Math.abs(delta);<span class="comment">//主要监测的方向上的变化</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> absODelta = Math.abs(odelta);<span class="comment">//另外一个方向上的变化</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//1.如果ACTION_DOWN发生时没有触摸到边缘，或者触摸到的边缘不是指定的edge，就直接返回false</span></span><br><span class="line">      	<span class="comment">//2.mTrackingEdges是由setEdgeTrackingEnabled(int edgeFlags)设置的</span></span><br><span class="line">      	<span class="comment">//3.锁定的边缘</span></span><br><span class="line">		<span class="comment">//4.mEdgeDragsInProgress是保存已发生过拖动事件的边缘的</span></span><br><span class="line">        <span class="comment">//5.检查本次移动的距离是不是太小了，太小就不处理了</span></span><br><span class="line">        <span class="keyword">if</span> ((mInitialEdgesTouched[pointerId] &amp; edge) != edge  || (mTrackingEdges &amp; edge) == <span class="number">0</span> ||</span><br><span class="line">                (mEdgeDragsLocked[pointerId] &amp; edge) == edge ||</span><br><span class="line">                (mEdgeDragsInProgress[pointerId] &amp; edge) == edge ||</span><br><span class="line">                (absDelta &lt;= mTouchSlop &amp;&amp; absODelta &lt;= mTouchSlop)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (absDelta &lt; absODelta * <span class="number">0.5f</span> &amp;&amp; mCallback.onEdgeLock(edge)) &#123;<span class="comment">//次要方向上移动的距离是否远超过主要方向上移动的距离</span></span><br><span class="line">            mEdgeDragsLocked[pointerId] |= edge;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (mEdgeDragsInProgress[pointerId] &amp; edge) == <span class="number">0</span> &amp;&amp; absDelta &gt; mTouchSlop;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveLastMotion</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">            mLastMotionX[pointerId] = x;</span><br><span class="line">            mLastMotionY[pointerId] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findTopChildUnder()</code> 方法是获得 View，如果在同一个位置有两个子 View 重叠，想要让下层的子 View 被选中， 那么就要实现 Callback 里的 <code>getOrderedChildIndex(int index)</code> 方法来改变查找子View的顺序；例如 topView（ 上层View ）的 index 是 4， bottomView（下层View）的 index 是 3，按照正常的遍历查找方式（ getOrderedChildIndex() 默认直接返回 index ），会选择到 topView ， 要想让 bottomView 被选中就得这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrderedChildIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> indexTop = mParentView.indexOfChild(topView);</span><br><span class="line">    <span class="keyword">int</span> indexBottom = mParentView.indexOfChild(bottomView);</span><br><span class="line">    <span class="keyword">if</span> (index == indexTop) &#123;</span><br><span class="line">        <span class="keyword">return</span> indexBottom;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>shouldInterceptTouchEvent()</code> 方法中，一开始进入的是 <code>ACTION_DOWN</code> ，mCapturedView 默认为 null ，所以一开始会进到 <code>tryCaptureViewForDrag()</code> 里面，当条件 <code>tryCaptureView()</code> 满足的时候会回调 <code>onViewCaptured()</code> 出去，同时设置状态为 <code>STATE_DRAGGING</code> ，之后再回调 <code>onEdgeTouched()</code> 。<code>ACTION_DOWN</code> 部分处理完了，跳过 switch 语句块，剩下的代码就只有 <code>return mDragState == STATE_DRAGGING;</code> ，此时如果状态为 dragging 的话，就反会的 true ，那么表示手势事件被拦截了；在 <code>ACTION_DOWN</code> 部分没有对 mDragState 进行赋值，其默认值为 <code>STATE_IDLE</code> ，所以此处返回 false ，此时会将手势事件传递给子 View 。如果子 View 没有消耗手势事件，那么会进到 <code>ViewDragHelper#processTouchEvent()</code> 中；如果子 View 消耗了手势事件，那么父 View 的 <code>onTouchEvent()</code> 收不到 <code>ACTION_DOWN</code>  事件，<strong>不过只要子 View 没有调用过 <code>requestDisallowInterceptTouchEvent(true)</code>，父 View 的 <code>onInterceptTouchEvent()</code> 的 <code>ACTION_MOVE</code> 部分还是会执行的， 如果在此时返回了 true 拦截了<code>ACTION_MOVE</code> 事件，<code>processTouchEvent()</code> 里的 <code>ACTION_MOVE</code> 部分也就会正常执行，拖动也就没问题了。</strong></p>
<p>如果有多个手指触摸到屏幕上了，对每个触摸点都检查一下，看当前触摸的地方是否需要捕获某个 View。这里先用 <code>findTopChildUnder(int x, int y)</code> 寻找触摸点处的子 View，再用 <code>checkTouchSlop(View child, float dx, float dy)</code> 检查当前触摸点到 <code>ACTION_DOWN</code> 触摸点的距离是否达到了 mTouchSlop，达到了才会去捕获 View。</p>
<h3 id="processTouchEvent"><a href="#processTouchEvent" class="headerlink" title="processTouchEvent"></a>processTouchEvent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewDragHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Process a touch event received by the parent view. This method will dispatch callback events</span><br><span class="line">     * as needed before returning. The parent view's onTouchEvent implementation should call this.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> ev The touch event received by the parent view</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);<span class="comment">//当前action</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(ev);<span class="comment">//当前actionIndex</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// Reset things for a new event stream, just in case we didn't get</span></span><br><span class="line">            <span class="comment">// the whole previous stream.</span></span><br><span class="line">            cancel();<span class="comment">//归位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化mVelocityTracker并添加事件</span></span><br><span class="line">        <span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">        &#125;</span><br><span class="line">        mVelocityTracker.addMovement(ev);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);<span class="comment">//手指id</span></span><br><span class="line">                <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line"></span><br><span class="line">                saveInitialMotion(x, y, pointerId);<span class="comment">//保存手指id对应的信息</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Since the parent is already directly processing this touch event,</span></span><br><span class="line">                <span class="comment">// there is no reason to delay for a slop before dragging.</span></span><br><span class="line">                <span class="comment">// Start immediately if possible.</span></span><br><span class="line">                tryCaptureViewForDrag(toCapture, pointerId);<span class="comment">//去drag</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];<span class="comment">//得到当前边缘触摸</span></span><br><span class="line">                <span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;<span class="comment">//mTrackingEdges为是否开启某边缘的触摸drag</span></span><br><span class="line">                    mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);<span class="comment">//回调</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEventCompat.ACTION_POINTER_DOWN: &#123;<span class="comment">//多手指</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, actionIndex);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, actionIndex);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, actionIndex);</span><br><span class="line"></span><br><span class="line">                saveInitialMotion(x, y, pointerId);;<span class="comment">//保存手指id对应的信息</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// A ViewDragHelper can only manipulate one view at a time.</span></span><br><span class="line">                <span class="keyword">if</span> (mDragState == STATE_IDLE) &#123;</span><br><span class="line">                    <span class="comment">// If we're idle we can do anything! Treat it like a normal down event.</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);<span class="comment">//找到View</span></span><br><span class="line">                    tryCaptureViewForDrag(toCapture, pointerId);<span class="comment">//回调</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> edgesTouched = mInitialEdgesTouched[pointerId];<span class="comment">//得到边缘</span></span><br><span class="line">                    <span class="keyword">if</span> ((edgesTouched &amp; mTrackingEdges) != <span class="number">0</span>) &#123;<span class="comment">//是否能够触发边缘drag</span></span><br><span class="line">                        mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId);<span class="comment">//回调</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCapturedViewUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y)) &#123;</span><br><span class="line">                    <span class="comment">// We're still tracking a captured view. If the same view is under this</span></span><br><span class="line">                    <span class="comment">// point, we'll swap to controlling it with this pointer instead.</span></span><br><span class="line">                    <span class="comment">// (This will still work if we're "catching" a settling view.)</span></span><br><span class="line"></span><br><span class="line">                    tryCaptureViewForDrag(mCapturedView, pointerId);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;<span class="comment">//正在拖动</span></span><br><span class="line">                    <span class="comment">// If pointer is invalid then skip the ACTION_MOVE.</span></span><br><span class="line">                    <span class="keyword">if</span> (!isValidPointerForActionMove(mActivePointerId)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, index);<span class="comment">//得到X</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, index);<span class="comment">//得到Y</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (x - mLastMotionX[mActivePointerId]);<span class="comment">//算出移动的X方向距离</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> idy = (<span class="keyword">int</span>) (y - mLastMotionY[mActivePointerId]);<span class="comment">//算出移动的Y方向距离</span></span><br><span class="line"></span><br><span class="line">                    dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);<span class="comment">//移动</span></span><br><span class="line"></span><br><span class="line">                    saveLastMotion(ev);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Check to see if any pointer is now over a draggable view.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If pointer is invalid then skip the ACTION_MOVE.</span></span><br><span class="line">                        <span class="keyword">if</span> (!isValidPointerForActionMove(pointerId)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> dx = x - mInitialMotionX[pointerId];</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> dy = y - mInitialMotionY[pointerId];</span><br><span class="line"></span><br><span class="line">                        reportNewEdgeDrags(dx, dy, pointerId);<span class="comment">//经过计算之后回调结果出去</span></span><br><span class="line">                        <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">                            <span class="comment">// Callback might have started an edge drag.</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">final</span> View toCapture = findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y);</span><br><span class="line">                        <span class="keyword">if</span> (checkTouchSlop(toCapture, dx, dy) &amp;&amp;</span><br><span class="line">                                tryCaptureViewForDrag(toCapture, pointerId)) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    saveLastMotion(ev);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEventCompat.ACTION_POINTER_UP: &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, actionIndex);</span><br><span class="line">                <span class="keyword">if</span> (mDragState == STATE_DRAGGING &amp;&amp; pointerId == mActivePointerId) &#123;</span><br><span class="line">                    <span class="comment">// Try to find another pointer that's still holding on to the captured view.</span></span><br><span class="line">                    <span class="keyword">int</span> newActivePointer = INVALID_POINTER;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> pointerCount = MotionEventCompat.getPointerCount(ev);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> id = MotionEventCompat.getPointerId(ev, i);</span><br><span class="line">                        <span class="keyword">if</span> (id == mActivePointerId) &#123;</span><br><span class="line">                            <span class="comment">// This one's going away, skip.</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, i);</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, i);</span><br><span class="line">                        <span class="keyword">if</span> (findTopChildUnder((<span class="keyword">int</span>) x, (<span class="keyword">int</span>) y) == mCapturedView &amp;&amp;</span><br><span class="line">                                tryCaptureViewForDrag(mCapturedView, id)) &#123;</span><br><span class="line">                            newActivePointer = mActivePointerId;<span class="comment">//更新手指id</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (newActivePointer == INVALID_POINTER) &#123;</span><br><span class="line">                        <span class="comment">// We didn't find another pointer still touching the view, release it.</span></span><br><span class="line">                        releaseViewForPointerUp();<span class="comment">//释放</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                clearMotionHistory(pointerId);<span class="comment">//清除数据</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">                    releaseViewForPointerUp();<span class="comment">//释放</span></span><br><span class="line">                &#125;</span><br><span class="line">                cancel();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">                    dispatchViewReleased(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">//释放</span></span><br><span class="line">                &#125;</span><br><span class="line">                cancel();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dragTo</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;、、参数dx和dy是前后两次ACTION_MOVE移动的距离</span><br><span class="line">        <span class="keyword">int</span> clampedX = left;</span><br><span class="line">        <span class="keyword">int</span> clampedY = top;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldLeft = mCapturedView.getLeft();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldTop = mCapturedView.getTop();</span><br><span class="line">        <span class="keyword">if</span> (dx != <span class="number">0</span>) &#123;</span><br><span class="line">            clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);<span class="comment">//回调</span></span><br><span class="line">            ViewCompat.offsetLeftAndRight(mCapturedView, clampedX - oldLeft);<span class="comment">//移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">            clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);<span class="comment">//回调</span></span><br><span class="line">            ViewCompat.offsetTopAndBottom(mCapturedView, clampedY - oldTop);<span class="comment">//移动</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dx != <span class="number">0</span> || dy != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> clampedDx = clampedX - oldLeft;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> clampedDy = clampedY - oldTop;</span><br><span class="line">            mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY,</span><br><span class="line">                    clampedDx, clampedDy);<span class="comment">//回调</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseViewForPointerUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mVelocityTracker.computeCurrentVelocity(<span class="number">1000</span>, mMaxVelocity);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> xvel = clampMag(</span><br><span class="line">                VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">                mMinVelocity, mMaxVelocity);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> yvel = clampMag(</span><br><span class="line">                VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">                mMinVelocity, mMaxVelocity);</span><br><span class="line">        dispatchViewReleased(xvel, yvel);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Clamp the magnitude of value for absMin and absMax.</span><br><span class="line">     * If the value is below the minimum, it will be clamped to zero.</span><br><span class="line">     * If the value is above the maximum, it will be clamped to the maximum.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> value Value to clamp</span><br><span class="line">     * <span class="doctag">@param</span> absMin Absolute value of the minimum significant value to return</span><br><span class="line">     * <span class="doctag">@param</span> absMax Absolute value of the maximum value to return</span><br><span class="line">     * <span class="doctag">@return</span> The clamped value with the same sign as &lt;code&gt;value&lt;/code&gt;</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">clampMag</span><span class="params">(<span class="keyword">float</span> value, <span class="keyword">float</span> absMin, <span class="keyword">float</span> absMax)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> absValue = Math.abs(value);</span><br><span class="line">        <span class="keyword">if</span> (absValue &lt; absMin) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (absValue &gt; absMax) <span class="keyword">return</span> value &gt; <span class="number">0</span> ? absMax : -absMax;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Like all callback events this must happen on the UI thread, but release</span><br><span class="line">     * involves some extra semantics. During a release (mReleaseInProgress)</span><br><span class="line">     * is the only time it is valid to call &#123;<span class="doctag">@link</span> #settleCapturedViewAt(int, int)&#125;</span><br><span class="line">     * or &#123;<span class="doctag">@link</span> #flingCapturedView(int, int, int, int)&#125;.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchViewReleased</span><span class="params">(<span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;</span><br><span class="line">        mReleaseInProgress = <span class="keyword">true</span>;</span><br><span class="line">        mCallback.onViewReleased(mCapturedView, xvel, yvel);</span><br><span class="line">        mReleaseInProgress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDragState == STATE_DRAGGING) &#123;</span><br><span class="line">            <span class="comment">// onViewReleased didn't call a method that would have changed this. Go idle.</span></span><br><span class="line">            setDragState(STATE_IDLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ACTION_DOWN</code> 与 <code>shouldInterceptTouchEvent</code> 中的差不多。当进入到 <code>ACTION_MOVE</code> 的时候，先判断 mDragState 是否为 <code>STATE_DRAGGING</code> ，而唯一调用 <code>setDragState(STATE_DRAGGING)</code> 的地方就是 <code>tryCaptureViewForDrag()</code> 了， 刚才在 <code>ACTION_DOWN</code> 里调用过 <code>tryCaptureViewForDrag()</code> 。当为 <code>STATE_DRAGGING</code> 的时候，开始不停的调用 <code>dragTo()</code> 对 mCaptureView 进行真正拖动了。而 <code>dragTo()</code> 通过调用 <code>offsetLeftAndRight()</code> 和 <code>offsetTopAndBottom()</code> 来完成对 mCapturedView 移动。在 <code>dispatchViewReleased()</code> 的注释里面有介绍了两个方法，<code>settleCapturedViewAt(int, int)</code> 和 <code>flingCapturedView(int, int, int, int)</code> ：</p>
<h3 id="settleCapturedViewAt-amp-amp-flingCapturedView"><a href="#settleCapturedViewAt-amp-amp-flingCapturedView" class="headerlink" title="settleCapturedViewAt &amp;&amp; flingCapturedView"></a>settleCapturedViewAt &amp;&amp; flingCapturedView</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewDragHelper</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Settle the captured view at the given (left, top) position.</span><br><span class="line">     * The appropriate velocity from prior motion will be taken into account.</span><br><span class="line">     * If this method returns true, the caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125;</span><br><span class="line">     * on each subsequent frame to continue the motion until it returns false. If this method</span><br><span class="line">     * returns false there is no further work to do to complete the movement.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> finalLeft Settled left edge position for the captured view</span><br><span class="line">     * <span class="doctag">@param</span> finalTop Settled top edge position for the captured view</span><br><span class="line">     * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">settleCapturedViewAt</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mReleaseInProgress) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot settleCapturedViewAt outside of a call to "</span> +</span><br><span class="line">                    <span class="string">"Callback#onViewReleased"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> forceSettleCapturedViewAt(finalLeft, finalTop,</span><br><span class="line">                (<span class="keyword">int</span>) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">                (<span class="keyword">int</span>) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Settle the captured view at the given (left, top) position.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> finalLeft Target left position for the captured view</span><br><span class="line">     * <span class="doctag">@param</span> finalTop Target top position for the captured view</span><br><span class="line">     * <span class="doctag">@param</span> xvel Horizontal velocity</span><br><span class="line">     * <span class="doctag">@param</span> yvel Vertical velocity</span><br><span class="line">     * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">forceSettleCapturedViewAt</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop, <span class="keyword">int</span> xvel, <span class="keyword">int</span> yvel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> startLeft = mCapturedView.getLeft();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> startTop = mCapturedView.getTop();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dx = finalLeft - startLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dy = finalTop - startTop;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dx == <span class="number">0</span> &amp;&amp; dy == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Nothing to do. Send callbacks, be done.</span></span><br><span class="line">            mScroller.abortAnimation();</span><br><span class="line">            setDragState(STATE_IDLE);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> duration = computeSettleDuration(mCapturedView, dx, dy, xvel, yvel);</span><br><span class="line">        mScroller.startScroll(startLeft, startTop, dx, dy, duration);<span class="comment">//靠Scroll类完成</span></span><br><span class="line"></span><br><span class="line">        setDragState(STATE_SETTLING);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeSettleDuration</span><span class="params">(View child, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> xvel, <span class="keyword">int</span> yvel)</span> </span>&#123;</span><br><span class="line">        xvel = clampMag(xvel, (<span class="keyword">int</span>) mMinVelocity, (<span class="keyword">int</span>) mMaxVelocity);</span><br><span class="line">        yvel = clampMag(yvel, (<span class="keyword">int</span>) mMinVelocity, (<span class="keyword">int</span>) mMaxVelocity);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> absDx = Math.abs(dx);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> absDy = Math.abs(dy);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> absXVel = Math.abs(xvel);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> absYVel = Math.abs(yvel);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> addedVel = absXVel + absYVel;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> addedDistance = absDx + absDy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> xweight = xvel != <span class="number">0</span> ? (<span class="keyword">float</span>) absXVel / addedVel :</span><br><span class="line">                (<span class="keyword">float</span>) absDx / addedDistance;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> yweight = yvel != <span class="number">0</span> ? (<span class="keyword">float</span>) absYVel / addedVel :</span><br><span class="line">                (<span class="keyword">float</span>) absDy / addedDistance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> xduration = computeAxisDuration(dx, xvel, mCallback.getViewHorizontalDragRange(child));</span><br><span class="line">        <span class="keyword">int</span> yduration = computeAxisDuration(dy, yvel, mCallback.getViewVerticalDragRange(child));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (xduration * xweight + yduration * yweight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeAxisDuration</span><span class="params">(<span class="keyword">int</span> delta, <span class="keyword">int</span> velocity, <span class="keyword">int</span> motionRange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果给定的速率velocity不为0，就通过距离除以速率来算出时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> width = mParentView.getWidth();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfWidth = width / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> distanceRatio = Math.min(<span class="number">1f</span>, (<span class="keyword">float</span>) Math.abs(delta) / width);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> distance = halfWidth + halfWidth *</span><br><span class="line">                distanceInfluenceForSnapDuration(distanceRatio);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> duration;</span><br><span class="line">        velocity = Math.abs(velocity);</span><br><span class="line">        <span class="keyword">if</span> (velocity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            duration = <span class="number">4</span> * Math.round(<span class="number">1000</span> * Math.abs(distance / velocity));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> range = (<span class="keyword">float</span>) Math.abs(delta) / motionRange;</span><br><span class="line">            duration = (<span class="keyword">int</span>) ((range + <span class="number">1</span>) * BASE_SETTLE_DURATION);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(duration, MAX_SETTLE_DURATION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Clamp the magnitude of value for absMin and absMax.</span><br><span class="line">     * If the value is below the minimum, it will be clamped to zero.</span><br><span class="line">     * If the value is above the maximum, it will be clamped to the maximum.</span><br><span class="line">     * 确保参数中给定的速率在正常范围之内</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> value Value to clamp</span><br><span class="line">     * <span class="doctag">@param</span> absMin Absolute value of the minimum significant value to return</span><br><span class="line">     * <span class="doctag">@param</span> absMax Absolute value of the maximum value to return</span><br><span class="line">     * <span class="doctag">@return</span> The clamped value with the same sign as &lt;code&gt;value&lt;/code&gt;</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">clampMag</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> absMin, <span class="keyword">int</span> absMax)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> absValue = Math.abs(value);</span><br><span class="line">        <span class="keyword">if</span> (absValue &lt; absMin) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (absValue &gt; absMax) <span class="keyword">return</span> value &gt; <span class="number">0</span> ? absMax : -absMax;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Settle the captured view based on standard free-moving fling behavior.</span><br><span class="line">     * The caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; on each subsequent frame</span><br><span class="line">     * to continue the motion until it returns false.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> minLeft Minimum X position for the view's left edge</span><br><span class="line">     * <span class="doctag">@param</span> minTop Minimum Y position for the view's top edge</span><br><span class="line">     * <span class="doctag">@param</span> maxLeft Maximum X position for the view's left edge</span><br><span class="line">     * <span class="doctag">@param</span> maxTop Maximum Y position for the view's top edge</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flingCapturedView</span><span class="params">(<span class="keyword">int</span> minLeft, <span class="keyword">int</span> minTop, <span class="keyword">int</span> maxLeft, <span class="keyword">int</span> maxTop)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mReleaseInProgress) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot flingCapturedView outside of a call to "</span> +</span><br><span class="line">                    <span class="string">"Callback#onViewReleased"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mScroller.fling(mCapturedView.getLeft(), mCapturedView.getTop(),</span><br><span class="line">                (<span class="keyword">int</span>) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">                (<span class="keyword">int</span>) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),</span><br><span class="line">                minLeft, maxLeft, minTop, maxTop);</span><br><span class="line"></span><br><span class="line">        setDragState(STATE_SETTLING);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法里一开始都会判断 mReleaseInProgress 为 false ，如果为 false 就会抛一个 IllegalStateException 异常， 而 mReleaseInProgress 唯一为true的时候就是在 <code>dispatchViewReleased()</code> 里调用 <code>onViewReleased()</code> 的时候。<code>settleCapturedViewAt(int finalLeft, int finalTop)</code> 以松手前的滑动速度为初速动，让捕获到的 View 自动滚动到指定位置。只能在 Callback 的 <code>onViewReleased()</code> 中调用。<code>flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)</code>  以松手前的滑动速度为初速动，让捕获到的 View 在指定范围内 fling ，也只能在 Callback 的 <code>onViewReleased()</code> 中调用。</p>
<h3 id="smoothSlideViewTo"><a href="#smoothSlideViewTo" class="headerlink" title="smoothSlideViewTo"></a>smoothSlideViewTo</h3><p>ViewDragHelper 还有一个移动 View 的方法是 smoothSlideViewTo(View child, int finalLeft, int finalTop)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewDragHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Animate the view &lt;code&gt;child&lt;/code&gt; to the given (left, top) position.</span><br><span class="line">     * If this method returns true, the caller should invoke &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125;</span><br><span class="line">     * on each subsequent frame to continue the motion until it returns false. If this method</span><br><span class="line">     * returns false there is no further work to do to complete the movement.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This operation does not count as a capture event, though &#123;<span class="doctag">@link</span> #getCapturedView()&#125;</span><br><span class="line">     * will still report the sliding view while the slide is in progress.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> child Child view to capture and animate</span><br><span class="line">     * <span class="doctag">@param</span> finalLeft Final left position of child</span><br><span class="line">     * <span class="doctag">@param</span> finalTop Final top position of child</span><br><span class="line">     * <span class="doctag">@return</span> true if animation should continue through &#123;<span class="doctag">@link</span> #continueSettling(boolean)&#125; calls</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">smoothSlideViewTo</span><span class="params">(View child, <span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">        mCapturedView = child;</span><br><span class="line">        mActivePointerId = INVALID_POINTER;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> continueSliding = forceSettleCapturedViewAt(finalLeft, finalTop, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!continueSliding &amp;&amp; mDragState == STATE_IDLE &amp;&amp; mCapturedView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If we're in an IDLE state to begin with and aren't moving anywhere, we</span></span><br><span class="line">            <span class="comment">// end up having a non-null capturedView with an IDLE dragState</span></span><br><span class="line">            mCapturedView = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> continueSliding;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它不受 mReleaseInProgress 的限制，所以可以在任何地方调用，效果和 <code>settleCapturedViewAt()</code> 类似，因为它们最终都调用了 <code>forceSettleCapturedViewAt()</code> 来启动自动滚动，区别在于 <code>settleCapturedViewAt()</code> 会以最后松手前的滑动速率为初速度将 View 滚动到最终位置，而 <code>smoothSlideViewTo()</code> 滚动的初速度是0。 <code>smoothSlideViewTo(View child, int finalLeft, int finalTop)</code> 指定某个 View 自动滚动到指定的位置，初速度为 0 ，可在任何地方调用。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/07/27/rxmarkdown/" class="prev">上一篇</a><a href="/2016/06/05/arraymap-analyse/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yydcdut.com">yydcdut</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>