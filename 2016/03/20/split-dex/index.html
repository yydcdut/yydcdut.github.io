<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android Dex分包之旅 · Android杂文 - yydcdut</title><meta name="description" content="Android Dex分包之旅 - yydcdut"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yydcdut.com/atom.xml" title="Android杂文 - yydcdut"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut/yydcdut.github.io/issues" target="_blank" class="nav-list-link">COMMENT</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android Dex分包之旅</h1><div class="post-info">2016年3月20日</div><div class="post-content"><p>当程序越来越大之后，出现了一个 dex 包装不下的情况，通过 <code>MultiDex</code> 的方法解决了这个问题，但是在底端机器上又出现了 <code>INSTALL_FAILED_DEXOPT</code> 的情况，那再解决这个问题吧。等解决完这个问题之后，发现需要填的坑越来越多了，文章讲的是我在分包处理中填的坑，比如 65536、LinearAlloc、NoClassDefFoundError等等。</p>
<a id="more"></a>
<h2 id="INSTALL-FAILED-DEXOPT"><a href="#INSTALL-FAILED-DEXOPT" class="headerlink" title="INSTALL_FAILED_DEXOPT"></a>INSTALL_FAILED_DEXOPT</h2><p>INSTALL_FAILED_DEXOPT 出现的原因大部分都是两种，一种是 65536 了，另外一种是 <code>LinearAlloc</code> 太小了。两者的限制不同，但是原因却是相似，那就是App太大了，导致没办法安装到手机上。</p>
<h3 id="65536"><a href="#65536" class="headerlink" title="65536"></a>65536</h3><blockquote>
<p>trouble writing output: Too many method references: 70048; max is 65536.</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>UNEXPECTED TOP-LEVEL EXCEPTION: java.lang.IllegalArgumentException: method ID not in [0, 0xffff]: 65536<br>​    at com.android.dx.merge.DexMerger$6.updateIndex(DexMerger.java:501)<br>​    at com.android.dx.merge.DexMerger$IdMerger.mergeSorted(DexMerger.java:276)<br>​    at com.android.dx.merge.DexMerger.mergeMethodIds(DexMerger.java:490)<br>​    at com.android.dx.merge.DexMerger.mergeDexes(DexMerger.java:167)<br>​    at com.android.dx.merge.DexMerger.merge(DexMerger.java:188)<br>​    at com.android.dx.command.dexer.Main.mergeLibraryDexBuffers(Main.java:439)<br>​    at com.android.dx.command.dexer.Main.runMonoDex(Main.java:287)<br>​    at com.android.dx.command.dexer.Main.run(Main.java:230)<br>​    at com.android.dx.command.dexer.Main.main(Main.java:199)<br>​    at com.android.dx.command.Main.main(Main.java:103):Derp:dexDerpDebug FAILED</p>
</blockquote>
<h4 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:1.3.0'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">23</span></span><br><span class="line">    buildToolsVersion <span class="string">"24.0.0rc1"</span></span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion <span class="number">14</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span></span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为什么是65536"><a href="#为什么是65536" class="headerlink" title="为什么是65536"></a>为什么是65536</h4><p>根据  <a href="http://stackoverflow.com/questions/21490382/does-the-android-art-runtime-have-the-same-method-limit-limitations-as-dalvik/21492160#21492160" target="_blank" rel="external">StackOverFlow – Does the Android ART runtime have the same method limit limitations as Dalvik?</a> 上面的说法，是因为 Dalvik 的 invoke-kind 指令集中，method reference index 只留了 16 bits，最多能<strong>引用</strong> 65535 个方法。<a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html" target="_blank" rel="external">Dalvik bytecode</a> ：</p>
<blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">Op &amp; Format</th>
<th>Mnemonic / Syntax</th>
<th>Arguments</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6e..72 35c</td>
<td>invoke-<em>kind</em> {vC, vD, vE, vF, vG}, meth@BBBB6e: invoke-virtual6f: invoke-super70: invoke-direct71: invoke-static72: invoke-interface</td>
<td><code>A:</code> argument word count (4 bits)<code>B:</code> method reference index (16 bits)<code>C..G:</code> argument registers (4 bits each)</td>
</tr>
</tbody>
</table>
</blockquote>
<p>即使 dex 里面的引用方法数超过了 65536，那也只有前面的 65536 得的到调用。所以这个不是 dex 的原因。其次，既然和 dex 没有关系，那在打包 dex 的时候为什么会报错。我们先定位 <code>Too many</code> 关键字，定位到了 <a href="https://github.com/yydcdut/platform_dalvik/blob/master/dx/src/com/android/dx/dex/file/MemberIdsSection.java" target="_blank" rel="external">MemberIdsSection</a> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberIdsSection</span> <span class="keyword">extends</span> <span class="title">UniformItemSection</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** &#123;<span class="doctag">@inheritDoc</span>&#125; */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">orderItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (items().size() &gt; DexFormat.MAX_MEMBER_IDX + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DexIndexOverflowException(getTooManyMembersMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object i : items()) &#123;</span><br><span class="line">            ((MemberIdItem) i).setIndex(idx);</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getTooManyMembersMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, AtomicInteger&gt; membersByPackage = <span class="keyword">new</span> TreeMap&lt;String, AtomicInteger&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Object member : items()) &#123;</span><br><span class="line">            String packageName = ((MemberIdItem) member).getDefiningClass().getPackageName();</span><br><span class="line">            AtomicInteger count = membersByPackage.get(packageName);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;</span><br><span class="line">                count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">                membersByPackage.put(packageName, count);</span><br><span class="line">            &#125;</span><br><span class="line">            count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Formatter formatter = <span class="keyword">new</span> Formatter();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String memberType = <span class="keyword">this</span> <span class="keyword">instanceof</span> MethodIdsSection ? <span class="string">"method"</span> : <span class="string">"field"</span>;</span><br><span class="line">            formatter.format(<span class="string">"Too many %s references: %d; max is %d.%n"</span> +</span><br><span class="line">                    Main.getTooManyIdsErrorMessage() + <span class="string">"%n"</span> +</span><br><span class="line">                    <span class="string">"References by package:"</span>,</span><br><span class="line">                    memberType, items().size(), DexFormat.MAX_MEMBER_IDX + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, AtomicInteger&gt; entry : membersByPackage.entrySet()) &#123;</span><br><span class="line">                formatter.format(<span class="string">"%n%6d %s"</span>, entry.getValue().get(), entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> formatter.toString();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            formatter.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>items().size() &gt; DexFormat.MAX_MEMBER_IDX + 1</code> ，那 <a href="https://github.com/yydcdut/android_libcore/blob/kitkat/dex/src/main/java/com/android/dex/DexFormat.java" target="_blank" rel="external">DexFormat</a> 的值是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexFormat</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">     * Maximum addressable field or method index.</span><br><span class="line">     * The largest addressable member is 0xffff, in the "instruction formats" spec as field<span class="doctag">@CCCC</span> or</span><br><span class="line">     * meth<span class="doctag">@CCCC</span>.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_MEMBER_IDX = <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dx 在这里做了判断，当大于 65536 的时候就抛出异常了。所以在生成 dex 文件的过程中，当调用方法数不能超过 65535 。那我们再跟一跟代码，发现 <code>MemberIdsSection</code> 的一个子类叫  <a href="https://github.com/yydcdut/platform_dalvik/blob/master/dx/src/com/android/dx/dex/file/MethodIdsSection.java" target="_blank" rel="external">MethodidsSection</a> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodIdsSection</span> <span class="keyword">extends</span> <span class="title">MemberIdsSection</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>回过头来，看一下 <code>orderItems()</code> 方法在哪里被调用了，跟到了 <code>MemberIdsSection</code> 的父类 <a href="https://github.com/yydcdut/platform_dalvik/blob/master/dx/src/com/android/dx/dex/file/UniformItemSection.java" target="_blank" rel="external">UniformItemSection</a> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UniformItemSection</span> <span class="keyword">extends</span> <span class="title">Section</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepare0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DexFile file = getFile();</span><br><span class="line"></span><br><span class="line">        orderItems();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Item one : items()) &#123;</span><br><span class="line">            one.addContents(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">orderItems</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再跟一下 <code>prepare0</code> 在哪里被调用，查到了 <code>UniformItemSection</code> 父类 <a href="https://github.com/yydcdut/platform_dalvik/blob/master/dx/src/com/android/dx/dex/file/Section.java" target="_blank" rel="external">Section</a> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Section</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        throwIfPrepared();</span><br><span class="line">        prepare0();</span><br><span class="line">        prepared = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare0</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那现在再跟一下 <code>prepare()</code> ，查到 <a href="https://github.com/yydcdut/platform_dalvik/blob/master/dx/src/com/android/dx/dex/file/DexFile.java" target="_blank" rel="external">DexFile</a> 中有调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexFile</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> ByteArrayAnnotatedOutput <span class="title">toDex0</span><span class="params">(<span class="keyword">boolean</span> annotate, <span class="keyword">boolean</span> verbose)</span> </span>&#123;</span><br><span class="line">        classDefs.prepare();</span><br><span class="line">        classData.prepare();</span><br><span class="line">        wordData.prepare();</span><br><span class="line">        byteData.prepare();</span><br><span class="line">        methodIds.prepare();</span><br><span class="line">        fieldIds.prepare();</span><br><span class="line">        protoIds.prepare();</span><br><span class="line">        typeLists.prepare();</span><br><span class="line">        typeIds.prepare();</span><br><span class="line">        stringIds.prepare();</span><br><span class="line">        stringData.prepare();</span><br><span class="line">        header.prepare();</span><br><span class="line">		<span class="comment">//blablabla......</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那再看一下 <code>toDex0()</code> 吧，因为是 private 的，直接在类中找调用的地方就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexFile</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">byte</span>[] toDex(Writer humanOut, <span class="keyword">boolean</span> verbose) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">boolean</span> annotate = (humanOut != <span class="keyword">null</span>);</span><br><span class="line">        ByteArrayAnnotatedOutput result = toDex0(annotate, verbose);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (annotate) &#123;</span><br><span class="line">            result.writeAnnotationsTo(humanOut);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.getArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(OutputStream out, Writer humanOut, <span class="keyword">boolean</span> verbose)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> annotate = (humanOut != <span class="keyword">null</span>);</span><br><span class="line">        ByteArrayAnnotatedOutput result = toDex0(annotate, verbose);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">            out.write(result.getArray());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (annotate) &#123;</span><br><span class="line">            result.writeAnnotationsTo(humanOut);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先搜搜 <code>toDex()</code> 方法吧，最终发现在 <a href="https://github.com/yydcdut/platform_dalvik/blob/master/dx/src/com/android/dx/command/dexer/Main.java" target="_blank" rel="external">com.android.dx.command.dexer.Main</a> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] writeDex(DexFile outputDex) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] outArray = <span class="keyword">null</span>;</span><br><span class="line">      	<span class="comment">//blablabla......</span></span><br><span class="line">		<span class="keyword">if</span> (args.methodToDump != <span class="keyword">null</span>) &#123;</span><br><span class="line">			outputDex.toDex(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">            dumpMethod(outputDex, args.methodToDump, humanOutWriter);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			outArray = outputDex.toDex(humanOutWriter, args.verboseDump);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//blablabla......</span></span><br><span class="line">        <span class="keyword">return</span> outArray;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//调用writeDex的地方</span></span><br><span class="line">  	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runMonoDex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  		<span class="comment">//blablabla......</span></span><br><span class="line">      	outArray = writeDex(outputDex);</span><br><span class="line">      	<span class="comment">//blablabla......</span></span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">//调用runMonoDex的地方</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(Arguments arguments)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  		<span class="keyword">if</span> (args.multiDex) &#123;</span><br><span class="line">			<span class="keyword">return</span> runMultiDex();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> runMonoDex();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>args.multiDex</code> 就是是否分包的参数，那么问题找着了，如果不选择分包的情况下，引用方法数超过了 65536 的话就会抛出异常。</p>
<p>同样分析第二种情况，根据错误信息可以具体定位到代码，但是很奇怪的是 <code>DexMerger</code> ，我们没有设置分包参数或者其他参数，为什么会有 <code>DexMerger</code> ，而且依赖工程最终不都是 aar 格式的吗？那我们还是来跟一跟代码吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] mergeLibraryDexBuffers(<span class="keyword">byte</span>[] outArray) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ArrayList&lt;Dex&gt; dexes = <span class="keyword">new</span> ArrayList&lt;Dex&gt;();</span><br><span class="line">        <span class="keyword">if</span> (outArray != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dexes.add(<span class="keyword">new</span> Dex(outArray));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span>[] libraryDex : libraryDexBuffers) &#123;</span><br><span class="line">            dexes.add(<span class="keyword">new</span> Dex(libraryDex));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dexes.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Dex merged = <span class="keyword">new</span> DexMerger(dexes.toArray(<span class="keyword">new</span> Dex[dexes.size()]), CollisionPolicy.FAIL).merge();</span><br><span class="line">        <span class="keyword">return</span> merged.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到变量 <code>libraryDexBuffers</code> ，是一个 List 集合，那么我们看一下这个集合在哪里添加数据的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">processFileBytes</span><span class="params">(String name, <span class="keyword">long</span> lastModified, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">boolean</span> isClassesDex = name.equals(DexFormat.DEX_IN_JAR_NAME);</span><br><span class="line">      	<span class="comment">//blablabla...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isClassesDex) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (libraryDexBuffers) &#123;</span><br><span class="line">                libraryDexBuffers.add(bytes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">//blablabla...</span></span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">//调用processFileBytes的地方</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FileBytesConsumer</span> <span class="keyword">implements</span> <span class="title">ClassPathOpener</span>.<span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processFileBytes</span><span class="params">(String name, <span class="keyword">long</span> lastModified,</span><br><span class="line">                <span class="keyword">byte</span>[] bytes)</span>   </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Main.processFileBytes(name, lastModified, bytes);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//blablabla...</span></span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//调用FileBytesConsumer的地方</span></span><br><span class="line">  	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processOne</span><span class="params">(String pathname, FileNameFilter filter)</span> </span>&#123;</span><br><span class="line">        ClassPathOpener opener;</span><br><span class="line"></span><br><span class="line">        opener = <span class="keyword">new</span> ClassPathOpener(pathname, <span class="keyword">true</span>, filter, <span class="keyword">new</span> FileBytesConsumer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opener.process()) &#123;</span><br><span class="line">          updateStatus(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//调用processOne的地方</span></span><br><span class="line">  	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">processAllFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//blablabla...</span></span><br><span class="line">  		<span class="comment">// forced in main dex</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileNames.length; i++) &#123;</span><br><span class="line">			processOne(fileNames[i], mainPassFilter);</span><br><span class="line">		&#125;</span><br><span class="line">      	<span class="comment">//blablabla...</span></span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">//调用processAllFiles的地方</span></span><br><span class="line">  	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runMonoDex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">//blablabla...</span></span><br><span class="line">  		<span class="keyword">if</span> (!processAllFiles()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//blablabla...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟了一圈又跟回来了，但是注意一个变量：<code>fileNames[i]</code>，传进去这个变量，是个地址，最终在 <code>processFileBytes</code> 中处理后添加到 <code>libraryDexBuffers</code> 中，那跟一下这个变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">processAllFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//blablabla...</span></span><br><span class="line">  		String[] fileNames = args.fileNames;</span><br><span class="line">      	<span class="comment">//blablabla...</span></span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//blablabla...</span></span><br><span class="line">    	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(parser.isArg(INPUT_LIST_OPTION + <span class="string">"="</span>)) &#123;</span><br><span class="line">			File inputListFile = <span class="keyword">new</span> File(parser.getLastValue());</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				inputList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                readPathsFromFile(inputListFile.getAbsolutePath(), inputList);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">				System.err.println(<span class="string">"Unable to read input list file: "</span> + inputListFile.getName());</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> UsageException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">//blablabla...</span></span><br><span class="line">  		fileNames = parser.getRemaining();</span><br><span class="line">		<span class="keyword">if</span>(inputList != <span class="keyword">null</span> &amp;&amp; !inputList.isEmpty()) &#123;</span><br><span class="line">            inputList.addAll(Arrays.asList(fileNames));</span><br><span class="line">            fileNames = inputList.toArray(<span class="keyword">new</span> String[inputList.size()]);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argArray)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Arguments arguments = <span class="keyword">new</span> Arguments();</span><br><span class="line">        arguments.parse(argArray);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = run(arguments);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            System.exit(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟到这里发现是传进来的参数，那我们再看看 gradle 里面传的是什么参数吧，查看 <a href="https://github.com/yydcdut/android_tools_base/blob/mm/build-system/gradle-core/src/main/groovy/com/android/build/gradle/tasks/Dex.groovy" target="_blank" rel="external">Dex</a> task :</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dex</span> <span class="keyword">extends</span> <span class="title">BaseTask</span> &#123;</span></span><br><span class="line">  	<span class="annotation">@InputFiles</span></span><br><span class="line">    Collection&lt;File&gt; libraries</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把这个参数打印出来：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">afterEvaluate &#123;</span><br><span class="line">    tasks.matching &#123;</span><br><span class="line">        it.name.startsWith(<span class="string">'dex'</span>)</span><br><span class="line">    &#125;.each &#123; dx -&gt;</span><br><span class="line">        <span class="keyword">if</span> (dx.additionalParameters == <span class="literal">null</span>) &#123;</span><br><span class="line">            dx.additionalParameters = []</span><br><span class="line">        &#125;</span><br><span class="line">        println dx.libraries</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出来发现是 <code>build/intermediates/pre-dexed/</code> 目录里面的 jar 文件，再把 jar 文件解压发现里面就是 dex 文件了。所以 <code>DexMerger</code> 的工作就是合并这里的 dex 。</p>
<h4 id="更改编译环境"><a href="#更改编译环境" class="headerlink" title="更改编译环境"></a>更改编译环境</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.1.0-alpha3'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 gradle 设置为 2.1.0-alpha3 之后，在项目的 <code>build.gradle</code> 中即使没有设置 <code>multiDexEnabled true</code> 也能够编译通过，但是生成的 apk 包依旧是两个 dex ，我想的是可能为了设置 <code>instantRun</code> 。</p>
<h4 id="解决-65536"><a href="#解决-65536" class="headerlink" title="解决 65536"></a>解决 65536</h4><p>Google MultiDex 解决方案：</p>
<p>在 gradle 中添加 <code>MultiDex</code> 的依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123; compile <span class="string">'com.android.support:MultiDex:1.0.0'</span> &#125;</span><br></pre></td></tr></table></figure>
<p>在 gradle 中配置 <code>MultiDexEnable</code> :</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">	buildToolsVersion <span class="string">"21.1.0"</span></span><br><span class="line">	defaultConfig &#123;</span><br><span class="line">        <span class="comment">// Enabling MultiDex support.</span></span><br><span class="line">        MultiDexEnabled <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 AndroidManifest.xml 的 application 中声明:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">application</span></span><br><span class="line">  <span class="attribute">android:name</span>=<span class="value">"android.support.multidex.MultiDexApplication"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">application</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果有自己的 Application 了，让其继承于 MultiDexApplication 。</p>
<p>如果继承了其他的 Application ，那么可以重写 <code>attachBaseContext(Context)</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">    MultiDex.install(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LinearAlloc"><a href="#LinearAlloc" class="headerlink" title="LinearAlloc"></a>LinearAlloc</h3><blockquote>
<p>ERROR/dalvikvm(4620): LinearAlloc exceeded capacity (5242880), last=…</p>
</blockquote>
<h4 id="LinearAlloc-是什么"><a href="#LinearAlloc-是什么" class="headerlink" title="LinearAlloc 是什么"></a>LinearAlloc 是什么</h4><p>LinearAlloc 主要用来管理 Dalvik 中 class 加载时的内存，就是让 App 在执行时减少系统内存的占用。在 App 的安装过程中，系统会运行一个名为 dexopt 的程序为该应用在当前机型中运行做准备。dexopt 使用 LinearAlloc 来存储应用的方法信息。App 在执行前会将 class 读进 LinearAlloc 这个 buffer 中，这个 LinearAlloc 在 Android 2.3 之前是 4M 或 5M ，到 4.0 之后变为 8M 或 16M。因为 5M 实在是太小了，可能还没有 65536 就已经超过 5M 了，什么意思呢，就是只有一个包的情况下也有可能出现 INSTALL_FAILED_DEXOPT ，原因就在于 LinearAlloc。</p>
<h4 id="解决-LinearAlloc"><a href="#解决-LinearAlloc" class="headerlink" title="解决 LinearAlloc"></a>解决 LinearAlloc</h4><p>gradle：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">afterEvaluate &#123; </span><br><span class="line">  tasks.matching &#123; </span><br><span class="line">    it.name.startsWith(<span class="string">'dex'</span>) </span><br><span class="line">  &#125;.each &#123; dx -&gt; </span><br><span class="line">    <span class="keyword">if</span> (dx.additionalParameters == <span class="literal">null</span>) &#123; </span><br><span class="line">      dx.additionalParameters = []</span><br><span class="line">    &#125;  </span><br><span class="line">    dx.additionalParameters += <span class="string">'--set-max-idx-number=48000'</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>--set-max-idx-number=</code> 用于控制每一个 dex 的最大方法个数。</p>
<p>这个参数在查看 dx.jar 找到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//blablabla...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parser.isArg(<span class="string">"--set-max-idx-number="</span>)) &#123; <span class="comment">// undocumented test option</span></span><br><span class="line">  maxNumberOfIdxPerDex = Integer.parseInt(parser.getLastValue());</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(parser.isArg(INPUT_LIST_OPTION + <span class="string">"="</span>)) &#123;</span><br><span class="line"><span class="comment">//blablabla...</span></span><br></pre></td></tr></table></figure>
<p>更多细节可以查看源码：<a href="https://github.com/yydcdut/platform_dalvik/blob/master/dx/src/com/android/dx/command/dexer/Main.java" target="_blank" rel="external">Github – platform_dalvik/Main</a></p>
<p>FB 的工程师们曾经还想到过直接修改 LinearAlloc 的大小，比如从 5M 修改到 8M： <a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-dalvik-patch-for-facebook-for-android/10151345597798920" target="_blank" rel="external">Under the Hood: Dalvik patch for Facebook for Android</a> 。</p>
<h2 id="dexopt-amp-amp-dex2oat"><a href="#dexopt-amp-amp-dex2oat" class="headerlink" title="dexopt &amp;&amp; dex2oat"></a>dexopt &amp;&amp; dex2oat</h2><p><img src="http://7xs03u.com1.z0.glb.clouddn.com/dex_dexopt_dex2oat.png" alt="dexopt_dex2oat"></p>
<h3 id="dexopt"><a href="#dexopt" class="headerlink" title="dexopt"></a>dexopt</h3><p>当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 是在第一次加载 Dex 文件的时候执行的，将 dex 的依赖库文件和一些辅助数据打包成 odex 文件，即 Optimised Dex，存放在 cache/dalvik_cache 目录下。保存格式为 <code>apk路径 @ apk名 @ classes.dex</code> 。执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。</p>
<p>更多可查看 <a href="http://www.netmite.com/android/mydroid/dalvik/docs/dexopt.html" target="_blank" rel="external">Dalvik Optimization and Verification With <em>dexopt</em></a> 。</p>
<h3 id="dex2oat"><a href="#dex2oat" class="headerlink" title="dex2oat"></a>dex2oat</h3><p>Android Runtime 的 dex2oat 是将 dex 文件编译成 oat 文件。而 oat 文件是 elf 文件，是可以在本地执行的文件，而 Android Runtime 替换掉了虚拟机读取的字节码转而用本地可执行代码，这就被叫做 AOT(ahead-of-time)。dex2oat 对所有 apk 进行编译并保存在 dalvik-cache 目录里。PackageManagerService 会持续扫描安装目录，如果有新的 App 安装则马上调用 dex2oat 进行编译。</p>
<p>更多可查看  <a href="http://blog.csdn.net/luoshengyang/article/details/39256813" target="_blank" rel="external">Android运行时ART简要介绍和学习计划</a> 。</p>
<h2 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h2><p>现在 INSTALL_FAILED_DEXOPT 问题是解决了，但是有时候编译完运行的时候一打开 App 就 crash 了，查看 log 发现是某个类找不到引用。</p>
<h3 id="Build-Tool-是如何分包的"><a href="#Build-Tool-是如何分包的" class="headerlink" title="Build Tool 是如何分包的"></a>Build Tool 是如何分包的</h3><p>为什么会这样呢？是因为 build-tool 在分包的时候只判断了直接引用类。什么是直接引用类呢？举个栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        DirectReferenceClass test = <span class="keyword">new</span> DirectReferenceClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectReferenceClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectReferenceClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InDirectReferenceClass test = <span class="keyword">new</span> InDirectReferenceClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InDirectReferenceClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InDirectReferenceClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面有 MainActivity、DirectReferenceClass 、InDirectReferenceClass 三个类，其中 DirectReferenceClass 是 MainActivity 的直接引用类，InDirectReferenceClass 是 DirectReferenceClass 的直接引用类。而 InDirectReferenceClass 是 MainActivity 的间接引用类(即直接引用类的所有直接引用类)。</p>
<p>如果我们代码是这样写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloMultiDexApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">        DirectReferenceClass test = <span class="keyword">new</span> DirectReferenceClass();</span><br><span class="line">        MultiDex.install(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样直接就 crash 了。同理还要单例模式中拿到单例之后直接调用某个方法返回的是另外一个对象，并非单例对象。</p>
<p>build tool 的分包操作可以查看 sdk 中 build-tools 文件夹下的 <code>mainDexClasses</code> 脚本，同时还发现了 <code>mainDexClasses.rules</code> 文件，该文件是主 dex 的匹配规则。该脚本要求输入一个文件组（包含编译后的目录或jar包），然后分析文件组中的类并写入到–output所指定的文件中。实现原理也不复杂，主要分为三步：</p>
<ol>
<li>环境检查，包括传入参数合法性检查，路径检查以及proguard环境检测等。</li>
<li>使用mainDexClasses.rules规则，通过Proguard的shrink功能，裁剪无关类，生成一个tmp.jar包。</li>
<li>通过生成的tmp jar包，调用MainDexListBuilder类生成主dex的文件列表。</li>
</ol>
<p>更多细节可以查看源码：<a href="https://github.com/yydcdut/platform_dalvik/blob/0be69b5268823139b04411f6a8e15cb58f54ddae/dx/src/com/android/multidex/MainDexListBuilder.java" target="_blank" rel="external">Github – platform_dalvik/MainDexListBuilder</a></p>
<h3 id="Gradle-打包流程中是如何分包的"><a href="#Gradle-打包流程中是如何分包的" class="headerlink" title="Gradle 打包流程中是如何分包的"></a>Gradle 打包流程中是如何分包的</h3><p>在项目中，可以直接运行 gradle 的 task 。</p>
<ul>
<li><code>collect{flavor}{buildType}MultiDexComponents</code> Task 。这个 task 是获取 AndroidManifest.xml 中 Application 、Activity 、Service 、 Receiver 、 Provider 等相关类，以及 Annotation ，之后将内容写到 <code>build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt</code> 文件中去。</li>
</ul>
<ul>
<li><code>packageAll{flavor}DebugClassesForMultiDex</code> Task 。该 task 是将所有类打包成 jar 文件存在 <code>build/intermediates/multi-dex/{flavor}/debug/allclasses.jar</code> 。 当 BuildType 为 Release 的时候，执行的是 <code>proguard{flavor}Release</code> Task，该 task 将 proguard 混淆后的类打包成 jar 文件存在 <code>build/intermediates/classes-proguard/{flavor}/release/classes.jar</code></li>
<li><code>shrink{flavor}{buildType}MultiDexComponents</code> Task 。该 task 会根据 maindexlist.txt 生成  componentClasses.jar ，该 jar 包里面就只有 maindexlist.txt 里面的类，该 jar 包的位置在 <code>build/intermediates/multi-dex/{flavor}/{buildType}/componentClasses.jar</code></li>
<li><code>create{flavor}{buildType}MainDexClassList</code> Task 。该 task 会根据生成的 componentClasses.jar 去找这里面的所有的 class 中直接依赖的 class ，然后将内容写到 <code>build/intermediates/multi-dex/{flavor}/{buildType}/maindexlist.txt</code> 中。最终这个文件里面列出来的类都会被分配到第一个 dex 里面。</li>
</ul>
<p>更多细节可以查看源码：<a href="https://github.com/yydcdut/android_tools_base/blob/mm/build-system/gradle-core/src/main/groovy/com/android/build/gradle/internal/tasks/multidex/CreateManifestKeepList.groovy" target="_blank" rel="external">Github – android_tools_base</a> 。</p>
<h3 id="解决-NoClassDefFoundError"><a href="#解决-NoClassDefFoundError" class="headerlink" title="解决 NoClassDefFoundError"></a>解决 NoClassDefFoundError</h3><p>gradle :</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">afterEvaluate &#123; </span><br><span class="line">  tasks.matching &#123; </span><br><span class="line">    it.name.startsWith(<span class="string">'dex'</span>) </span><br><span class="line">  &#125;.each &#123; dx -&gt; </span><br><span class="line">    <span class="keyword">if</span> (dx.additionalParameters == <span class="literal">null</span>) &#123; </span><br><span class="line">      dx.additionalParameters = []</span><br><span class="line">    &#125;  </span><br><span class="line">    dx.additionalParameters += <span class="string">'--set-max-idx-number=48000'</span> </span><br><span class="line">    dx.additionalParameters += <span class="string">"--main-dex-list=$projectDir/multidex.keep"</span>.toString()</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>--main-dex-list=</code> 参数是一个类列表的文件，在该文件中的类会被打包在第一个 dex 中。</p>
<p>multidex.keep 里面列上需要打包到第一个 dex 的 class 文件，注意，如果需要混淆的话需要写混淆之后的 class 。</p>
<h2 id="Application-Not-Responding"><a href="#Application-Not-Responding" class="headerlink" title="Application Not Responding"></a>Application Not Responding</h2><p>因为第一次运行（包括清除数据之后）的时候需要 dexopt ，然而 dexopt 是一个比较耗时的操作，同时 <code>MultiDex.install()</code> 操作是在 <code>Application.attachBaseContext()</code> 中进行的，占用的是UI线程。那么问题来了，当我的第二个包、第三个包很大的时候，程序就阻塞在 <code>MultiDex.install()</code> 这个地方了，一旦超过规定时间，那就 ANR 了。那怎么办？放子线程？如果 Application 有一些初始化操作，到初始化操作的地方的时候都还没有完成 install + dexopt 的话，那不是又 NoClassDefFoundError 了吗？同时 ClassLoader 放在哪个线程都让主线程挂起。好了，那在 multidex.keep 的加上相关的所有的类吧。好像这样成了，但是第一个 dex 又大起来了，而且如果用户操作快，还没完成 install + dexopt 但是已经把 App 所以界面都打开了一遍。。。虽然这不现实。。</p>
<h3 id="微信加载方案"><a href="#微信加载方案" class="headerlink" title="微信加载方案"></a>微信加载方案</h3><p>首次加载在地球中页中, 并用线程去加载（但是 5.0 之前加载 dex 时还是会挂起主线程一段时间（不是全程都挂起））。</p>
<ul>
<li><p>dex 形式</p>
<p>微信是将包放在 <code>assets</code> 目录下的，在加载 Dex 的代码时，实际上传进去的是 zip，在加载前需要验证 MD5，确保所加载的 Dex 没有被篡改。</p>
</li>
<li><p>dex 类分包规则</p>
<p>分包规则即将所有 Application、ContentProvider 以及所有 export 的 Activity、Service 、Receiver 的间接依赖集都必须放在主 dex。</p>
</li>
<li><p>加载 dex 的方式</p>
<p>加载逻辑这边主要判断是否已经 dexopt，若已经 dexopt，即放在 attachBaseContext 加载，反之放于地球中用线程加载。怎么判断？因为在微信中，若判断 revision 改变，即将 dex 以及 dexopt 目录清空。只需简单判断两个目录 dex 名称、数量是否与配置文件的一致。</p>
</li>
</ul>
<p>总的来说，这种方案用户体验较好，缺点在于太过复杂，每次都需重新扫描依赖集，而且使用的是比较大的间接依赖集。</p>
<h3 id="Facebook-加载方案"><a href="#Facebook-加载方案" class="headerlink" title="Facebook 加载方案"></a>Facebook 加载方案</h3><p>Facebook的思路是将 <code>MultiDex.install()</code> 操作放在另外一个经常进行的。</p>
<ul>
<li><p>dex 形式</p>
<p>与微信相同。</p>
</li>
<li><p>dex 类分包规则</p>
<p>Facebook 将加载 dex 的逻辑单独放于一个单独的 nodex 进程中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span> </span><br><span class="line"><span class="attribute">android:exported</span>=<span class="value">"false"</span></span><br><span class="line"><span class="attribute">android:process</span>=<span class="value">":nodex"</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.facebook.nodex.startup.splashscreen.NodexSplashActivity"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>所有的依赖集为 Application、NodexSplashActivity 的间接依赖集即可。</p>
</li>
<li><p>加载 dex 的方式</p>
<p>因为 <code>NodexSplashActivity</code> 的 intent-filter 指定为 <code>Main</code> 和 <code>LAUNCHER</code> ，所以一打开 App 首先拉起 nodex 进程，然后打开 <code>NodexSplashActivity</code> 进行 <code>MultiDex.install()</code> 。如果已经进行了 dexpot 操作的话就直接跳转主界面，没有的话就等待 dexpot 操作完成再跳转主界面。</p>
</li>
</ul>
<p>这种方式好处在于依赖集非常简单，同时首次加载 dex 时也不会卡死。但是它的缺点也很明显，即每次启动主进程时，都需先启动 nodex 进程。尽管 nodex 进程逻辑非常简单，这也需100ms以上。</p>
<h3 id="美团加载方案"><a href="#美团加载方案" class="headerlink" title="美团加载方案"></a>美团加载方案</h3><ul>
<li><p>dex 形式</p>
<p>在 gradle 生成 dex 文件的这步中，自定义一个 task 来干预 dex 的生产过程，从而产生多个 dex 。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tasks.whenTaskAdded &#123; task -&gt;</span><br><span class="line">    <span class="keyword">if</span> (task.name.startsWith(<span class="string">'proguard'</span>) &amp;&amp; (task.name.endsWith(<span class="string">'Debug'</span>) || task.name.endsWith(<span class="string">'Release'</span>))) &#123;</span><br><span class="line">        task.doLast &#123;</span><br><span class="line">            makeDexFileAfterProguardJar();</span><br><span class="line">        &#125;</span><br><span class="line">        task.doFirst &#123;</span><br><span class="line">            delete <span class="string">"$&#123;project.buildDir&#125;/intermediates/classes-proguard"</span>;</span><br><span class="line"></span><br><span class="line">            String flavor = task.name.substring(<span class="string">'proguard'</span>.length(), task.name.lastIndexOf(task.name.endsWith(<span class="string">'Debug'</span>) ? "Debug" : <span class="string">"Release"</span>));</span><br><span class="line">            generateMainIndexKeepList(flavor.toLowerCase());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (task.name.startsWith(<span class="string">'zipalign'</span>) &amp;&amp; (task.name.endsWith(<span class="string">'Debug'</span>) || task.name.endsWith(<span class="string">'Release'</span>))) &#123;</span><br><span class="line">        task.doFirst &#123;</span><br><span class="line">            ensureMultiDexInApk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>dex 类分包规则</p>
<p>把 Service、Receiver、Provider 涉及到的代码都放到主 dex 中，而把 Activity 涉及到的代码进行了一定的拆分，把首页 Activity、Laucher Activity 、欢迎页的 Activity 、城市列表页 Activity 等所依赖的 class 放到了主 dex 中，把二级、三级页面的 Activity 以及业务频道的代码放到了第二个  dex 中，为了减少人工分析 class 的依赖所带了的不可维护性和高风险性，美团编写了一个能够自动分析 class 依赖的脚本， 从而能够保证主 dex 包含 class 以及他们所依赖的所有 class 都在其内，这样这个脚本就会在打包之前自动分析出启动到主 dex 所涉及的所有代码，保证主 dex 运行正常。</p>
</li>
<li><p>加载 dex 的方式</p>
<p>通过分析 Activity 的启动过程，发现 Activity 是由 ActivityThread 通过 Instrumentation 来启动的，那么是否可以在 Instrumentation 中做一定的手脚呢？通过分析代码 ActivityThread 和 Instrumentation 发现，Instrumentation 有关 Activity 启动相关的方法大概有：execStartActivity、 newActivity 等等，这样就可以在这些方法中添加代码逻辑进行判断这个 class 是否加载了，如果加载则直接启动这个 Activity，如果没有加载完成则启动一个等待的 Activity 显示给用户，然后在这个 Activity 中等待后台第二个 dex 加载完成，完成后自动跳转到用户实际要跳转的 Activity；这样在代码充分解耦合，以及每个业务代码能够做到颗粒化的前提下，就做到第二个 dex 的按需加载了。</p>
</li>
</ul>
<p>美团的这种方式对主 dex 的要求非常高，因为第二个 dex 是等到需要的时候再去加载。重写Instrumentation 的 execStartActivity 方法，hook 跳转 Activity 的总入口做判断，如果当前第二个 dex 还没有加载完成，就弹一个 loading Activity等待加载完成。</p>
<h3 id="综合加载方案"><a href="#综合加载方案" class="headerlink" title="综合加载方案"></a>综合加载方案</h3><p>微信的方案需要将 dex 放于 <code>assets</code> 目录下，在打包的时候太过负责；Facebook 的方案每次进入都是开启一个 nodex 进程，而我们希望节省资源的同时快速打开 App；美团的方案确实很 hack，但是对于项目已经很庞大，耦合度又比较高的情况下并不适合。所以这里尝试结合三个方案，针对自己的项目来进行优化。</p>
<ul>
<li><p>dex 形式</p>
<p>第一，为了能够继续支持 Android 2.x 的机型，我们将每个包的方法数控制在 48000 个，这样最后分出来 dex 包大约在 5M 左右；第二，为了防止 NoClassDefFoundError 的情况，我们找出来启动页、引导页、首页比较在意的一些类，比如 Fragment 等（因为在生成 maindexlist.txt 的时候只会找 Activity 的直接引用，比如首页 Activity 直接引用 AFragemnt，但是 AFragment 的引用并没有去找）。</p>
</li>
<li><p>dex 类分包规则</p>
<p>第一个包放 Application、Android四大组件以及启动页、引导页、首页的直接引用的 Fragment 的引用类，还放了推送消息过来点击 Notification 之后要展示的 Activity 中的 Fragment 的引用类。</p>
<p>Fragment 的引用类是写了一个脚本，输入需要找的类然后将这些引用类写到 multidex.keep 文件中，如果是 debug 的就直接在生成的 jar 里面找，如果是 release 的话就通过 mapping.txt 找，找不到的话再去 jar 里面找，所以在 gradle 打包的过程中我们人为干扰一下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tasks.whenTaskAdded &#123; task -&gt;</span><br><span class="line">    <span class="keyword">if</span> (task.name.startsWith(<span class="string">"create"</span>) &amp;&amp; task.name.endsWith(<span class="string">"MainDexClassList"</span>)) &#123;</span><br><span class="line">        task.doLast &#123;</span><br><span class="line">            <span class="keyword">def</span> flavorAndBuildType = task.name.substring(<span class="string">"create"</span>.length(), task.name.length() - <span class="string">"MainDexClassList"</span>.length())</span><br><span class="line">            autoSplitDex.configure &#123;</span><br><span class="line">                description = flavorAndBuildType</span><br><span class="line">            &#125;</span><br><span class="line">            autoSplitDex.execute()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细代码可见：<a href="https://github.com/yydcdut/PhotoNoter/blob/master/app/build.gradle" target="_blank" rel="external">Github — PhotoNoter/gradle</a></p>
</li>
<li><p>加载 dex 的方式</p>
<p>在防止 ANR 方面，我们采用了 Facebook 的思路。但是稍微有一点区别，差别在于我们并不在一开启 App 的时候就去起进程，而是一开启 App 的时候在主进程里面判断是否 dexopt 过没，没有的话再去起另外的进程的 Activity 专门做 dexopt 操作 。一旦拉起了去做 dexopt 的进程，那么让主进程进入一个死循环，一直等到 dexopt 进程结束再结束死循环往下走。那么问题来了，第一，主进程进入死循环会 ANR 吗？第二，如何判断是否 dexopt 过；第三，为了界面友好，dexopt 的进程该怎么做；第四，主进程怎么知道 dexopt 进程结束了，也就是怎么去做进程间通信。</p>
<p>一个一个问题的解决，先第一个：因为当拉起 dexopt 进程之后，我们在 dexopt 进程的 Activity 中进行 <code>MultiDex.install()</code> 操作，此时主进程不再是前台进程了，所以不会 ANR 。</p>
<p>第二个问题：因为第一次启动是什么数据都没有的，那么我们就建立一个 <code>SharedPreference</code> ，启动的时候先去从这里获取数据，如果没有数据那么也就是没有 dexopt 过，如果有数据那么肯定是 dexopt 过的，但是这个 <code>SharedPreference</code> 我们得保证我们的程序只有这个地方可以修改，其他地方不能修改。</p>
<p>第三个问题：因为 App 的启动也是一张图片，所以在 dexopt 的 Activity 的 layout 中，我们就把这张图片设置上去就好了，当关闭 dexopt 的 Activity 的时候，我们得关闭 Activity 的动画。同时为了不让 dexopt 进程发生 ANR ，我们将 <code>MultiDex.install()</code> 过程放在了子线程中进行。</p>
<p>第四个问题：Linux 的进程间通信的方式有很多，Android 中还有 Binder 等，那么我们这里采用哪种方式比较好呢？首先想到的是既然 dexopt 进程结束了自然在主进程的死循环中去判断 dexopt 进程是否存在。但是在实际操作中发现，dexopt 虽然已经退出了，但是进程并没有马上被回收掉，所以这个方法走不通。那么用 Broadcast 广播可以吗？可是可以，但是增加了 Application 的负担，在拉起 dexopt 进程前还得注册一个动态广播，接收到广播之后还得注销掉，所以这个也没有采用。那么最终采用的方式是判断文件是否存在，在拉起 dexopt 进程前在某个安全的地方建立一个临时文件，然后死循环判断这个文件是否存在，在 dexopt 进程结束的时候删除这个临时文件，那么在主进程的死循环中发现此文件不存在了，就直接跳出循环，继续 Application 初始化操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoteApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">        <span class="comment">//开启dex进程的话也会进入application</span></span><br><span class="line">        <span class="keyword">if</span> (isDexProcess()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        doInstallBeforeLollipop();</span><br><span class="line">        MultiDex.install(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="keyword">if</span> (isDexProcess()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//其他初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInstallBeforeLollipop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//满足3个条件，1.第一次安装开启，2.主进程，3.API&lt;21(因为21之后ART的速度比dalvik快接近10倍(毕竟5.0之后的手机性能也要好很多))</span></span><br><span class="line">        <span class="keyword">if</span> (isAppFirstInstall() &amp;&amp; !isDexProcessOrOtherProcesses() &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                createTempFile();</span><br><span class="line">                startDexProcess();</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (existTempFile()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        setAppNoteFirstInstall();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>详细代码可见：<a href="https://github.com/yydcdut/PhotoNoter/blob/master/app/src/main/java/com/yydcdut/note/NoteApplication.java" target="_blank" rel="external">Github — PhotoNoter/NoteApplication</a></p>
<p>​</p>
</li>
</ul>
<p>总的来说，这种方式好处在于依赖集非常简单，同时它的集成方式也是非常简单，我们无须去修改与加载无关的代码。但是当没有启动过 App 的时候，被推送全家桶唤醒或者收到了广播，虽然这里都是没有界面的过程，但是运用了这种加载方式的话会弹出 dexopt 进程的 Activity，用户看到会一脸懵比的。</p>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="Too-many-classes-in-–main-dex-list"><a href="#Too-many-classes-in-–main-dex-list" class="headerlink" title="Too many classes in –main-dex-list"></a>Too many classes in –main-dex-list</h3><blockquote>
<p>UNEXPECTED TOP-LEVEL EXCEPTION:com.android.dex.DexException: Too many classes in –main-dex-list, main dex capacity exceeded  at com.android.dx.command.dexer.Main.processAllFiles(Main.java:494)  at com.android.dx.command.dexer.Main.runMultiDex(Main.java:332)  at com.android.dx.command.dexer.Main.run(Main.java:243)  at com.android.dx.command.dexer.Main.main(Main.java:214)  at com.android.dx.command.Main.main(Main.java:106)</p>
</blockquote>
<p>通过 sdk 的 <code>mainDexClasses.rules</code> 知道主 dex 里面会有 Application、Activity、Service、Receiver、Provider、Instrumentation、BackupAgent 和 Annotation。当这些类以及直接引用类比较多的时候，都要塞进主 dex ，就引发了 main dex capacity exceeded build error 。</p>
<p>为了解决这个问题，当执行 <code>Create{flavor}{buildType}ManifestKeepList</code> task 之前将其中的 <code>activity</code> 去掉，之后会发现 /build/intermediates/multi_dex/{flavor}/{buildType}/manifest_keep.txt 文件中已经没有 Activity 相关的类了。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> patchKeepSpecs() &#123;</span><br><span class="line">    <span class="keyword">def</span> taskClass = <span class="string">"com.android.build.gradle.internal.tasks.multidex.CreateManifestKeepList"</span>;</span><br><span class="line">    <span class="keyword">def</span> clazz = <span class="keyword">this</span>.<span class="keyword">class</span>.classLoader.loadClass(taskClass)</span><br><span class="line">    <span class="keyword">def</span> keepSpecsField = clazz.getDeclaredField(<span class="string">"KEEP_SPECS"</span>)</span><br><span class="line">    keepSpecsField.setAccessible(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">def</span> keepSpecsMap = (Map) keepSpecsField.get(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">if</span> (keepSpecsMap.remove(<span class="string">"activity"</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">        println <span class="string">"KEEP_SPECS patched: removed 'activity' root"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println <span class="string">"Failed to patch KEEP_SPECS: no 'activity' root found"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">patchKeepSpecs()</span><br></pre></td></tr></table></figure>
<p>详细可以看 <code>CreateManifestKeepList</code> 的源码：<a href="https://github.com/yydcdut/android_tools_base/blob/mm/build-system/gradle-core/src/main/groovy/com/android/build/gradle/internal/tasks/multidex/CreateManifestKeepList.groovy" target="_blank" rel="external">Github – CreateManifestKeepList</a></p>
<h3 id="Too-many-classes-in-–main-dex-list-1"><a href="#Too-many-classes-in-–main-dex-list-1" class="headerlink" title="Too many classes in –main-dex-list"></a>Too many classes in –main-dex-list</h3><p>没错，还是 Too many classes in –main-dex-list 的错误。在美团的自动拆包中讲到：</p>
<blockquote>
<p>实际应用中我们还遇到另外一个比较棘手的问题， 就是Field的过多的问题，Field过多是由我们目前采用的代码组织结构引入的，我们为了方便多业务线、多团队并发协作的情况下开发，我们采用的aar的方式进行开发，并同时在aar依赖链的最底层引入了一个通用业务aar，而这个通用业务aar中包含了很多资源，而ADT14以及更高的版本中对Library资源处理时，Library的R资源不再是static final的了，<a href="http://tools.android.com/tips/non-constant-fields" target="_blank" rel="external">详情请查看google官方说明</a>，这样在最终打包时Library中的R没法做到内联，这样带来了R field过多的情况，导致需要拆分多个Secondary DEX，为了解决这个问题我们采用的是在打包过程中利用脚本把Libray中R field（例如ID、Layout、Drawable等）的引用替换成常量，然后删去Library中R.class中的相应Field。</p>
</blockquote>
<p>同样，hu关于这个问题可以参考这篇大神的文章：<a href="http://jiajixin.cn/2015/10/21/field-65535/" target="_blank" rel="external">当Field邂逅65535</a> 。</p>
<h3 id="DexException-Library-dex-files-are-not-supported-in-multi-dex-mode"><a href="#DexException-Library-dex-files-are-not-supported-in-multi-dex-mode" class="headerlink" title="DexException: Library dex files are not supported in multi-dex mode"></a>DexException: Library dex files are not supported in multi-dex mode</h3><blockquote>
<p>com.android.dex.DexException: Library dex files are not supported in multi-dex mode<br>​ at com.android.dx.command.dexer.Main.runMultiDex(Main.java:322)<br>​ at com.android.dx.command.dexer.Main.run(Main.java:228)<br>​ at com.android.dx.command.dexer.Main.main(Main.java:199)<br>​ at com.android.dx.command.Main.main(Main.java:103)</p>
</blockquote>
<p>解决：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    dexOptions &#123;</span><br><span class="line">        preDexLibraries = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OutOfMemoryError-Java-heap-space"><a href="#OutOfMemoryError-Java-heap-space" class="headerlink" title="OutOfMemoryError: Java heap space"></a>OutOfMemoryError: Java heap space</h3><blockquote>
<p>UNEXPECTED TOP-LEVEL ERROR:<br>​  java.lang.OutOfMemoryError: Java heap space</p>
</blockquote>
<p>解决：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    dexOptions &#123;</span><br><span class="line">        javaMaxHeapSize <span class="string">"2g"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MultiDex-install-Context"><a href="#MultiDex-install-Context" class="headerlink" title="MultiDex.install(Context)"></a>MultiDex.install(Context)</h2><p>回过头来我们看看 <code>MultiDex.install()</code> 做了一些什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiDex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//secondary-dexes的位置：/code_cache/secondary-dexes</span></span><br><span class="line">        SECONDARY_FOLDER_NAME = <span class="string">"code_cache"</span> + File.separator + <span class="string">"secondary-dexes"</span>;</span><br><span class="line">        installedApk = <span class="keyword">new</span> HashSet();</span><br><span class="line">        IS_VM_MULTIDEX_CAPABLE = isVMMultidexCapable(System.getProperty(<span class="string">"java.vm.version"</span>));</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"MultiDex"</span>, <span class="string">"install"</span>);</span><br><span class="line">        <span class="keyword">if</span>(IS_VM_MULTIDEX_CAPABLE) &#123;<span class="comment">//针对ART</span></span><br><span class="line">            Log.i(<span class="string">"MultiDex"</span>, <span class="string">"VM has multidex support, MultiDex support library is disabled."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(VERSION.SDK_INT &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Multi dex installation failed. SDK "</span> + VERSION.SDK_INT + <span class="string">" is unsupported. Min SDK version is "</span> + <span class="number">4</span> + <span class="string">"."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ApplicationInfo e = getApplicationInfo(context);</span><br><span class="line">                <span class="keyword">if</span>(e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Set var2 = installedApk;</span><br><span class="line">                <span class="keyword">synchronized</span>(installedApk) &#123;</span><br><span class="line">                    String apkPath = e.sourceDir;</span><br><span class="line">                    <span class="comment">//installedApk的类型是：Set&lt;String&gt;，如果这个apk已经安装，则不重复安装   </span></span><br><span class="line">                    <span class="keyword">if</span>(installedApk.contains(apkPath)) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    installedApk.add(apkPath);</span><br><span class="line">                    <span class="keyword">if</span>(VERSION.SDK_INT &gt; <span class="number">20</span>) &#123;</span><br><span class="line">                        Log.w(<span class="string">"MultiDex"</span>, <span class="string">"MultiDex is not guaranteed to work in SDK version "</span> + VERSION.SDK_INT + <span class="string">": SDK version higher than "</span> + <span class="number">20</span> + <span class="string">" should be backed by "</span> + <span class="string">"runtime with built-in multidex capabilty but it\'s not the "</span> + <span class="string">"case here: java.vm.version=\""</span> + System.getProperty(<span class="string">"java.vm.version"</span>) + <span class="string">"\""</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">          <span class="comment">//类加载器，PathClassLoader</span></span><br><span class="line">                    ClassLoader loader;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        loader = context.getClassLoader();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException var9) &#123;</span><br><span class="line">                        Log.w(<span class="string">"MultiDex"</span>, <span class="string">"Failure while trying to obtain Context class loader. Must be running in test mode. Skip patching."</span>, var9);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Log.e(<span class="string">"MultiDex"</span>, <span class="string">"Context class loader is null. Must be running in test mode. Skip patching."</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//删除以前的dex</span></span><br><span class="line">                        clearOldDexDir(context);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable var8) &#123;</span><br><span class="line">                        Log.w(<span class="string">"MultiDex"</span>, <span class="string">"Something went wrong when trying to clear old MultiDex extraction, continuing without cleaning."</span>, var8);</span><br><span class="line">                    &#125;</span><br><span class="line">          <span class="comment">//dex将会输出到/data/data/&#123;packagename&#125;/code_cache/secondary-dexes目录。  </span></span><br><span class="line">                    File dexDir = <span class="keyword">new</span> File(e.dataDir, SECONDARY_FOLDER_NAME);</span><br><span class="line">                    List files = MultiDexExtractor.load(context, e, dexDir, <span class="keyword">false</span>);</span><br><span class="line">                  <span class="comment">//blablabla......</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var11) &#123;</span><br><span class="line">                Log.e(<span class="string">"MultiDex"</span>, <span class="string">"Multidex installation failure"</span>, var11);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Multi dex installation failed ("</span> + var11.getMessage() + <span class="string">")."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Log.i(<span class="string">"MultiDex"</span>, <span class="string">"install done"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前都是准备工作，然后进入 <code>MultiDexExtractor.load()</code> 看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiDexExtractor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> List&lt;File&gt; <span class="title">load</span><span class="params">(Context context, ApplicationInfo applicationInfo, File dexDir, <span class="keyword">boolean</span> forceReload)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//dexDir地址是/data/data/&#123;packagename&#125;/code_cache/secondary-dexes</span></span><br><span class="line">        Log.i(<span class="string">"MultiDex"</span>, <span class="string">"MultiDexExtractor.load("</span> + applicationInfo.sourceDir + <span class="string">", "</span> + forceReload + <span class="string">")"</span>);</span><br><span class="line">        <span class="comment">//applicationInfo.sourceDir地址是/data/app/&#123;packagename&#125;-1.apk</span></span><br><span class="line">        File sourceApk = <span class="keyword">new</span> File(applicationInfo.sourceDir);</span><br><span class="line">        <span class="comment">//Crc校验</span></span><br><span class="line">        <span class="keyword">long</span> currentCrc = getZipCrc(sourceApk);</span><br><span class="line">        List files;</span><br><span class="line">        <span class="comment">//isModified()判断apk是否被修改过</span></span><br><span class="line">        <span class="keyword">if</span>(!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加载已经存在的文件，如果有的文件不存在，或者不是zip文件，则会抛出异常  </span></span><br><span class="line">                files = loadExistingExtractions(context, sourceApk, dexDir);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">                Log.w(<span class="string">"MultiDex"</span>, <span class="string">"Failed to reload existing extracted secondary dex files, falling back to fresh extraction"</span>, var9);</span><br><span class="line">                <span class="comment">// 从apk中提取出多dex，然后将这些dex逐个打包为zip文件，最终返回提取出来的zip文件列表</span></span><br><span class="line">                files = performExtractions(sourceApk, dexDir);</span><br><span class="line">        <span class="comment">// getTimeStamp方法中调用的是sourceApk.lastModified()方法  </span></span><br><span class="line">                <span class="comment">// putStoredApkInfo方法存储apk的信息：时间戳、crc值、apk中dex的总个数  </span></span><br><span class="line">                putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.i(<span class="string">"MultiDex"</span>, <span class="string">"Detected that extraction must be performed."</span>);</span><br><span class="line">            files = performExtractions(sourceApk, dexDir);</span><br><span class="line">            putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(<span class="string">"MultiDex"</span>, <span class="string">"load found "</span> + files.size() + <span class="string">" secondary dex files"</span>);</span><br><span class="line">        <span class="keyword">return</span> files;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isModified</span><span class="params">(Context context, File archive, <span class="keyword">long</span> currentCrc)</span> </span>&#123;</span><br><span class="line">        SharedPreferences prefs = getMultiDexPreferences(context);</span><br><span class="line">        <span class="keyword">return</span> prefs.getLong(<span class="string">"timestamp"</span>, -<span class="number">1L</span>) != getTimeStamp(archive) || prefs.getLong(<span class="string">"crc"</span>, -<span class="number">1L</span>) != currentCrc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下 <code>performExtractions()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiDexExtractor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title">performExtractions</span><span class="params">(File sourceApk, File dexDir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//extractedFilePrefix的内容是&#123;packagename&#125;-1.apk.classes</span></span><br><span class="line">        String extractedFilePrefix = sourceApk.getName() + <span class="string">".classes"</span>;</span><br><span class="line">        <span class="comment">//准备文件夹</span></span><br><span class="line">        prepareDexDir(dexDir, extractedFilePrefix);</span><br><span class="line">        ArrayList files = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        ZipFile apk = <span class="keyword">new</span> ZipFile(sourceApk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> e = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(ZipEntry dexFile = apk.getEntry(<span class="string">"classes"</span> + e + <span class="string">".dex"</span>); dexFile != <span class="keyword">null</span>; dexFile = apk.getEntry(<span class="string">"classes"</span> + e + <span class="string">".dex"</span>)) &#123;<span class="comment">//那第e个dex</span></span><br><span class="line">                <span class="comment">//&#123;packagename&#125;-1.apk.classes2.zip</span></span><br><span class="line">                String fileName = extractedFilePrefix + e + <span class="string">".zip"</span>;</span><br><span class="line">                <span class="comment">//extractedFile地址是/data/data/&#123;packagename&#125;/code_cache/secondary-dexes/com.yydcdut.note-1.apk.classes2.zip</span></span><br><span class="line">                File extractedFile = <span class="keyword">new</span> File(dexDir, fileName);</span><br><span class="line">                files.add(extractedFile);</span><br><span class="line">                Log.i(<span class="string">"MultiDex"</span>, <span class="string">"Extraction is needed for file "</span> + extractedFile);</span><br><span class="line">                <span class="keyword">int</span> numAttempts = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">boolean</span> isExtractionSuccessful = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(numAttempts &lt; <span class="number">3</span> &amp;&amp; !isExtractionSuccessful) &#123;</span><br><span class="line">                    ++numAttempts;</span><br><span class="line">                    <span class="comment">//提取apk中的dex文件，然后打包成一个zip文</span></span><br><span class="line">                    extract(apk, dexFile, extractedFile, extractedFilePrefix);</span><br><span class="line">                    <span class="comment">//验证提取的文件是否是一个zip文件。  </span></span><br><span class="line">                    isExtractionSuccessful = verifyZipFile(extractedFile);</span><br><span class="line">                    Log.i(<span class="string">"MultiDex"</span>, <span class="string">"Extraction "</span> + (isExtractionSuccessful?<span class="string">"success"</span>:<span class="string">"failed"</span>) + <span class="string">" - length "</span> + extractedFile.getAbsolutePath() + <span class="string">": "</span> + extractedFile.length());</span><br><span class="line">                    <span class="keyword">if</span>(!isExtractionSuccessful) &#123;</span><br><span class="line">                        extractedFile.delete();</span><br><span class="line">                        <span class="keyword">if</span>(extractedFile.exists()) &#123;</span><br><span class="line">                            Log.w(<span class="string">"MultiDex"</span>, <span class="string">"Failed to delete corrupted secondary dex \'"</span> + extractedFile.getPath() + <span class="string">"\'"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!isExtractionSuccessful) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Could not create zip file "</span> + extractedFile.getAbsolutePath() + <span class="string">" for secondary dex ("</span> + e + <span class="string">")"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ++e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                apk.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var16) &#123;</span><br><span class="line">                Log.w(<span class="string">"MultiDex"</span>, <span class="string">"Failed to close resource"</span>, var16);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> files;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareDexDir</span><span class="params">(File dexDir, <span class="keyword">final</span> String extractedFilePrefix)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//dexDir的地址是：/data/data/&#123;packagename&#125;/code_cache/secondary-dexes</span></span><br><span class="line">        <span class="comment">//extractedFilePrefix的内容是data/app/&#123;packagename&#125;-1.apk.classes</span></span><br><span class="line">        File cache = dexDir.getParentFile();</span><br><span class="line">        <span class="comment">//创建文件夹</span></span><br><span class="line">        mkdirChecked(cache);</span><br><span class="line">        mkdirChecked(dexDir);</span><br><span class="line">        FileFilter filter = <span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> !pathname.getName().startsWith(extractedFilePrefix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        File[] files = dexDir.listFiles(filter);</span><br><span class="line">        <span class="keyword">if</span>(files == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.w(<span class="string">"MultiDex"</span>, <span class="string">"Failed to list secondary dex dir content ("</span> + dexDir.getPath() + <span class="string">")."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            File[] arr$ = files;</span><br><span class="line">            <span class="keyword">int</span> len$ = files.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i$ = <span class="number">0</span>; i$ &lt; len$; ++i$) &#123;</span><br><span class="line">                File oldFile = arr$[i$];</span><br><span class="line">                Log.i(<span class="string">"MultiDex"</span>, <span class="string">"Trying to delete old file "</span> + oldFile.getPath() + <span class="string">" of size "</span> + oldFile.length());</span><br><span class="line">                <span class="keyword">if</span>(!oldFile.delete()) &#123;</span><br><span class="line">                    Log.w(<span class="string">"MultiDex"</span>, <span class="string">"Failed to delete old file "</span> + oldFile.getPath());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.i(<span class="string">"MultiDex"</span>, <span class="string">"Deleted old file "</span> + oldFile.getPath());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自习看一下 <code>extract()</code> 做的事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiDexExtractor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extract</span><span class="params">(ZipFile apk, ZipEntry dexFile, File extractTo, String extractedFilePrefix)</span> <span class="keyword">throws</span> IOException, FileNotFoundException </span>&#123;</span><br><span class="line">        InputStream in = apk.getInputStream(dexFile);</span><br><span class="line">        ZipOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//创建临时文件，地址/data/data/&#123;packagename&#125;/code_cache/secondary-dexes/&#123;packagename&#125;-1.apk.classes941893003.zip</span></span><br><span class="line">        File tmp = File.createTempFile(extractedFilePrefix, <span class="string">".zip"</span>, extractTo.getParentFile());</span><br><span class="line">        Log.i(<span class="string">"MultiDex"</span>, <span class="string">"Extracting "</span> + tmp.getPath());</span><br><span class="line">    <span class="comment">//变zip</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            out = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(tmp)));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ZipEntry classesDex = <span class="keyword">new</span> ZipEntry(<span class="string">"classes.dex"</span>);</span><br><span class="line">                classesDex.setTime(dexFile.getTime());</span><br><span class="line">                out.putNextEntry(classesDex);</span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16384</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> length = in.read(buffer); length != -<span class="number">1</span>; length = in.read(buffer)) &#123;</span><br><span class="line">                    out.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                out.closeEntry();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">      <span class="comment">//extractTo的地址是 /data/data/&#123;packagename&#125;/code_cache/secondary-dexes/&#123;packagename&#125;-1.apk.classes2.zip</span></span><br><span class="line">            Log.i(<span class="string">"MultiDex"</span>, <span class="string">"Renaming to "</span> + extractTo.getPath());</span><br><span class="line">            <span class="comment">//重明明</span></span><br><span class="line">            <span class="keyword">if</span>(!tmp.renameTo(extractTo)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Failed to rename \""</span> + tmp.getAbsolutePath() + <span class="string">"\" to \""</span> + extractTo.getAbsolutePath() + <span class="string">"\""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeQuietly(in);</span><br><span class="line">            tmp.delete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完这里，<code>List files = MultiDexExtractor.load(context, e, dexDir, false);</code> 也就执行完了，继续看 <code>MultiDex.install()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiDex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"MultiDex"</span>, <span class="string">"install"</span>);</span><br><span class="line">        <span class="keyword">if</span>(IS_VM_MULTIDEX_CAPABLE) &#123;<span class="comment">//针对ART</span></span><br><span class="line">            Log.i(<span class="string">"MultiDex"</span>, <span class="string">"VM has multidex support, MultiDex support library is disabled."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(VERSION.SDK_INT &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Multi dex installation failed. SDK "</span> + VERSION.SDK_INT + <span class="string">" is unsupported. Min SDK version is "</span> + <span class="number">4</span> + <span class="string">"."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">//blablabla......</span></span><br><span class="line">          <span class="comment">//dex将会输出到/data/data/&#123;packagename&#125;/code_cache/secondary-dexes目录。  </span></span><br><span class="line">                    File dexDir = <span class="keyword">new</span> File(e.dataDir, SECONDARY_FOLDER_NAME);</span><br><span class="line">                    List files = MultiDexExtractor.load(context, e, dexDir, <span class="keyword">false</span>);</span><br><span class="line">          <span class="comment">//校验这些zip文件是否合法  </span></span><br><span class="line">                    <span class="keyword">if</span>(checkValidZipFiles(files)) &#123;</span><br><span class="line">                        <span class="comment">//安装提取出来的zip文件  </span></span><br><span class="line">                        installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//不合法的情况下强制load一遍</span></span><br><span class="line">                        Log.w(<span class="string">"MultiDex"</span>, <span class="string">"Files were not valid zip files.  Forcing a reload."</span>);</span><br><span class="line">                         <span class="comment">//最后一个参数是true，代表强制加载</span></span><br><span class="line">                        files = MultiDexExtractor.load(context, e, dexDir, <span class="keyword">true</span>);</span><br><span class="line">                        <span class="comment">//还是不合法的就抛异常</span></span><br><span class="line">                        <span class="keyword">if</span>(!checkValidZipFiles(files)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Zip files were not valid."</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">            <span class="comment">//终于合法了，安装zip文件</span></span><br><span class="line">                        installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var11) &#123;</span><br><span class="line">                Log.e(<span class="string">"MultiDex"</span>, <span class="string">"Multidex installation failure"</span>, var11);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Multi dex installation failed ("</span> + var11.getMessage() + <span class="string">")."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Log.i(<span class="string">"MultiDex"</span>, <span class="string">"install done"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>installSecondaryDexes(loader, dexDir, files)</code> 比较重要，在这个方法里面进行将第二个 dex 的代码加载到程序中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiDex</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installSecondaryDexes</span><span class="params">(ClassLoader loader, File dexDir, List&lt;File&gt; files)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//分版本加载</span></span><br><span class="line">        <span class="keyword">if</span>(!files.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">                MultiDex.V19.install(loader, files, dexDir);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">                MultiDex.V14.install(loader, files, dexDir);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                MultiDex.V4.install(loader, files);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看看 <code>MultiDex.V14.install(loader, files, dexDir);</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiDex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V14</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries, File optimizedDirectory)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line">            <span class="comment">//optimizedDirectory地址是/data/data/&#123;packagename&#125;/code_cache/secondary-dexes</span></span><br><span class="line">            <span class="comment">//反射找到PathClassLoader的pathList属性，是DexPathList类，这个属性是父类 BaseDexClassLoader</span></span><br><span class="line">            Field pathListField = MultiDex.findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">            Object dexPathList = pathListField.get(loader);</span><br><span class="line">            <span class="comment">//dexElements为dexPathList的一个属性，是Element数组</span></span><br><span class="line">            MultiDex.expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, makeDexElements(dexPathList, <span class="keyword">new</span> ArrayList(additionalClassPathEntries), optimizedDirectory));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] makeDexElements(Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory) <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line">          <span class="comment">//反射拿到dexPathList的方法makeDexElements，private static Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory, ArrayList&lt;IOException&gt; suppressedExceptions)</span></span><br><span class="line">            Method makeDexElements = MultiDex.findMethod(dexPathList, <span class="string">"makeDexElements"</span>, <span class="keyword">new</span> Class[]&#123;ArrayList.class, File.class&#125;);</span><br><span class="line">            <span class="comment">//调用方法，该方法的作用是通过传入的files去加载jar或者zip，封装成DexFile，在封装成Element返回</span></span><br><span class="line">            <span class="keyword">return</span> (Object[])((Object[])makeDexElements.invoke(dexPathList, <span class="keyword">new</span> Object[]&#123;files, optimizedDirectory&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expandFieldArray</span><span class="params">(Object instance, String fieldName, Object[] extraElements)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//找到dexElements这个属性</span></span><br><span class="line">        Field jlrField = findField(instance, fieldName);</span><br><span class="line">        <span class="comment">//classloader中原始的dexElements</span></span><br><span class="line">        Object[] original = (Object[])((Object[])jlrField.get(instance));</span><br><span class="line">        <span class="comment">//new一个新的出来</span></span><br><span class="line">        Object[] combined = (Object[])((Object[])Array.newInstance(original.getClass().getComponentType(), original.length + extraElements.length));</span><br><span class="line">        <span class="comment">//将原有的复制到新的里面去</span></span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, combined, <span class="number">0</span>, original.length);</span><br><span class="line">        <span class="comment">//将第二个dex的复制到新的里面去</span></span><br><span class="line">        System.arraycopy(extraElements, <span class="number">0</span>, combined, original.length, extraElements.length);</span><br><span class="line">        <span class="comment">//再塞回去</span></span><br><span class="line">        jlrField.set(instance, combined);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，<code>MultiDex.install()</code> 分析完了，这里只讲一下V14的，在 Java 层的主要流程将第二个 dex 取出（现在只考虑两个 dex 的情况），整成 Zip 形式的，然后通过反射将 zip 的地址等参数封装起来再塞给 PathClassLoader 。为什么是 Zip ，因为在 BaseDexClassLoader 中 <code>DexFile.loadDex()</code> 只接受 jar 或者 zip。</p>
<p>更多的可以参考：Github – <a href="https://github.com/yydcdut/android_libcore/blob/kitkat/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java" target="_blank" rel="external">BaseDexClassLoader</a> <a href="https://github.com/yydcdut/android_libcore/blob/kitkat/dalvik/src/main/java/dalvik/system/DexFile.java" target="_blank" rel="external">DexFile</a> <a href="https://github.com/yydcdut/android_libcore/blob/kitkat/dalvik/src/main/java/dalvik/system/DexPathList.java" target="_blank" rel="external">DexPathList</a></p>
<h2 id="Jack"><a href="#Jack" class="headerlink" title="Jack"></a>Jack</h2><p>通过 <a href="http://tools.android.com/tech-docs/jackandjill" target="_blank" rel="external">Experimental New Android Tool Chain - Jack and Jill</a> 查看到 build tools 21.1.1 开始就支持 <code>Jack</code> 了。</p>
<p>那么我们直接使用文章给出的 jack 在 gradle 中的用法使用编译工程吧：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.1.0-alpha3'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">android &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    buildToolsVersion <span class="string">'21.1.2'</span></span><br><span class="line">  	minSdkVersion <span class="number">21</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">    <span class="comment">// Enable the experimental Jack build tools.</span></span><br><span class="line">    useJack = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  compileOptions &#123;</span><br><span class="line">    sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在实际编译过程中出现了问题：</p>
<blockquote>
<p>Error:Execution failed for task ‘:app:jillDebugPackagedLibraries’.<br> Jack requires Build Tools 24.0.0 or later</p>
</blockquote>
<p>那么把 build tool 更新到 <code>24.0.0rc1</code> 再试试吧：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildToolsVersion <span class="string">'24.0.0rc1'</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新编译，然后当 gradle 运行到 <code>compileDebugJavaWithJack</code> 的时候：</p>
<blockquote>
<p>ERROR: Dex writing phase: classes.dex has too many IDs. Try using multi-dex<br>com.android.jack.api.v01.CompilationException: Dex writing phase: classes.dex has too many IDs. Try using multi-dex<br>​    at com.android.jack.api.v01.impl.Api01ConfigImpl$Api01CompilationTaskImpl.run(Api01ConfigImpl.java:113)<br>​    at com.android.builder.core.AndroidBuilder.convertByteCodeUsingJackApis(AndroidBuilder.java:1904)<br>​    at com.android.build.gradle.tasks.JackTask.doMinification(JackTask.java:148)<br>​    at com.android.build.gradle.tasks.JackTask.access$000(JackTask.java:73)<br>​    at com.android.build.gradle.tasks.JackTask$1.run(JackTask.java:112)<br>​    at com.android.builder.tasks.Job.runTask(Job.java:51)<br>​    at com.android.build.gradle.tasks.SimpleWorkQueue$EmptyThreadContext.runTask(SimpleWorkQueue.java:41)<br>​    at com.android.builder.tasks.WorkQueue.run(WorkQueue.java:223)<br>​    at java.lang.Thread.run(Thread.java:745)<br>Caused by: com.android.jack.JackAbortException: Dex writing phase: classes.dex has too many IDs. Try using multi-dex<br>​    at com.android.jack.backend.dex.DexFileWriter.run(DexFileWriter.java:90)<br>​    at com.android.jack.backend.dex.DexFileWriter.run(DexFileWriter.java:41)<br>​    at com.android.sched.scheduler.ScheduleInstance.runWithLog(ScheduleInstance.java:161)<br>​    at com.android.sched.scheduler.MultiWorkersScheduleInstance$SequentialTask.process(MultiWorkersScheduleInstance.java:442)<br>​    at com.android.sched.scheduler.MultiWorkersScheduleInstance$Worker.run(MultiWorkersScheduleInstance.java:162)<br>Caused by: com.android.jack.backend.dex.DexWritingException: Dex writing phase: classes.dex has too many IDs. Try using multi-dex<br>​    at com.android.jack.backend.dex.SingleDexWritingTool.write(SingleDexWritingTool.java:64)<br>​    at com.android.jack.backend.dex.DexFileWriter.run(DexFileWriter.java:87)<br>​    … 4 more<br>Caused by: com.android.jack.backend.dex.SingleDexOverflowException: classes.dex has too many IDs. Try using multi-dex<br>​    … 6 more<br>Caused by: com.android.jack.tools.merger.MethodIdOverflowException: Method ID overflow when trying to merge dex files<br>​    at com.android.jack.tools.merger.ConstantManager.addDexFile(ConstantManager.java:177)<br>​    at com.android.jack.tools.merger.JackMerger.addDexFile(JackMerger.java:69)<br>​    at com.android.jack.backend.dex.DexWritingTool.mergeDex(DexWritingTool.java:107)<br>​    at com.android.jack.backend.dex.SingleDexWritingTool.write(SingleDexWritingTool.java:62)<br>​    … 5 more</p>
</blockquote>
<p>还是得使用 multidex 。jack 不支持 <code>instantRun</code> ，同样 gradle 是 <code>2.1.0-alpha3</code> ，这里就需要 multidex 了。 65536 的根本问题并不在于  jack 身上，而在于指令集身上，jack 也是采用的 multidex 来解决这个问题的。</p>
<p>更多 jack 的资料：</p>
<ul>
<li><a href="http://tools.android.com/tech-docs/jackandjill" target="_blank" rel="external">Experimental New Android Tool Chain - Jack and Jill</a></li>
<li><a href="https://source.android.com/source/jack.html" target="_blank" rel="external">Jack (Java Android Compiler Kit)</a></li>
<li><a href="http://developer.android.com/intl/zh-tw/preview/j8-jack.html" target="_blank" rel="external">Java 8 Language Features</a></li>
<li><a href="https://www.guardsquare.com/blog/the_upcoming_jack_and_jill_compilers_in_android" target="_blank" rel="external">The upcoming Jack &amp; Jill compilers in Android</a></li>
<li><a href="http://www.i-programmer.info/news/193-android/8072-the-new-android-compilers-meet-jack-and-jill.html" target="_blank" rel="external">The New <strong>Android</strong> Compilers - Meet <strong>Jack</strong> And Jill</a></li>
<li><a href="android-developers.blogspot.co.uk/2014/12/hello-world-meet-our-new-experimental.html">Hello World, meet our new experimental toolchain, Jack and Jill | Android Developers Blog</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://tech.meituan.com/mt-android-auto-split-dex.html" target="_blank" rel="external">美团Android DEX自动拆包及动态加载简介</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207151651&amp;idx=1&amp;sn=9eab282711f4eb2b4daf2fbae5a5ca9a&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd" target="_blank" rel="external">Android拆分与加载Dex的多种方案对比</a></li>
<li><a href="http://blog.zongwu233.com/the-touble-of-multidex" target="_blank" rel="external">其实你不知道MultiDex到底有多坑</a></li>
<li><a href="http://blog.osom.info/2014/12/too-many-methods-in-main-dex.html" target="_blank" rel="external">Alex Lipov @ osom.info: Too many methods in main-dex?</a></li>
<li><a href="https://github.com/casidiablo/multidex" target="_blank" rel="external">casidiablo/multidex</a></li>
<li><a href="http://jayfeng.com/2016/03/10/%E7%94%B1Android-65K%E6%96%B9%E6%B3%95%E6%95%B0%E9%99%90%E5%88%B6%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/" target="_blank" rel="external">由Android 65K方法数限制引发的思考</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2016/03/27/elasticscrollview-analyse/" class="prev">PREV</a><a href="/2016/03/13/volley-code-analyse/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yydcdut.com">yydcdut</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>