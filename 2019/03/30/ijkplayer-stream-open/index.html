<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ijkplayer框架简析 -- 读取数据 · Android杂文 - yydcdut</title><meta name="description" content="ijkplayer框架简析 -- 读取数据 - yydcdut"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yydcdut.com/atom.xml" title="Android杂文 - yydcdut"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut/yydcdut.github.io/issues" target="_blank" class="nav-list-link">COMMENT</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ijkplayer框架简析 -- 读取数据</h1><div class="post-info">2019年3月30日</div><div class="post-content"><p>IjkMediaPlayer 通过 <code>prepareAsync()</code> 之后去加载数据、解码数据，调用 <code>start()</code> 之后去渲染</p>
<a id="more"></a>
<h2 id="stream-open"><a href="#stream-open" class="headerlink" title="stream_open"></a>stream_open</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> VideoState *<span class="title">stream_open</span><span class="params">(FFPlayer *ffp, <span class="keyword">const</span> <span class="keyword">char</span> *filename, AVInputFormat *iformat)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// ..........</span></span><br><span class="line">    <span class="comment">/* start video display */</span></span><br><span class="line">    <span class="keyword">if</span> (frame_queue_init(&amp;is-&gt;pictq, &amp;is-&gt;videoq, ffp-&gt;pictq_size, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    <span class="keyword">if</span> (frame_queue_init(&amp;is-&gt;subpq, &amp;is-&gt;subtitleq, SUBPICTURE_QUEUE_SIZE, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    <span class="keyword">if</span> (frame_queue_init(&amp;is-&gt;sampq, &amp;is-&gt;audioq, SAMPLE_QUEUE_SIZE, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (packet_queue_init(&amp;is-&gt;videoq) &lt; <span class="number">0</span> ||</span><br><span class="line">        packet_queue_init(&amp;is-&gt;audioq) &lt; <span class="number">0</span> ||</span><br><span class="line">        packet_queue_init(&amp;is-&gt;subtitleq) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    <span class="comment">// ..........</span></span><br><span class="line">    is-&gt;video_refresh_tid = SDL_CreateThreadEx(&amp;is-&gt;_video_refresh_tid, video_refresh_thread, ffp, <span class="string">"ff_vout"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;video_refresh_tid) &#123;</span><br><span class="line">        av_freep(&amp;ffp-&gt;is);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    is-&gt;initialized_decoder = <span class="number">0</span>;</span><br><span class="line">    is-&gt;read_tid = SDL_CreateThreadEx(&amp;is-&gt;_read_tid, read_thread, ffp, <span class="string">"ff_read"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;read_tid) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">"SDL_CreateThread(): %s\n"</span>, SDL_GetError());</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>frame_queue_init()</code> 初始化队列，第一个参数是解码之后的队列（FrameQueue），第二个参数是解码之前的队列（PackerQueue）</li>
<li><code>packet_queue_init()</code> 给 PacketQueue 创建互斥锁</li>
<li>创建两个线程<ul>
<li>ff_vout</li>
<li>ff_read</li>
</ul>
</li>
</ul>
<p>其中 <code>ff_read</code> 为读取线程，调用的是 <code>read_thread()</code> 方法</p>
<h3 id="read-thread"><a href="#read-thread" class="headerlink" title="read_thread"></a>read_thread</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* this thread gets the stream from the disk or the network */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">read_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    ic = avformat_alloc_context();</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    err = avformat_open_input(&amp;ic, is-&gt;filename, is-&gt;iformat, &amp;ffp-&gt;format_opts);</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    err = avformat_find_stream_info(ic, opts);</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="comment">/* open the streams */</span></span><br><span class="line">    <span class="keyword">if</span> (st_index[AVMEDIA_TYPE_AUDIO] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        stream_component_open(ffp, st_index[AVMEDIA_TYPE_AUDIO]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ffp-&gt;av_sync_type = AV_SYNC_VIDEO_MASTER;</span><br><span class="line">        is-&gt;av_sync_type  = ffp-&gt;av_sync_type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (st_index[AVMEDIA_TYPE_VIDEO] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ret = stream_component_open(ffp, st_index[AVMEDIA_TYPE_VIDEO]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;show_mode == SHOW_MODE_NONE)</span><br><span class="line">        is-&gt;show_mode = ret &gt;= <span class="number">0</span> ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st_index[AVMEDIA_TYPE_SUBTITLE] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        stream_component_open(ffp, st_index[AVMEDIA_TYPE_SUBTITLE]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ret = av_read_frame(ic, pkt);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">         <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;audio_stream &amp;&amp; pkt_in_play_range) &#123;</span><br><span class="line">            packet_queue_put(&amp;is-&gt;audioq, pkt);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;video_stream &amp;&amp; pkt_in_play_range</span><br><span class="line">                   &amp;&amp; !(is-&gt;video_st &amp;&amp; (is-&gt;video_st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC))) &#123;</span><br><span class="line">            packet_queue_put(&amp;is-&gt;videoq, pkt);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;subtitle_stream &amp;&amp; pkt_in_play_range) &#123;</span><br><span class="line">            packet_queue_put(&amp;is-&gt;subtitleq, pkt);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            av_packet_unref(pkt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>read_thread()</code> 整体流程跟 ffmpeg 类似，数据会在在 <code>for(;;)</code> 中进行读取，通过 <code>packet_queue_put()</code> 塞到队列中；同时在 <code>stream_component_open()</code> 方法中开启另外的线程进行解码</p>
<h3 id="av-read-frame"><a href="#av-read-frame" class="headerlink" title="av_read_frame"></a>av_read_frame</h3><p>关于 <code>av_read_frame()</code> 可以参考 <a href="http://yydcdut.com/2019/03/09/ijkplayer-ffmpeg-av-read-frame/">ijkplayer框架简析 — av_read_frame</a></p>
<h2 id="stream-component-open"><a href="#stream-component-open" class="headerlink" title="stream_component_open"></a>stream_component_open</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* open a given stream. Return 0 if OK */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stream_component_open</span><span class="params">(FFPlayer *ffp, <span class="keyword">int</span> stream_index)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    codec = avcodec_find_decoder(avctx-&gt;codec_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (avctx-&gt;codec_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO   : is-&gt;last_audio_stream    = stream_index; forced_codec_name = ffp-&gt;audio_codec_name; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_SUBTITLE: is-&gt;last_subtitle_stream = stream_index; forced_codec_name = ffp-&gt;subtitle_codec_name; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO   : is-&gt;last_video_stream    = stream_index; forced_codec_name = ffp-&gt;video_codec_name; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (forced_codec_name)</span><br><span class="line">        codec = avcodec_find_decoder_by_name(forced_codec_name);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (avctx-&gt;codec_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">        <span class="comment">/* prepare audio output */</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = audio_open(ffp, channel_layout, nb_channels, sample_rate, &amp;is-&gt;audio_tgt)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        decoder_init(&amp;is-&gt;auddec, avctx, &amp;is-&gt;audioq, is-&gt;continue_read_thread);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = decoder_start(&amp;is-&gt;auddec, audio_thread, ffp, <span class="string">"ff_audio_dec"</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        SDL_AoutPauseAudio(ffp-&gt;aout, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">        is-&gt;video_stream = stream_index;</span><br><span class="line">        is-&gt;video_st = ic-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ffp-&gt;async_init_decoder) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!is-&gt;initialized_decoder) &#123;</span><br><span class="line">                SDL_Delay(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ffp-&gt;node_vdec) &#123;</span><br><span class="line">                is-&gt;viddec.avctx = avctx;</span><br><span class="line">                ret = ffpipeline_config_video_decoder(ffp-&gt;pipeline, ffp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ret || !ffp-&gt;node_vdec) &#123;</span><br><span class="line">                decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread);</span><br><span class="line">                ffp-&gt;node_vdec = ffpipeline_open_video_decoder(ffp-&gt;pipeline, ffp);</span><br><span class="line">                <span class="keyword">if</span> (!ffp-&gt;node_vdec)</span><br><span class="line">                    <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread);</span><br><span class="line">            ffp-&gt;node_vdec = ffpipeline_open_video_decoder(ffp-&gt;pipeline, ffp);</span><br><span class="line">            <span class="keyword">if</span> (!ffp-&gt;node_vdec)</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = decoder_start(&amp;is-&gt;viddec, video_thread, ffp, <span class="string">"ff_video_dec"</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先通过 <code>avcodec_find_decoder()</code> 来找解码器，然后判断是音频还是视频来进行解码</p>
<h3 id="AVMEDIA-TYPE-AUDIO"><a href="#AVMEDIA-TYPE-AUDIO" class="headerlink" title="AVMEDIA_TYPE_AUDIO"></a>AVMEDIA_TYPE_AUDIO</h3><h4 id="audio-open"><a href="#audio-open" class="headerlink" title="audio_open"></a>audio_open</h4><p>如果是音频的话，首先调用 <code>audio_open()</code> 方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">audio_open</span><span class="params">(FFPlayer *opaque, int64_t wanted_channel_layout, <span class="keyword">int</span> wanted_nb_channels, <span class="keyword">int</span> wanted_sample_rate, <span class="keyword">struct</span> AudioParams *audio_hw_params)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FFPlayer *ffp = opaque;</span><br><span class="line">    VideoState *is = ffp-&gt;is;</span><br><span class="line">    SDL_AudioSpec wanted_spec, spec;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *env;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> next_nb_channels[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> FFP_MERGE</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> next_sample_rates[] = &#123;<span class="number">0</span>, <span class="number">44100</span>, <span class="number">48000</span>, <span class="number">96000</span>, <span class="number">192000</span>&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> next_sample_rates[] = &#123;<span class="number">0</span>, <span class="number">44100</span>, <span class="number">48000</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> next_sample_rate_idx = FF_ARRAY_ELEMS(next_sample_rates) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    env = SDL_getenv(<span class="string">"SDL_AUDIO_CHANNELS"</span>);</span><br><span class="line">    <span class="keyword">if</span> (env) &#123;</span><br><span class="line">        wanted_nb_channels = atoi(env);</span><br><span class="line">        wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!wanted_channel_layout || wanted_nb_channels != av_get_channel_layout_nb_channels(wanted_channel_layout)) &#123;</span><br><span class="line">        wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);</span><br><span class="line">        wanted_channel_layout &amp;= ~AV_CH_LAYOUT_STEREO_DOWNMIX;</span><br><span class="line">    &#125;</span><br><span class="line">    wanted_nb_channels = av_get_channel_layout_nb_channels(wanted_channel_layout);</span><br><span class="line">    wanted_spec.channels = wanted_nb_channels;</span><br><span class="line">    wanted_spec.freq = wanted_sample_rate;</span><br><span class="line">    <span class="keyword">if</span> (wanted_spec.freq &lt;= <span class="number">0</span> || wanted_spec.channels &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Invalid sample rate or channel count!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (next_sample_rate_idx &amp;&amp; next_sample_rates[next_sample_rate_idx] &gt;= wanted_spec.freq)</span><br><span class="line">        next_sample_rate_idx--;</span><br><span class="line">    wanted_spec.format = AUDIO_S16SYS;</span><br><span class="line">    wanted_spec.silence = <span class="number">0</span>;</span><br><span class="line">    wanted_spec.samples = FFMAX(SDL_AUDIO_MIN_BUFFER_SIZE, <span class="number">2</span> &lt;&lt; av_log2(wanted_spec.freq / SDL_AoutGetAudioPerSecondCallBacks(ffp-&gt;aout)));</span><br><span class="line">    wanted_spec.callback = sdl_audio_callback;</span><br><span class="line">    wanted_spec.userdata = opaque;</span><br><span class="line">    <span class="keyword">while</span> (SDL_AoutOpenAudio(ffp-&gt;aout, &amp;wanted_spec, &amp;spec) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* avoid infinity loop on exit. --by bbcallen */</span></span><br><span class="line">        <span class="keyword">if</span> (is-&gt;abort_request)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">"SDL_OpenAudio (%d channels, %d Hz): %s\n"</span>,</span><br><span class="line">               wanted_spec.channels, wanted_spec.freq, SDL_GetError());</span><br><span class="line">        wanted_spec.channels = next_nb_channels[FFMIN(<span class="number">7</span>, wanted_spec.channels)];</span><br><span class="line">        <span class="keyword">if</span> (!wanted_spec.channels) &#123;</span><br><span class="line">            wanted_spec.freq = next_sample_rates[next_sample_rate_idx--];</span><br><span class="line">            wanted_spec.channels = wanted_nb_channels;</span><br><span class="line">            <span class="keyword">if</span> (!wanted_spec.freq) &#123;</span><br><span class="line">                av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">                       <span class="string">"No more combinations to try, audio open failed\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        wanted_channel_layout = av_get_default_channel_layout(wanted_spec.channels);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (spec.format != AUDIO_S16SYS) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">"SDL advised audio format %d is not supported!\n"</span>, spec.format);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (spec.channels != wanted_spec.channels) &#123;</span><br><span class="line">        wanted_channel_layout = av_get_default_channel_layout(spec.channels);</span><br><span class="line">        <span class="keyword">if</span> (!wanted_channel_layout) &#123;</span><br><span class="line">            av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">                   <span class="string">"SDL advised channel count %d is not supported!\n"</span>, spec.channels);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    audio_hw_params-&gt;fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">    audio_hw_params-&gt;freq = spec.freq;</span><br><span class="line">    audio_hw_params-&gt;channel_layout = wanted_channel_layout;</span><br><span class="line">    audio_hw_params-&gt;channels =  spec.channels;</span><br><span class="line">    audio_hw_params-&gt;frame_size = av_samples_get_buffer_size(<span class="literal">NULL</span>, audio_hw_params-&gt;channels, <span class="number">1</span>, audio_hw_params-&gt;fmt, <span class="number">1</span>);</span><br><span class="line">    audio_hw_params-&gt;bytes_per_sec = av_samples_get_buffer_size(<span class="literal">NULL</span>, audio_hw_params-&gt;channels, audio_hw_params-&gt;freq, audio_hw_params-&gt;fmt, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (audio_hw_params-&gt;bytes_per_sec &lt;= <span class="number">0</span> || audio_hw_params-&gt;frame_size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"av_samples_get_buffer_size failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_AoutSetDefaultLatencySeconds(ffp-&gt;aout, ((<span class="keyword">double</span>)(<span class="number">2</span> * spec.size)) / audio_hw_params-&gt;bytes_per_sec);</span><br><span class="line">    <span class="keyword">return</span> spec.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在其中调用了 <code>SDL_AoutOpenAudio()</code> 方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_AoutOpenAudio</span><span class="params">(SDL_Aout *aout, <span class="keyword">const</span> SDL_AudioSpec *desired, SDL_AudioSpec *obtained)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (aout &amp;&amp; desired &amp;&amp; aout-&gt;open_audio)</span><br><span class="line">        <span class="keyword">return</span> aout-&gt;open_audio(aout, desired, obtained);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>aout-&gt;open_audio</code> 指向的是 <code>aout_open_audio()</code> 方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDL_Aout *<span class="title">SDL_AoutAndroid_CreateForAudioTrack</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    SDL_Aout *aout = SDL_Aout_CreateInternal(<span class="keyword">sizeof</span>(SDL_Aout_Opaque));</span><br><span class="line">    <span class="keyword">if</span> (!aout)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    SDL_Aout_Opaque *opaque = aout-&gt;opaque;</span><br><span class="line">    opaque-&gt;wakeup_cond  = SDL_CreateCond();</span><br><span class="line">    opaque-&gt;wakeup_mutex = SDL_CreateMutex();</span><br><span class="line">    opaque-&gt;speed        = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    aout-&gt;opaque_class = &amp;g_audiotrack_class;</span><br><span class="line">    aout-&gt;free_l       = aout_free_l;</span><br><span class="line">    aout-&gt;open_audio   = aout_open_audio;</span><br><span class="line">    aout-&gt;pause_audio  = aout_pause_audio;</span><br><span class="line">    aout-&gt;flush_audio  = aout_flush_audio;</span><br><span class="line">    aout-&gt;set_volume   = aout_set_volume;</span><br><span class="line">    aout-&gt;close_audio  = aout_close_audio;</span><br><span class="line">    aout-&gt;func_get_audio_session_id = aout_get_audio_session_id;</span><br><span class="line">    aout-&gt;func_set_playback_rate    = func_set_playback_rate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> aout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看在 <code>aout_open_audio()</code> 处理了什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aout_open_audio</span><span class="params">(SDL_Aout *aout, <span class="keyword">const</span> SDL_AudioSpec *desired, SDL_AudioSpec *obtained)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// SDL_Aout_Opaque *opaque = aout-&gt;opaque;</span></span><br><span class="line">    JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (JNI_OK != SDL_JNI_SetupThreadEnv(&amp;env)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"aout_open_audio: AttachCurrentThread: failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> aout_open_audio_n(env, aout, desired, obtained);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aout_open_audio_n</span><span class="params">(JNIEnv *env, SDL_Aout *aout, <span class="keyword">const</span> SDL_AudioSpec *desired, SDL_AudioSpec *obtained)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    assert(desired);</span><br><span class="line">    SDL_Aout_Opaque *opaque = aout-&gt;opaque;</span><br><span class="line"></span><br><span class="line">    opaque-&gt;spec = *desired;</span><br><span class="line">    opaque-&gt;atrack = SDL_Android_AudioTrack_new_from_sdl_spec(env, desired);</span><br><span class="line">    <span class="keyword">if</span> (!opaque-&gt;atrack) &#123;</span><br><span class="line">        ALOGE(<span class="string">"aout_open_audio_n: failed to new AudioTrcak()"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    opaque-&gt;buffer_size = SDL_Android_AudioTrack_get_min_buffer_size(opaque-&gt;atrack);</span><br><span class="line">    <span class="keyword">if</span> (opaque-&gt;buffer_size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"aout_open_audio_n: failed to getMinBufferSize()"</span>);</span><br><span class="line">        SDL_Android_AudioTrack_free(env, opaque-&gt;atrack);</span><br><span class="line">        opaque-&gt;atrack = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    opaque-&gt;buffer = <span class="built_in">malloc</span>(opaque-&gt;buffer_size);</span><br><span class="line">    <span class="keyword">if</span> (!opaque-&gt;buffer) &#123;</span><br><span class="line">        ALOGE(<span class="string">"aout_open_audio_n: failed to allocate buffer"</span>);</span><br><span class="line">        SDL_Android_AudioTrack_free(env, opaque-&gt;atrack);</span><br><span class="line">        opaque-&gt;atrack = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obtained) &#123;</span><br><span class="line">        SDL_Android_AudioTrack_get_target_spec(opaque-&gt;atrack, obtained);</span><br><span class="line">        SDLTRACE(<span class="string">"audio target format fmt:0x%x, channel:0x%x"</span>, (<span class="keyword">int</span>)obtained-&gt;format, (<span class="keyword">int</span>)obtained-&gt;channels);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    opaque-&gt;audio_session_id = SDL_Android_AudioTrack_getAudioSessionId(env, opaque-&gt;atrack);</span><br><span class="line">    ALOGI(<span class="string">"audio_session_id = %d\n"</span>, opaque-&gt;audio_session_id);</span><br><span class="line"></span><br><span class="line">    opaque-&gt;pause_on = <span class="number">1</span>;</span><br><span class="line">    opaque-&gt;abort_request = <span class="number">0</span>;</span><br><span class="line">    opaque-&gt;audio_tid = SDL_CreateThreadEx(&amp;opaque-&gt;_audio_tid, aout_thread, aout, <span class="string">"ff_aout_android"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!opaque-&gt;audio_tid) &#123;</span><br><span class="line">        ALOGE(<span class="string">"aout_open_audio_n: failed to create audio thread"</span>);</span><br><span class="line">        SDL_Android_AudioTrack_free(env, opaque-&gt;atrack);</span><br><span class="line">        opaque-&gt;atrack = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最终调用的 <code>aout_open_audio_n()</code> 中，输出使用的是 <code>AudioTrack</code>，开启了一个叫 <code>ff_aout_android</code> 的音频播放线程</p>
<h4 id="decoder-start"><a href="#decoder-start" class="headerlink" title="decoder_start"></a>decoder_start</h4><p>调用完 <code>audio_open</code> 之后，紧接着调用了 <code>decoder_start</code> 方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static int decoder_start(Decoder *d, int (*fn)(void *), void *arg, const char *name)</span><br><span class="line">&#123;</span><br><span class="line">    packet_queue_start(d-&gt;queue);</span><br><span class="line">    d-&gt;decoder_tid = SDL_CreateThreadEx(&amp;d-&gt;_decoder_tid, fn, arg, name);</span><br><span class="line">    if (!d-&gt;decoder_tid) &#123;</span><br><span class="line">        av_log(NULL, AV_LOG_ERROR, "SDL_CreateThread(): %s\n", SDL_GetError());</span><br><span class="line">        return AVERROR(ENOMEM);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中参数 <code>const char *name</code> 传的是创建线程的名字 <code>decoder_start(&amp;is-&gt;auddec, audio_thread, ffp, &quot;ff_audio_dec&quot;)</code>，这里创建的是音频的解码线程</p>
<h3 id="AVMEDIA-TYPE-VIDEO"><a href="#AVMEDIA-TYPE-VIDEO" class="headerlink" title="AVMEDIA_TYPE_VIDEO"></a>AVMEDIA_TYPE_VIDEO</h3><h4 id="ffpipeline-open-video-decoder"><a href="#ffpipeline-open-video-decoder" class="headerlink" title="ffpipeline_open_video_decoder"></a>ffpipeline_open_video_decoder</h4><p>视频的流程与音频差不多，调用 <code>ffpipeline_open_video_decoder</code> 打开解码器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IJKFF_Pipenode* <span class="title">ffpipeline_open_video_decoder</span><span class="params">(IJKFF_Pipeline *pipeline, FFPlayer *ffp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline-&gt;func_open_video_decoder(pipeline, ffp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ijkplayer 最开始的时候初始化了 <code>IJKFF_Pipenode</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IjkMediaPlayer *ijkmp_android_create(int(*msg_loop)(void*))</span><br><span class="line">&#123;</span><br><span class="line">    IjkMediaPlayer *mp = ijkmp_create(msg_loop);</span><br><span class="line">    if (!mp)</span><br><span class="line">        goto fail;</span><br><span class="line"></span><br><span class="line">    mp-&gt;ffplayer-&gt;vout = SDL_VoutAndroid_CreateForAndroidSurface();</span><br><span class="line">    if (!mp-&gt;ffplayer-&gt;vout)</span><br><span class="line">        goto fail;</span><br><span class="line"></span><br><span class="line">    mp-&gt;ffplayer-&gt;pipeline = ffpipeline_create_from_android(mp-&gt;ffplayer);</span><br><span class="line">    if (!mp-&gt;ffplayer-&gt;pipeline)</span><br><span class="line">        goto fail;</span><br><span class="line"></span><br><span class="line">    ffpipeline_set_vout(mp-&gt;ffplayer-&gt;pipeline, mp-&gt;ffplayer-&gt;vout);</span><br><span class="line"></span><br><span class="line">    return mp;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    ijkmp_dec_ref_p(&amp;mp);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这里调用到了 <code>ffpipeline_android.c</code> 中的方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> IJKFF_Pipenode *<span class="title">func_open_video_decoder</span><span class="params">(IJKFF_Pipeline *pipeline, FFPlayer *ffp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    IJKFF_Pipeline_Opaque *opaque = pipeline-&gt;opaque;</span><br><span class="line">    IJKFF_Pipenode        *node = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ffp-&gt;mediacodec_all_videos || ffp-&gt;mediacodec_avc || ffp-&gt;mediacodec_hevc || ffp-&gt;mediacodec_mpeg2)</span><br><span class="line">        node = ffpipenode_create_video_decoder_from_android_mediacodec(ffp, pipeline, opaque-&gt;weak_vout);</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        node = ffpipenode_create_video_decoder_from_ffplay(ffp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可以看出，如果<strong>硬解失败的话就转软解</strong></p>
<h4 id="decoder-start-1"><a href="#decoder-start-1" class="headerlink" title="decoder_start"></a>decoder_start</h4><p><code>decoder_start(&amp;is-&gt;viddec, video_thread, ffp, &quot;ff_video_dec&quot;)</code> 同样创建了一个视频的解码线程</p>
<ul>
<li><strong>软解</strong>：从 videoq 队列中获取视频包，解码视频帧放入 pictq 列表中</li>
<li><strong>硬解</strong>：从 videoq 队列中获取视频包，推送 MediaCodec 解码，获取解码 outputbuffer index 并存储在 Picts 列表中</li>
</ul>
<h2 id="read-thread-1"><a href="#read-thread-1" class="headerlink" title="read_thread"></a>read_thread</h2><p>在循环中不断的向几个队列中put数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* this thread gets the stream from the disk or the network */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">read_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">                <span class="keyword">if</span> (is-&gt;audio_stream &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    packet_queue_flush(&amp;is-&gt;audioq);</span><br><span class="line">                    packet_queue_put(&amp;is-&gt;audioq, &amp;flush_pkt);</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> clear invaild audio data</span></span><br><span class="line">                    <span class="comment">// SDL_AoutFlushAudio(ffp-&gt;aout);</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (is-&gt;subtitle_stream &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    packet_queue_flush(&amp;is-&gt;subtitleq);</span><br><span class="line">                    packet_queue_put(&amp;is-&gt;subtitleq, &amp;flush_pkt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (is-&gt;video_stream &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ffp-&gt;node_vdec) &#123;</span><br><span class="line">                        ffpipenode_flush(ffp-&gt;node_vdec);</span><br><span class="line">                    &#125;</span><br><span class="line">                    packet_queue_flush(&amp;is-&gt;videoq);</span><br><span class="line">                    packet_queue_put(&amp;is-&gt;videoq, &amp;flush_pkt);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2019/03/16/ijkplayer-from-constructor-to-prepare/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yydcdut.com">yydcdut</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>