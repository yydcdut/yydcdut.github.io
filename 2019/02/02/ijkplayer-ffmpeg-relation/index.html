<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ijkplayer框架简析 — FFmpeg中重要结构体 · Android杂文 - yydcdut</title><meta name="description" content="ijkplayer框架简析 — FFmpeg中重要结构体 - yydcdut"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yydcdut.com/atom.xml" title="Android杂文 - yydcdut"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut/yydcdut.github.io/issues" target="_blank" class="nav-list-link">COMMENT</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ijkplayer框架简析 — FFmpeg中重要结构体</h1><div class="post-info">2019年2月2日</div><div class="post-content"><p><code>A complete, cross-platform solution to record, convert and stream audio and video.</code></p>
<a id="more"></a>
<p>FFmpeg 是一个多媒体框架，能够处理解编码、转码、mux、demux、流、滤镜和播放。它支持很多格式，且具有高度的移植性。</p>
<h2 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h2><p><code>libavformat</code> - 用于解析和生成音视频格式<br><code>libavcodec</code> - 编解码音视频<br><code>libavutil</code> - 工具库<br><code>libswscale</code> - 提供比例缩放、色彩映射转换、图像颜色空间或格式转换的功能<br><code>libswresample</code> - 音频重采样，采样格式转换和混合等<br><code>libavfilter</code> -  滤波器，如宽高比裁剪、格式化、非格式化、伸缩<br><code>libpostproc</code> - 后期效果处理，如图像的去块效应等<br><code>libavdevice</code> -  硬件采集、加速、显示</p>
<h2 id="结构体之间关系"><a href="#结构体之间关系" class="headerlink" title="结构体之间关系"></a>结构体之间关系</h2><ul>
<li><p>协议（http, rtsp, rtmp, mms） </p>
<p>AVIOContext，URLProtocol，URLContext 主要存储视音频使用的协议的类型以及状态。URLProtocol 存储输入视音频使用的封装格式；每种协议都对应一个URLProtocol结构<em>（注意：FFMPEG中文件也被当做一种协议 “file” ）</em></p>
</li>
<li><p>封装（flv, avi, rmvb, mp4） </p>
<p>AVFormatContext 主要存储视音频封装格式中包含的信息；AVInputFormat 存储输入视音频使用的封装格式。每种视音频封装格式都对应一个 AVInputFormat 结构</p>
</li>
<li><p>编解码（h264, mpeg2, aac, mp3） </p>
<p>每个 AVStream 存储一个视频/音频流的相关数据；每个 AVStream 对应一个 AVCodecContext，存储该视频 / 音频流使用解码方式的相关数据；每个 AVCodecContext 中对应一个 AVCodec，包含该视频/音频对应的解码器。每种解码器都对应一个 AVCodec 结构</p>
</li>
<li><p>数据 </p>
<p>视频的话，每个结构一般是存一帧<em>（音频可能有好几帧）</em></p>
<p>解码前数据：AVPacket；解码后数据：AVFrame</p>
</li>
</ul>
<p><img src="http://yydcdut.com/img/ijkplayer_ffmpeg_%20relation.png" alt="img"></p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><h4 id="AVIOContext"><a href="#AVIOContext" class="headerlink" title="AVIOContext"></a>AVIOContext</h4><p>管理输入输出数据的结构体，<strong>在 <code>avformat_open_input()</code> 中进行初始化</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AVIOContext&#123;</span><br><span class="line">    <span class="keyword">const</span> AVClass *av_class;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer;  <span class="comment">/**&lt; Start of the buffer. */</span></span><br><span class="line">    <span class="keyword">int</span> buffer_size;        <span class="comment">/**&lt; Maximum buffer size */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf_ptr; <span class="comment">/**&lt; Current position in the buffer */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf_end; <span class="comment">/**&lt; End of the data */</span></span><br><span class="line">    <span class="keyword">int</span> (*read_packet)(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size);</span><br><span class="line">    <span class="keyword">int</span> (*write_packet)(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size);</span><br><span class="line">    <span class="keyword">int64_t</span> (*seek)(<span class="keyword">void</span> *opaque, <span class="keyword">int64_t</span> offset, <span class="keyword">int</span> whence);</span><br><span class="line">    <span class="keyword">int64_t</span> pos;            <span class="comment">/**&lt; position in the file of the current buffer */</span></span><br><span class="line">    <span class="keyword">int</span> must_flush;         <span class="comment">/**&lt; true if the next seek should flush */</span></span><br><span class="line">    <span class="keyword">int</span> eof_reached;        <span class="comment">/**&lt; true if eof reached */</span></span><br><span class="line">    <span class="keyword">int</span> write_flag;         <span class="comment">/**&lt; true if open for writing */</span></span><br><span class="line">    <span class="keyword">int</span> max_packet_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> checksum;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *checksum_ptr;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*update_checksum)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> checksum, <span class="keyword">const</span> uint8_t *buf, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> error;              <span class="comment">/**&lt; contains the error code or 0 if no error happened */</span></span><br><span class="line">    <span class="keyword">int</span> (*read_pause)(<span class="keyword">void</span> *opaque, <span class="keyword">int</span> pause);</span><br><span class="line">    <span class="keyword">int64_t</span> (*read_seek)(<span class="keyword">void</span> *opaque, <span class="keyword">int</span> stream_index,</span><br><span class="line">                         <span class="keyword">int64_t</span> timestamp, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> seekable;</span><br><span class="line">    <span class="keyword">int64_t</span> maxsize;</span><br><span class="line">    <span class="keyword">int</span> direct;</span><br><span class="line">    <span class="keyword">int64_t</span> bytes_read;</span><br><span class="line">    <span class="keyword">int</span> seek_count;</span><br><span class="line">    <span class="keyword">int</span> writeout_count;</span><br><span class="line">    <span class="keyword">int</span> orig_buffer_size;</span><br><span class="line">    <span class="keyword">int</span> short_seek_threshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>unsigned char *buffer : 缓存开始位置</li>
<li>int buffer_size : 缓存大小（默认32768）</li>
<li>unsigned char *buf_ptr : 当前指针读取到的位置</li>
<li>unsigned char *buf_end : 缓存结束的位置</li>
<li>void *opaque : URLContext 结构体 </li>
</ul>
<p>在解码的情况下，buffer 用于存储 ffmpeg 读入的数据。例如打开一个视频文件的时候，先把数据从硬盘读入buffer，然后在送给解码器用于解码。</p>
<h4 id="URLProtocol"><a href="#URLProtocol" class="headerlink" title="URLProtocol"></a>URLProtocol</h4><p>述了音视频数据传输所使用的协议，每种传输协议 (例如 HTTP、RTMP) 等，都会对应一个 URLProtocol 结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> URLProtocol &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="keyword">int</span> (*url_open)(URLContext *h, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags);</span><br><span class="line">	<span class="keyword">int</span> (*url_read)(URLContext *h, <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> size);</span><br><span class="line">	<span class="keyword">int</span> (*url_write)(URLContext *h, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> size);</span><br><span class="line">	<span class="keyword">int64_t</span> (*url_seek)(URLContext *h, <span class="keyword">int64_t</span> pos, <span class="keyword">int</span> whence);</span><br><span class="line">	<span class="keyword">int</span> (*url_close)(URLContext *h);</span><br><span class="line">	<span class="keyword">struct</span> URLProtocol *next;</span><br><span class="line">	<span class="keyword">int</span> (*url_read_pause)(URLContext *h, <span class="keyword">int</span> pause);</span><br><span class="line">	<span class="keyword">int64_t</span> (*url_read_seek)(URLContext *h, <span class="keyword">int</span> stream_index,</span><br><span class="line">		<span class="keyword">int64_t</span> timestamp, <span class="keyword">int</span> flags);</span><br><span class="line">	<span class="keyword">int</span> (*url_get_file_handle)(URLContext *h);</span><br><span class="line">	<span class="keyword">int</span> priv_data_size;</span><br><span class="line">	<span class="keyword">const</span> AVClass *priv_data_class;</span><br><span class="line">	<span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">int</span> (*url_check)(URLContext *h, <span class="keyword">int</span> mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>const char *name : 存储协议的名称，每一种输入协议都对应这样一个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">URLProtocol ff_rtmp_protocol = &#123;</span><br><span class="line">    .name                = <span class="string">"rtmp"</span>,</span><br><span class="line">    .url_open            = rtmp_open,</span><br><span class="line">    .url_read            = rtmp_read,</span><br><span class="line">    .url_write           = rtmp_write,</span><br><span class="line">    .url_close           = rtmp_close,</span><br><span class="line">    .url_read_pause      = rtmp_read_pause,</span><br><span class="line">    .url_read_seek       = rtmp_read_seek,</span><br><span class="line">    .url_get_file_handle = rtmp_get_file_handle,</span><br><span class="line">    .priv_data_size      = <span class="keyword">sizeof</span>(RTMP),</span><br><span class="line">    .flags               = URL_PROTOCOL_FLAG_NETWORK,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>等号右边的函数是完成具体读写功能的函数。可以看一下 file 协议的几个函数（file.c）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">file_read</span><span class="params">(URLContext *h, <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = (<span class="keyword">intptr_t</span>) h-&gt;priv_data;</span><br><span class="line">    <span class="keyword">int</span> r = read(fd, buf, size);</span><br><span class="line">    <span class="keyword">return</span> (-<span class="number">1</span> == r)?AVERROR(errno):r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">file_write</span><span class="params">(URLContext *h, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = (<span class="keyword">intptr_t</span>) h-&gt;priv_data;</span><br><span class="line">    <span class="keyword">int</span> r = write(fd, buf, size);</span><br><span class="line">    <span class="keyword">return</span> (-<span class="number">1</span> == r)?AVERROR(errno):r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">file_get_handle</span><span class="params">(URLContext *h)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">intptr_t</span>) h-&gt;priv_data;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">file_check</span><span class="params">(URLContext *h, <span class="keyword">int</span> mask)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> stat st;</span><br><span class="line">    <span class="keyword">int</span> ret = stat(h-&gt;filename, &amp;st);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> AVERROR(errno);</span><br><span class="line"> </span><br><span class="line">    ret |= st.st_mode&amp;S_IRUSR ? mask&amp;AVIO_FLAG_READ  : <span class="number">0</span>;</span><br><span class="line">    ret |= st.st_mode&amp;S_IWUSR ? mask&amp;AVIO_FLAG_WRITE : <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> CONFIG_FILE_PROTOCOL</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">file_open</span><span class="params">(URLContext *h, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flags)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> access;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"> </span><br><span class="line">    av_strstart(filename, <span class="string">"file:"</span>, &amp;filename);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AVIO_FLAG_WRITE &amp;&amp; flags &amp; AVIO_FLAG_READ) &#123;</span><br><span class="line">        access = O_CREAT | O_TRUNC | O_RDWR;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; AVIO_FLAG_WRITE) &#123;</span><br><span class="line">        access = O_CREAT | O_TRUNC | O_WRONLY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        access = O_RDONLY;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> O_BINARY</span></span><br><span class="line">    access |= O_BINARY;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    fd = open(filename, access, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> AVERROR(errno);</span><br><span class="line">    h-&gt;priv_data = (<span class="keyword">void</span> *) (<span class="keyword">intptr_t</span>) fd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* <span class="doctag">XXX:</span> use llseek */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> int64_t <span class="title">file_seek</span><span class="params">(URLContext *h, int64_t pos, <span class="keyword">int</span> whence)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = (<span class="keyword">intptr_t</span>) h-&gt;priv_data;</span><br><span class="line">    <span class="keyword">if</span> (whence == AVSEEK_SIZE) &#123;</span><br><span class="line">        <span class="keyword">struct</span> stat st;</span><br><span class="line">        <span class="keyword">int</span> ret = fstat(fd, &amp;st);</span><br><span class="line">        <span class="keyword">return</span> ret &lt; <span class="number">0</span> ? AVERROR(errno) : st.st_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lseek(fd, pos, whence);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">file_close</span><span class="params">(URLContext *h)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = (<span class="keyword">intptr_t</span>) h-&gt;priv_data;</span><br><span class="line">    <span class="keyword">return</span> close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="URLContext"><a href="#URLContext" class="headerlink" title="URLContext"></a>URLContext</h4><p>封装了协议对象及协议操作对象</p>
<h3 id="封装格式"><a href="#封装格式" class="headerlink" title="封装格式"></a>封装格式</h3><h4 id="AVFormatContext"><a href="#AVFormatContext" class="headerlink" title="AVFormatContext"></a>AVFormatContext</h4><p>描述了媒体文件的构成及基本信息，是统领全局的基本结构体，贯穿程序始终，很多函数都要用它作为参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AVFormatContext &#123;</span><br><span class="line">	<span class="keyword">const</span> AVClass *av_class;</span><br><span class="line">	<span class="keyword">struct</span> AVInputFormat *iformat;</span><br><span class="line">	<span class="keyword">struct</span> AVOutputFormat *oformat;</span><br><span class="line">	<span class="keyword">void</span> *priv_data;</span><br><span class="line">	AVIOContext *pb;</span><br><span class="line">	<span class="keyword">int</span> ctx_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nb_streams;</span><br><span class="line">	AVStream **streams;</span><br><span class="line">	<span class="keyword">char</span> filename[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">int64_t</span> start_time;</span><br><span class="line">	<span class="keyword">int64_t</span> duration;</span><br><span class="line">	<span class="keyword">int</span> bit_rate;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_size;</span><br><span class="line">    <span class="keyword">int</span> max_delay;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *key;</span><br><span class="line">    <span class="keyword">int</span> keylen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nb_programs;</span><br><span class="line">    AVProgram **programs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID video_codec_id;</span><br><span class="line">    <span class="keyword">enum</span> AVCodecID audio_codec_id;</span><br><span class="line">    <span class="keyword">enum</span> AVCodecID subtitle_codec_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_index_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_picture_buffer;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nb_chapters;</span><br><span class="line">    AVChapter **chapters;</span><br><span class="line">    AVDictionary *metadata;</span><br><span class="line">    <span class="keyword">int64_t</span> start_time_realtime;</span><br><span class="line">    <span class="keyword">int</span> fps_probe_size;</span><br><span class="line">    <span class="keyword">int</span> error_recognition;</span><br><span class="line">    AVIOInterruptCB interrupt_callback;</span><br><span class="line">    <span class="keyword">int64_t</span> max_interleave_delta;</span><br><span class="line">    <span class="keyword">int</span> strict_std_compliance;</span><br><span class="line">    <span class="keyword">int</span> event_flags;</span><br><span class="line">    <span class="keyword">int</span> max_ts_probe;</span><br><span class="line">    <span class="keyword">int</span> avoid_negative_ts;</span><br><span class="line">    <span class="keyword">int</span> ts_id;</span><br><span class="line">    <span class="keyword">int</span> audio_preload;</span><br><span class="line">    <span class="keyword">int</span> max_chunk_duration;</span><br><span class="line">    <span class="keyword">int</span> max_chunk_size;</span><br><span class="line">    <span class="keyword">int</span> use_wallclock_as_timestamps;</span><br><span class="line">    <span class="keyword">int</span> avio_flags;</span><br><span class="line">    <span class="keyword">enum</span> AVDurationEstimationMethod duration_estimation_method;</span><br><span class="line">    <span class="keyword">int64_t</span> skip_initial_bytes;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> correct_ts_overflow;</span><br><span class="line">    <span class="keyword">int</span> seek2any;</span><br><span class="line">    <span class="keyword">int</span> probe_score;</span><br><span class="line">    <span class="keyword">int</span> format_probesize;</span><br><span class="line">    <span class="keyword">char</span> *codec_whitelist;</span><br><span class="line">    <span class="keyword">char</span> *format_whitelist;</span><br><span class="line">    AVFormatInternal *internal;</span><br><span class="line">    <span class="keyword">int</span> io_repositioned;</span><br><span class="line">    AVCodec *video_codec;</span><br><span class="line">    AVCodec *audio_codec;</span><br><span class="line">    AVCodec *subtitle_codec;</span><br><span class="line">    AVCodec *data_codec;</span><br><span class="line">    <span class="keyword">int</span> metadata_header_padding;</span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line">    av_format_control_message control_message_cb;</span><br><span class="line">    <span class="keyword">int64_t</span> output_ts_offset;</span><br><span class="line">    <span class="keyword">uint8_t</span> *dump_separator;</span><br><span class="line">    <span class="keyword">enum</span> AVCodecID data_codec_id;</span><br><span class="line">    <span class="keyword">int</span> (*open_cb)(<span class="keyword">struct</span> AVFormatContext *s, AVIOContext **p, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags, <span class="keyword">const</span> AVIOInterruptCB *int_cb, AVDictionary **options);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>struct AVInputFormat *iformat : 输入数据的封装格式，由 <code>avformat_open_input</code> 设置，仅仅在 Demuxing 使用。</li>
<li>struct AVOutputFormat *oformat : 输出数据的封装格式，必须由使用者在<code>avformat_write_header</code>前设置，由 Muxing 使用</li>
<li>priv_data : 在 muxing 中，由 <code>avformat_write_header</code> 设置；在 demuxing 中，由 <code>avformat_open_input</code> 设置</li>
<li>AVIOContext *pb : 输入数据的缓存。如 果<code>iformat/oformat.flags</code> 设置为 <code>AVFMT_NOFILE</code> 的话，该字段不需要设置。对于 Demuxing ，需要在<code>avformat_open_input</code> 前设置，或由 <code>avformat_open_input</code> 设置；对于 Muxing,在 <code>avformat_write_header</code> 前设置</li>
<li>ctx_flags : 码流的信息，表明码流属性的的信号。由 <code>libavformat</code>设置，例如 <code>AVFMTCTX_NOHEADER</code></li>
<li>nb_streams : 指 <code>AVFormatContext.streams</code> 的数量，必须由 <code>avformat_new_stream</code>设置</li>
<li>AVStream **streams : 文件中所有码流的列表，新的码流创建使用 <code>avformat_new_stream</code> 函数。Demuxing 中，码流由 <code>avformat_open_input</code> 创建。 如果 <code>AVFMTCTX_NOHEADER</code> 被设置，新的码流可以出现在 <code>av_read_frame</code> 中。Muxing 中，码流在 <code>avformat_write_header</code> 之前由用户创建，它的释放是由 <code>avformat_free_context</code>完成的</li>
<li>filename : 输入或输出的文件名，Demuxing 中由 <code>avformat_open_input</code> 设置，Muxing 中在使用 <code>avformat_write_header</code> 前由调用者设置</li>
<li>int64_t duration : 码流的时长</li>
<li>bit_rate : 比特率</li>
<li>AVDictionary *metadata : 元数据，适用于整个文件。通过 <code>av_dict_get()</code> 函数获得视频的原数据</li>
</ul>
<h4 id="AVInputFormat"><a href="#AVInputFormat" class="headerlink" title="AVInputFormat"></a>AVInputFormat</h4><p>解复用器对象，每种作为输入的封装格式 (例如 <em>FLV</em>、<em>MP4</em>、<em>TS</em> 等) 对应一个该结构体</p>
<h4 id="AVOutputFormat"><a href="#AVOutputFormat" class="headerlink" title="AVOutputFormat"></a>AVOutputFormat</h4><p>复用器对象，每种作为输出的封装格式（例如 <em>FLV</em>, <em>MP4</em>、<em>TS</em> 等）对应一个该结构体</p>
<h4 id="AVStream"><a href="#AVStream" class="headerlink" title="AVStream"></a>AVStream</h4><p>用于描述一个视频 / 音频流的相关数据信息</p>
<h3 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h3><h4 id="AVCodecContext"><a href="#AVCodecContext" class="headerlink" title="AVCodecContext"></a>AVCodecContext</h4><p>描述编解码器上下文的数据结构，包含了众多编解码器需要的参数信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AVCodecContext&#123;</span><br><span class="line">	<span class="keyword">const</span> AVClass *av_class;</span><br><span class="line">	<span class="keyword">int</span> log_level_offset;</span><br><span class="line">	<span class="keyword">enum</span> AVMediaType codec_type;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> AVCodec *codec;</span><br><span class="line">	<span class="keyword">enum</span> AVCodecID     codec_id;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> codec_tag;</span><br><span class="line">	<span class="keyword">void</span> *priv_data;</span><br><span class="line">	<span class="keyword">struct</span> AVCodecInternal *internal;</span><br><span class="line">	<span class="keyword">void</span> *opaque;</span><br><span class="line">	<span class="keyword">int</span> bit_rate;</span><br><span class="line">	<span class="keyword">int</span> bit_rate_tolerance;</span><br><span class="line">	<span class="keyword">int</span> global_quality;</span><br><span class="line">	<span class="keyword">int</span> compression_level;</span><br><span class="line">	<span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">int</span> flags2;</span><br><span class="line">	<span class="keyword">uint8_t</span> *extradata;</span><br><span class="line">	<span class="keyword">int</span> extradata_size;</span><br><span class="line">	AVRational time_base;</span><br><span class="line">	<span class="keyword">int</span> ticks_per_frame;</span><br><span class="line">	<span class="keyword">int</span> delay;</span><br><span class="line">	<span class="keyword">int</span> width, height;</span><br><span class="line">	<span class="keyword">int</span> coded_width, coded_height;</span><br><span class="line">	<span class="keyword">int</span> gop_size;</span><br><span class="line">	<span class="keyword">enum</span> AVPixelFormat pix_fmt;</span><br><span class="line">	<span class="keyword">void</span> (*draw_horiz_band)(<span class="keyword">struct</span> AVCodecContext *s,</span><br><span class="line">                            <span class="keyword">const</span> AVFrame *src, <span class="keyword">int</span> offset[AV_NUM_DATA_POINTERS],</span><br><span class="line">                            <span class="keyword">int</span> y, <span class="keyword">int</span> type, <span class="keyword">int</span> height);</span><br><span class="line">	<span class="function"><span class="keyword">enum</span> <span class="title">AVPixelFormat</span> <span class="params">(*get_format)</span><span class="params">(<span class="keyword">struct</span> AVCodecContext *s, <span class="keyword">const</span> <span class="keyword">enum</span> AVPixelFormat * fmt)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> max_b_frames;</span><br><span class="line">	<span class="keyword">float</span> b_quant_factor;</span><br><span class="line">	<span class="keyword">int</span> b_frame_strategy;</span><br><span class="line">	<span class="keyword">float</span> b_quant_offset;</span><br><span class="line">	<span class="keyword">int</span> has_b_frames;</span><br><span class="line">	<span class="keyword">int</span> mpeg_quant; 		<span class="comment">/*decoding: unused*/</span></span><br><span class="line">	<span class="keyword">float</span> i_quant_factor; 	<span class="comment">/*decoding: unused*/</span></span><br><span class="line">	<span class="keyword">float</span> i_quant_offset; 	<span class="comment">/*decoding: unused*/</span></span><br><span class="line">	<span class="keyword">float</span> lumi_masking;		<span class="comment">/*decoding: unused*/</span></span><br><span class="line">	<span class="keyword">float</span> temporal_cplx_masking; <span class="comment">/*decoding: unused*/</span></span><br><span class="line">	<span class="keyword">float</span> spatial_cplx_masking;  <span class="comment">/*decoding: unused*/</span></span><br><span class="line">	<span class="keyword">float</span> p_masking;		<span class="comment">/*decoding: unused*/</span></span><br><span class="line">	<span class="keyword">float</span> dark_masking;		<span class="comment">/*decoding: unused*/</span></span><br><span class="line">	<span class="keyword">int</span> slice_count;</span><br><span class="line">	<span class="keyword">int</span> prediction_method;	<span class="comment">/*decoding: unused*/</span></span><br><span class="line">	<span class="keyword">int</span> *slice_offset;</span><br><span class="line">	AVRational sample_aspect_ratio;</span><br><span class="line">	<span class="keyword">int</span> me_cmp;				<span class="comment">/*decoding: unused*/</span></span><br><span class="line">	<span class="keyword">int</span> me_sub_cmp;			<span class="comment">/*decoding: unused*/</span></span><br><span class="line">	<span class="keyword">int</span> mb_cmp;				<span class="comment">/*decoding: unused*/</span></span><br><span class="line">    ...</span><br><span class="line">&#125;AVCodecContext;</span><br></pre></td></tr></table></figure>
<ul>
<li>AVMediaType codec_type : 编解码器的类型，如音频、视频、字幕</li>
<li>AVCdec *codec : 采用的解码器 AVCodec</li>
<li>int bit_rate : 平均比特率</li>
<li>uint8_t *extradata; int extradata_size : 针对特定编码器包含的附加信息（例如对于H.264解码器来说，存储SPS，PPS等）</li>
<li>AVRational time_base : 根据该参数，可以把PTS转化为实际的时间（单位为秒s）</li>
<li>int width, height : 视频的宽高</li>
<li>int refs : 运动估计参考帧的个数</li>
<li>int sample_rate : 采样率</li>
<li>int channels : 声道数</li>
<li>enum AVSampleFormat sample_fmt : 采样格式</li>
<li>int profile : 型（H.264里面就有，其他编码标准应该也有）</li>
<li>int level : 级（和profile差不太多）</li>
</ul>
<p>AVCodecContext 使用 avcodec_alloc_context3 分配，该函数除了分配 AVCodecContext 外，还会初始化默认的字段。分配的内存必须通过 avcodec_free_context 释放。<em>AVCodecContext 中很多的参数是编码的时候使用的，而不是解码的时候使用的</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">avcodec_register_all();</span><br><span class="line">...</span><br><span class="line">codec = avcodec_find_decoder(AV_CODEC_ID_H264);</span><br><span class="line"><span class="keyword">if</span>(!codec)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">context = avcodec_alloc_context3(codec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(avcodec_open2(context, codec, opts) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h5 id="codec-type-编解码器类型"><a href="#codec-type-编解码器类型" class="headerlink" title="codec_type(编解码器类型)"></a>codec_type(编解码器类型)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVMediaType &#123;</span><br><span class="line">    AVMEDIA_TYPE_UNKNOWN = -<span class="number">1</span>,  <span class="comment">///&lt; Usually treated as AVMEDIA_TYPE_DATA</span></span><br><span class="line">    AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    AVMEDIA_TYPE_AUDIO,</span><br><span class="line">    AVMEDIA_TYPE_DATA,          <span class="comment">///&lt; Opaque data information usually continuous</span></span><br><span class="line">    AVMEDIA_TYPE_SUBTITLE,</span><br><span class="line">    AVMEDIA_TYPE_ATTACHMENT,    <span class="comment">///&lt; Opaque data information usually sparse</span></span><br><span class="line">    AVMEDIA_TYPE_NB</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="sample-fmt-音频采样格式"><a href="#sample-fmt-音频采样格式" class="headerlink" title="sample_fmt(音频采样格式)"></a>sample_fmt(音频采样格式)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVSampleFormat &#123;</span><br><span class="line">    AV_SAMPLE_FMT_NONE = -<span class="number">1</span>,</span><br><span class="line">    AV_SAMPLE_FMT_U8,          <span class="comment">///&lt; unsigned 8 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S16,         <span class="comment">///&lt; signed 16 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S32,         <span class="comment">///&lt; signed 32 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_FLT,         <span class="comment">///&lt; float</span></span><br><span class="line">    AV_SAMPLE_FMT_DBL,         <span class="comment">///&lt; double</span></span><br><span class="line"> </span><br><span class="line">    AV_SAMPLE_FMT_U8P,         <span class="comment">///&lt; unsigned 8 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S16P,        <span class="comment">///&lt; signed 16 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S32P,        <span class="comment">///&lt; signed 32 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_FLTP,        <span class="comment">///&lt; float, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_DBLP,        <span class="comment">///&lt; double, planar</span></span><br><span class="line"> </span><br><span class="line">    AV_SAMPLE_FMT_NB           <span class="comment">///&lt; Number of sample formats. DO NOT USE if linking dynamically</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_UNKNOWN -<span class="number">99</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_RESERVED -<span class="number">100</span></span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_AAC_MAIN <span class="number">0</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_AAC_LOW  <span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_AAC_SSR  <span class="number">2</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_AAC_LTP  <span class="number">3</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_AAC_HE   <span class="number">4</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_AAC_HE_V2 <span class="number">28</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_AAC_LD   <span class="number">22</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_AAC_ELD  <span class="number">38</span></span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_DTS         <span class="number">20</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_DTS_ES      <span class="number">30</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_DTS_96_24   <span class="number">40</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_DTS_HD_HRA  <span class="number">50</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_DTS_HD_MA   <span class="number">60</span></span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG2_422    <span class="number">0</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG2_HIGH   <span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG2_SS     <span class="number">2</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG2_SNR_SCALABLE  <span class="number">3</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG2_MAIN   <span class="number">4</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG2_SIMPLE <span class="number">5</span></span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_H264_CONSTRAINED  (<span class="number">1</span>&lt;&lt;<span class="number">9</span>)  <span class="comment">// 8+1; constraint_set1_flag</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_H264_INTRA        (<span class="number">1</span>&lt;&lt;<span class="number">11</span>) <span class="comment">// 8+3; constraint_set3_flag</span></span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_H264_BASELINE             <span class="number">66</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_H264_CONSTRAINED_BASELINE (<span class="number">66</span>|FF_PROFILE_H264_CONSTRAINED)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_H264_MAIN                 <span class="number">77</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_H264_EXTENDED             <span class="number">88</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_H264_HIGH                 <span class="number">100</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_H264_HIGH_10              <span class="number">110</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_H264_HIGH_10_INTRA        (<span class="number">110</span>|FF_PROFILE_H264_INTRA)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_H264_HIGH_422             <span class="number">122</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_H264_HIGH_422_INTRA       (<span class="number">122</span>|FF_PROFILE_H264_INTRA)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_H264_HIGH_444             <span class="number">144</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_H264_HIGH_444_PREDICTIVE  <span class="number">244</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_H264_HIGH_444_INTRA       (<span class="number">244</span>|FF_PROFILE_H264_INTRA)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_H264_CAVLC_444            <span class="number">44</span></span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_VC1_SIMPLE   <span class="number">0</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_VC1_MAIN     <span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_VC1_COMPLEX  <span class="number">2</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_VC1_ADVANCED <span class="number">3</span></span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG4_SIMPLE                     <span class="number">0</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG4_SIMPLE_SCALABLE            <span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG4_CORE                       <span class="number">2</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG4_MAIN                       <span class="number">3</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG4_N_BIT                      <span class="number">4</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG4_SCALABLE_TEXTURE           <span class="number">5</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION      <span class="number">6</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE     <span class="number">7</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG4_HYBRID                     <span class="number">8</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG4_ADVANCED_REAL_TIME         <span class="number">9</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG4_CORE_SCALABLE             <span class="number">10</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG4_ADVANCED_CODING           <span class="number">11</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG4_ADVANCED_CORE             <span class="number">12</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE <span class="number">13</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG4_SIMPLE_STUDIO             <span class="number">14</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FF_PROFILE_MPEG4_ADVANCED_SIMPLE           <span class="number">15</span></span></span><br></pre></td></tr></table></figure>
<h4 id="AVCodec"><a href="#AVCodec" class="headerlink" title="AVCodec"></a>AVCodec</h4><p>编解码器对象，每种编解码格式 (例如 H.264、AAC 等）对应一个该结构体；每个 AVCodecContext 中含有一个 AVCodec</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AVCodec&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *long_name;</span><br><span class="line">    <span class="keyword">enum</span> AVMediaType type;</span><br><span class="line">    <span class="keyword">enum</span> AVCodecID id;</span><br><span class="line">    <span class="keyword">int</span> capabilities;</span><br><span class="line">    <span class="keyword">const</span> AVRational *supported_framerates; <span class="comment">///&lt; array of supported framerates, or NULL if any, array is terminated by &#123;0,0&#125;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">enum</span> AVPixelFormat *pix_fmts;     <span class="comment">///&lt; array of supported pixel formats, or NULL if unknown, array is terminated by -1</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *supported_samplerates;       <span class="comment">///&lt; array of supported audio samplerates, or NULL if unknown, array is terminated by 0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">enum</span> AVSampleFormat *sample_fmts; <span class="comment">///&lt; array of supported sample formats, or NULL if unknown, array is terminated by -1</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> *channel_layouts;         <span class="comment">///&lt; array of support channel layouts, or NULL if unknown. array is terminated by 0</span></span><br><span class="line">    <span class="keyword">uint8_t</span> max_lowres;                     <span class="comment">///&lt; maximum value for lowres supported by the decoder, no direct access, use av_codec_get_max_lowres()</span></span><br><span class="line">    <span class="keyword">const</span> AVClass *priv_class;              <span class="comment">///&lt; AVClass for the private context</span></span><br><span class="line">    <span class="keyword">const</span> AVProfile *profiles;              <span class="comment">///&lt; array of recognized profiles, or NULL if unknown, array is terminated by &#123;FF_PROFILE_UNKNOWN&#125;</span></span><br><span class="line">    <span class="keyword">int</span> priv_data_size;</span><br><span class="line">    <span class="keyword">struct</span> AVCodec *next;</span><br><span class="line">    <span class="keyword">int</span> (*init_thread_copy)(AVCodecContext *);</span><br><span class="line">    <span class="keyword">int</span> (*update_thread_context)(AVCodecContext *dst, <span class="keyword">const</span> AVCodecContext *src);</span><br><span class="line">    <span class="keyword">const</span> AVCodecDefault *defaults;</span><br><span class="line">    <span class="keyword">void</span> (*init_static_data)(<span class="keyword">struct</span> AVCodec *codec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*init)(AVCodecContext *);</span><br><span class="line">    <span class="keyword">int</span> (*encode_sub)(AVCodecContext *, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size,</span><br><span class="line">    <span class="keyword">int</span> (*encode2)(AVCodecContext *avctx, AVPacket *avpkt, <span class="keyword">const</span> AVFrame *frame,</span><br><span class="line">                   <span class="keyword">int</span> *got_packet_ptr);</span><br><span class="line">    <span class="keyword">int</span> (*decode)(AVCodecContext *, <span class="keyword">void</span> *outdata, <span class="keyword">int</span> *outdata_size, AVPacket *avpkt);</span><br><span class="line">    <span class="keyword">int</span> (*close)(AVCodecContext *);</span><br><span class="line">    <span class="keyword">void</span> (*flush)(AVCodecContext *);</span><br><span class="line">    <span class="keyword">int</span> caps_internal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>name : 具体的 CODEC 的名称的简短描述，比如 “HEVC”/“H264” 等</li>
<li>long_name : CODEC 名称的详细描述，比如 “HEVC (High Efficiency Video Coding)”</li>
<li>type : 媒体类型的字段，它是 enum 型的，表示视频、音频、字幕等，比如AVMEDIA_TYPE_VIDEO、AVMEIDA_TYPE_AUDIO</li>
<li>id : 唯一标识的 CODEC 类型，比如 AV_CODEC_ID_HEVC</li>
<li>supported_framerates : 支持的视频帧率的数组，以{0，0}作为结束</li>
<li>pix_fmts : 编解码器支持的图像格式的数组，以 -1 作为结束</li>
<li>profiles : 编解码器支持的 Profile，以 HEVC 为例，包含 “Main” / “Main10” / “Main Still Picture”</li>
<li>supported_samplerates : 支持的音频采样率</li>
<li>sample_fmts : 支持的音频采样格式</li>
<li>channel_layouts : 支持的音频声道数</li>
<li>priv_data_size : 私有数据的大小</li>
</ul>
<h5 id="enum-AVMediaType-type"><a href="#enum-AVMediaType-type" class="headerlink" title="enum AVMediaType type"></a>enum AVMediaType type</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVMediaType &#123;</span><br><span class="line">    AVMEDIA_TYPE_UNKNOWN = -<span class="number">1</span>,  <span class="comment">///&lt; Usually treated as AVMEDIA_TYPE_DATA</span></span><br><span class="line">    AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    AVMEDIA_TYPE_AUDIO,</span><br><span class="line">    AVMEDIA_TYPE_DATA,          <span class="comment">///&lt; Opaque data information usually continuous</span></span><br><span class="line">    AVMEDIA_TYPE_SUBTITLE,</span><br><span class="line">    AVMEDIA_TYPE_ATTACHMENT,    <span class="comment">///&lt; Opaque data information usually sparse</span></span><br><span class="line">    AVMEDIA_TYPE_NB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="enum-AVCodecID-id"><a href="#enum-AVCodecID-id" class="headerlink" title="enum AVCodecID id"></a>enum AVCodecID id</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVCodecID &#123;</span><br><span class="line">    AV_CODEC_ID_NONE,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* video codecs */</span></span><br><span class="line">    AV_CODEC_ID_MPEG1VIDEO,</span><br><span class="line">    AV_CODEC_ID_MPEG2VIDEO, <span class="comment">///&lt; preferred ID for MPEG-1/2 video decoding</span></span><br><span class="line">    AV_CODEC_ID_MPEG2VIDEO_XVMC,</span><br><span class="line">    AV_CODEC_ID_H261,</span><br><span class="line">    AV_CODEC_ID_H263,</span><br><span class="line">    AV_CODEC_ID_RV10,</span><br><span class="line">    AV_CODEC_ID_RV20,</span><br><span class="line">    AV_CODEC_ID_MJPEG,</span><br><span class="line">    AV_CODEC_ID_MJPEGB,</span><br><span class="line">    AV_CODEC_ID_LJPEG,</span><br><span class="line">    AV_CODEC_ID_SP5X,</span><br><span class="line">    AV_CODEC_ID_JPEGLS,</span><br><span class="line">    AV_CODEC_ID_MPEG4,</span><br><span class="line">    AV_CODEC_ID_RAWVIDEO,</span><br><span class="line">    AV_CODEC_ID_MSMPEG4V1,</span><br><span class="line">    AV_CODEC_ID_MSMPEG4V2,</span><br><span class="line">    AV_CODEC_ID_MSMPEG4V3,</span><br><span class="line">    AV_CODEC_ID_WMV1,</span><br><span class="line">    AV_CODEC_ID_WMV2,</span><br><span class="line">    AV_CODEC_ID_H263P,</span><br><span class="line">    AV_CODEC_ID_H263I,</span><br><span class="line">    AV_CODEC_ID_FLV1,</span><br><span class="line">    AV_CODEC_ID_SVQ1,</span><br><span class="line">    AV_CODEC_ID_SVQ3,</span><br><span class="line">    AV_CODEC_ID_DVVIDEO,</span><br><span class="line">    AV_CODEC_ID_HUFFYUV,</span><br><span class="line">    AV_CODEC_ID_CYUV,</span><br><span class="line">    AV_CODEC_ID_H264,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="const-enum-AVPixelFormat-pix-fmts"><a href="#const-enum-AVPixelFormat-pix-fmts" class="headerlink" title="const enum AVPixelFormat *pix_fmts"></a>const enum AVPixelFormat *pix_fmts</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVPixelFormat &#123;</span><br><span class="line">    AV_PIX_FMT_NONE = -<span class="number">1</span>,</span><br><span class="line">    AV_PIX_FMT_YUV420P,   <span class="comment">///&lt; planar YUV 4:2:0, 12bpp, (1 Cr &amp; Cb sample per 2x2 Y samples)</span></span><br><span class="line">    AV_PIX_FMT_YUYV422,   <span class="comment">///&lt; packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr</span></span><br><span class="line">    AV_PIX_FMT_RGB24,     <span class="comment">///&lt; packed RGB 8:8:8, 24bpp, RGBRGB...</span></span><br><span class="line">    AV_PIX_FMT_BGR24,     <span class="comment">///&lt; packed RGB 8:8:8, 24bpp, BGRBGR...</span></span><br><span class="line">    AV_PIX_FMT_YUV422P,   <span class="comment">///&lt; planar YUV 4:2:2, 16bpp, (1 Cr &amp; Cb sample per 2x1 Y samples)</span></span><br><span class="line">    AV_PIX_FMT_YUV444P,   <span class="comment">///&lt; planar YUV 4:4:4, 24bpp, (1 Cr &amp; Cb sample per 1x1 Y samples)</span></span><br><span class="line">    AV_PIX_FMT_YUV410P,   <span class="comment">///&lt; planar YUV 4:1:0,  9bpp, (1 Cr &amp; Cb sample per 4x4 Y samples)</span></span><br><span class="line">    AV_PIX_FMT_YUV411P,   <span class="comment">///&lt; planar YUV 4:1:1, 12bpp, (1 Cr &amp; Cb sample per 4x1 Y samples)</span></span><br><span class="line">    AV_PIX_FMT_GRAY8,     <span class="comment">///&lt;        Y        ,  8bpp</span></span><br><span class="line">    AV_PIX_FMT_MONOWHITE, <span class="comment">///&lt;        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb</span></span><br><span class="line">    AV_PIX_FMT_MONOBLACK, <span class="comment">///&lt;        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb</span></span><br><span class="line">    AV_PIX_FMT_PAL8,      <span class="comment">///&lt; 8 bit with PIX_FMT_RGB32 palette</span></span><br><span class="line">    AV_PIX_FMT_YUVJ420P,  <span class="comment">///&lt; planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of PIX_FMT_YUV420P and setting color_range</span></span><br><span class="line">    AV_PIX_FMT_YUVJ422P,  <span class="comment">///&lt; planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of PIX_FMT_YUV422P and setting color_range</span></span><br><span class="line">    AV_PIX_FMT_YUVJ444P,  <span class="comment">///&lt; planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of PIX_FMT_YUV444P and setting color_range</span></span><br><span class="line">    AV_PIX_FMT_XVMC_MPEG2_MC,<span class="comment">///&lt; XVideo Motion Acceleration via common packet passing</span></span><br><span class="line">    AV_PIX_FMT_XVMC_MPEG2_IDCT,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="const-enum-AVSampleFormat-sample-fmts"><a href="#const-enum-AVSampleFormat-sample-fmts" class="headerlink" title="const enum AVSampleFormat *sample_fmts"></a>const enum AVSampleFormat *sample_fmts</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVSampleFormat &#123;</span><br><span class="line">    AV_SAMPLE_FMT_NONE = -<span class="number">1</span>,</span><br><span class="line">    AV_SAMPLE_FMT_U8,          <span class="comment">///&lt; unsigned 8 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S16,         <span class="comment">///&lt; signed 16 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S32,         <span class="comment">///&lt; signed 32 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_FLT,         <span class="comment">///&lt; float</span></span><br><span class="line">    AV_SAMPLE_FMT_DBL,         <span class="comment">///&lt; double</span></span><br><span class="line"> </span><br><span class="line">    AV_SAMPLE_FMT_U8P,         <span class="comment">///&lt; unsigned 8 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S16P,        <span class="comment">///&lt; signed 16 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S32P,        <span class="comment">///&lt; signed 32 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_FLTP,        <span class="comment">///&lt; float, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_DBLP,        <span class="comment">///&lt; double, planar</span></span><br><span class="line"> </span><br><span class="line">    AV_SAMPLE_FMT_NB           <span class="comment">///&lt; Number of sample formats. DO NOT USE if linking dynamically</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每一个编解码器对应一个 AVCodec 该结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AVCodec ff_h264_decoder = &#123;</span><br><span class="line">    .name           = <span class="string">"h264"</span>,</span><br><span class="line">    .type           = AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    .id             = CODEC_ID_H264,</span><br><span class="line">    .priv_data_size = <span class="keyword">sizeof</span>(H264Context),</span><br><span class="line">    .init           = ff_h264_decode_init,</span><br><span class="line">    .close          = ff_h264_decode_end,</span><br><span class="line">    .decode         = decode_frame,</span><br><span class="line">    .capabilities   = <span class="comment">/*CODEC_CAP_DRAW_HORIZ_BAND |*/</span> CODEC_CAP_DR1 | CODEC_CAP_DELAY |</span><br><span class="line">                      CODEC_CAP_SLICE_THREADS | CODEC_CAP_FRAME_THREADS,</span><br><span class="line">    .flush= flush_dpb,</span><br><span class="line">    .long_name = NULL_IF_CONFIG_SMALL(<span class="string">"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"</span>),</span><br><span class="line">    .init_thread_copy      = ONLY_IF_THREADS_ENABLED(decode_init_thread_copy),</span><br><span class="line">    .update_thread_context = ONLY_IF_THREADS_ENABLED(decode_update_thread_context),</span><br><span class="line">    .profiles = NULL_IF_CONFIG_SMALL(profiles),</span><br><span class="line">    .priv_class     = &amp;h264_class,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="AVCodecParameters"><a href="#AVCodecParameters" class="headerlink" title="AVCodecParameters"></a>AVCodecParameters</h4><p>编解码参数，每个 AVStream 中都含有一个 AVCodecParameters，用来存放当前流的编解码参数</p>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><h4 id="AVPacket"><a href="#AVPacket" class="headerlink" title="AVPacket"></a>AVPacket</h4><p>存放编码后、解码前的压缩数据，即 ES 数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AVPacket&#123;</span><br><span class="line">	AVBufferRef *buf;</span><br><span class="line">	<span class="keyword">int64_t</span>      pts;</span><br><span class="line">	<span class="keyword">int64_t</span>      dts;</span><br><span class="line">	<span class="keyword">uint8_t</span>    *data;</span><br><span class="line">	<span class="keyword">int</span>         size;</span><br><span class="line">	<span class="keyword">int</span> stream_index;</span><br><span class="line">	<span class="keyword">int</span>        flags;</span><br><span class="line">	AVPacketSideData *side_data;</span><br><span class="line">	<span class="keyword">int</span> side_data_elems;</span><br><span class="line">	<span class="keyword">int</span>   duration;</span><br><span class="line">	<span class="keyword">int64_t</span> pos;</span><br><span class="line">	<span class="keyword">int64_t</span> convergence_duration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>pts: 显示时间戳，它的单位是 AVStream-&gt;time_base；如果在文件中没有保存这个值，它被设置为 AV_NOPTS_VALUE。由于图像显示不可能早于图像解压，因此 PTS 必须比 DTS（解码时间戳）大或者相等。某些文件格式中可能会使用 PTS/DTS 表示其他含义，此时时间戳必须转为真正的时间戳才能保存到 AVPacket 结构中</li>
<li>dts : 解码时间戳，它的单位是 AVStream-&gt;time_base，表示压缩视频解码的时间，如果文件中没有保存该值，它被设置为 AV_NOPTS_VALUE</li>
<li>data : 指向真正的压缩编码的数据</li>
<li>size : 表示该 AVPacket 结构中 data 字段所指向的压缩数据的大小</li>
<li>stream_index : 标识该 AVPacket 结构所属的视频流或音频流</li>
<li>duration : 该 AVPacket 包以 AVStream-&gt;time_base 为单位，所持续的时间，0 表示未知，或者为显示时间戳的差值(next_pts - this pts)</li>
<li>pos : 表示该 AVPacket 数据在媒体中的位置，即字节偏移量</li>
</ul>
<h4 id="AVFrame"><a href="#AVFrame" class="headerlink" title="AVFrame"></a>AVFrame</h4><p>存放编码前、解码后的原始数据，如 YUV 格式的视频数据或 PCM 格式的音频数据等</p>
<p>AVFrame 结构体必须使用 <code>av_frame_alloc()</code> 分配，注意该函数只是分配了 AVFrame 结构本身，它的 data 区域要用其他方式管理；该结构体的释放要用 <code>av_frame_free()</code>。</p>
<p>AVFrame 结构体通常只需分配一次，之后即可通过保存不同的数据来重复多次使用，比如一个 AVFrame 结构可以保存从解码器中解码出的多帧数据。此时，就可以使用<code>av_frame_unref()</code>释放任何由 Frame 保存的参考帧并还原回最原始的状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AVFrame&#123;</span><br><span class="line">	<span class="keyword">uint8_t</span> *data[AV_NUM_DATA_POINTERS];</span><br><span class="line">	<span class="keyword">int</span> linesize[AV_NUM_DATA_POINTERS];</span><br><span class="line">	<span class="keyword">uint8_t</span> **extended_data;</span><br><span class="line">	<span class="keyword">int</span> width, height;</span><br><span class="line">	<span class="keyword">int</span> nb_samples; <span class="comment">/* number of audio samples(per channel) described by this frame */</span></span><br><span class="line">	<span class="keyword">int</span> format;</span><br><span class="line">	<span class="keyword">int</span> key_frame; <span class="comment">/* 1-&gt;keyframe, 0-&gt;not*/</span></span><br><span class="line">	<span class="keyword">enum</span> AVPictureType pict_type;</span><br><span class="line">	AVRational sample_aspect_ratio;</span><br><span class="line">	<span class="keyword">int64_t</span> pts;</span><br><span class="line">	<span class="keyword">int64_t</span> pkt_pts;</span><br><span class="line">	<span class="keyword">int64_t</span> pkt_dts;</span><br><span class="line">	<span class="keyword">int</span> coded_picture_number;</span><br><span class="line">	<span class="keyword">int</span> display_picture_number;</span><br><span class="line">	<span class="keyword">int</span> quality;</span><br><span class="line">	<span class="keyword">void</span> *opaque; <span class="comment">/* for some private data of the user */</span></span><br><span class="line">	<span class="keyword">uint64_t</span> error[AV_NUM_DATA_POINTERS];</span><br><span class="line">	<span class="keyword">int</span> repeat_pict;</span><br><span class="line">	<span class="keyword">int</span> interlaced_frame;</span><br><span class="line">	<span class="keyword">int</span> top_field_first;	<span class="comment">/* If the content is interlaced, is top field displayed first */</span></span><br><span class="line">	<span class="keyword">int</span> palette_has_changed;</span><br><span class="line">    <span class="keyword">int64_t</span> reordered_opaque;</span><br><span class="line">    <span class="keyword">int</span> sample_rate;    <span class="comment">/*Sample rate of the audio data*/</span></span><br><span class="line">    <span class="keyword">uint64_t</span> channel_layout; <span class="comment">/*channel layout of the audio data*/</span></span><br><span class="line">    AVBufferRef *buf[AV_NUM_DATA_POINTERS];</span><br><span class="line">    AVBufferRef **extended_buf;</span><br><span class="line">    <span class="keyword">int</span> nb_exteneded_buf;</span><br><span class="line">    AVFrameSideData **side_data;</span><br><span class="line">    <span class="keyword">int</span> nb_side_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">enum</span> AVColorRange color_range;</span><br><span class="line">    <span class="keyword">enum</span> AVColorPrimaries color_primaries;</span><br><span class="line">    <span class="keyword">enum</span> AVColorTransferCharacteristic color_trc;</span><br><span class="line">    <span class="keyword">enum</span> AVColorSpace colorspace;</span><br><span class="line">    <span class="keyword">enum</span> AVChromaLocation chroma_location;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> best_effort_timestamp;</span><br><span class="line">    <span class="keyword">int64_t</span> pkt_pos;</span><br><span class="line">    <span class="keyword">int64_t</span> pkt_duration;</span><br><span class="line">    AVDictionary *metadata;</span><br><span class="line">    <span class="keyword">int</span> decode _error_flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> channels;</span><br><span class="line">    <span class="keyword">int</span> pkt_size;</span><br><span class="line">    AVBufferRef *qp_table_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>data : 指向图片或信道的指针，与初始化时分配的大小可能不同，一些解码器取数据范围超出 (0,0)-(width, height) ，具体请查看 <code>avcodec_align_dimensions2()</code> 方法。一些过滤器或扫描器读数据时可能会超过 16 字节，所以当它们使用时，必须额外分配 16 字节。对于 packed 格式的数据(例如 RGB24)，会存放到 data[0] 里面；对于 planar 格式的数据(例如 YUV420P)，则会分开 data[0]/data[1]/data[2]（YUV420P 中 data[0] 存放 Y，data[1] 存放 U，data[2] 存放 V）</li>
<li>linesize : 对于视频数据，表示每个图像行的字节大小；对于音频数据，表示每个 Plane 的字节大小，只有linesize[0]可以设置，对于plane 音频，每个信道 channel 必须是相同的。对于视频的 linesize 应为 CPU 的对准要求的倍数，一般为 32。注意 linesize 可大于可用的数据的尺寸，有可能存在由于性能原因额外填充</li>
<li>width/height : 视频的宽高</li>
<li>format : 帧格式,-1表示未设置的帧格式。对于视频帧，该值为 enum 类型的 AVPixelFormat，例如 AV_PIX_FMT_YUV420P；对于音频帧，该值为 enum 型的 AVSampleFormat，例如 AV_SAMPLE_FMT_S16</li>
<li>key_frame : 关键帧，1 表示关键帧，0 表示非关键帧</li>
<li>pict_type : 帧图片类型，例如 I/P/B</li>
<li>sample_aspect_ration : 帧像素的宽高比，使用 AVRational 表示（16:9，4:3…）</li>
<li>pts : 显示时间戳，单位为 time_base</li>
<li>pkt_pts : 该 PTS 是从 AVPacket 结构中拷贝过来的；与之对应的是 pkt_dts</li>
<li>coded_picture_number/display_picture_number : 解码序列号和显示序列号（Display Order/Decoded Order）</li>
<li>interlaced_frame : 表示该帧为 interlace 码流或者为 progressive 码流</li>
<li>top_field_first : 对于 interlace 码流，表示该它是 top first or bottom first</li>
<li>qscale_table : QP 表</li>
<li>mbskip_table : 跳过宏块表</li>
<li>(*motion_val[2])[2] : 运动矢量表</li>
<li>mb_type : 宏块类型表</li>
<li>dct_coeff : DCT 系数，这个没有提取过</li>
<li>ref_index[2] : 运动估计参考帧列表（貌似 H.264 这种比较新的标准才会涉及到多参考帧）</li>
<li>interlaced_frame : 是否是隔行扫描</li>
</ul>
<h5 id="pict-type"><a href="#pict-type" class="headerlink" title="pict_type"></a>pict_type</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AVPictureType &#123;</span><br><span class="line">    AV_PICTURE_TYPE_NONE = <span class="number">0</span>, <span class="comment">///&lt; Undefined</span></span><br><span class="line">    AV_PICTURE_TYPE_I,     <span class="comment">///&lt; Intra</span></span><br><span class="line">    AV_PICTURE_TYPE_P,     <span class="comment">///&lt; Predicted</span></span><br><span class="line">    AV_PICTURE_TYPE_B,     <span class="comment">///&lt; Bi-dir predicted</span></span><br><span class="line">    AV_PICTURE_TYPE_S,     <span class="comment">///&lt; S(GMC)-VOP MPEG4</span></span><br><span class="line">    AV_PICTURE_TYPE_SI,    <span class="comment">///&lt; Switching Intra</span></span><br><span class="line">    AV_PICTURE_TYPE_SP,    <span class="comment">///&lt; Switching Predicted</span></span><br><span class="line">    AV_PICTURE_TYPE_BI,    <span class="comment">///&lt; BI type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://me.csdn.net/leixiaohua1020" target="_blank" rel="external">雷霄骅 - FFMPEG</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/09/02/learn-java8/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yydcdut.com">yydcdut</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>