<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ijkplayer框架简析 -- avformat_open_input · Android杂文 - yydcdut</title><meta name="description" content="ijkplayer框架简析 -- avformat_open_input - yydcdut"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yydcdut.com/atom.xml" title="Android杂文 - yydcdut"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut/yydcdut.github.io/issues" target="_blank" class="nav-list-link">COMMENT</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ijkplayer框架简析 -- avformat_open_input</h1><div class="post-info">2019年2月23日</div><div class="post-content"><p> <code>avformat_open_input()</code> 方法完成了媒体文件的打开和格式探测的功能</p>
<a id="more"></a>
<h2 id="avformat-open-input"><a href="#avformat-open-input" class="headerlink" title="avformat_open_input"></a>avformat_open_input</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">int avformat_open_input(AVFormatContext **ps, const char *filename,</span><br><span class="line">                        AVInputFormat *fmt, AVDictionary **options)</span><br><span class="line">&#123;</span><br><span class="line">    AVFormatContext *s = *ps;</span><br><span class="line">    int i, ret = 0;</span><br><span class="line">    AVDictionary *tmp = NULL;</span><br><span class="line">    AVDictionary *tmp2 = NULL;</span><br><span class="line">    ID3v2ExtraMeta *id3v2_extra_meta = NULL;</span><br><span class="line"></span><br><span class="line">    if (!s &amp;&amp; !(s = avformat_alloc_context()))</span><br><span class="line">        return AVERROR(ENOMEM);</span><br><span class="line">    if (!s-&gt;av_class) &#123;</span><br><span class="line">        av_log(NULL, AV_LOG_ERROR, "Input context has not been properly allocated by avformat_alloc_context() and is not NULL either\n");</span><br><span class="line">        return AVERROR(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    if (fmt)</span><br><span class="line">        s-&gt;iformat = fmt;</span><br><span class="line"></span><br><span class="line">    if (options)</span><br><span class="line">        av_dict_copy(&amp;tmp, *options, 0);</span><br><span class="line"></span><br><span class="line">    if (s-&gt;pb) // must be before any goto fail</span><br><span class="line">        s-&gt;flags |= AVFMT_FLAG_CUSTOM_IO;</span><br><span class="line"></span><br><span class="line">    if ((ret = av_opt_set_dict(s, &amp;tmp)) &lt; 0)</span><br><span class="line">        goto fail;</span><br><span class="line"></span><br><span class="line">    av_strlcpy(s-&gt;filename, filename ? filename : "", sizeof(s-&gt;filename));</span><br><span class="line">    if ((ret = init_input(s, filename, &amp;tmp)) &lt; 0)</span><br><span class="line">        goto fail;</span><br><span class="line">    s-&gt;probe_score = ret;</span><br><span class="line"></span><br><span class="line">    if (!s-&gt;protocol_whitelist &amp;&amp; s-&gt;pb &amp;&amp; s-&gt;pb-&gt;protocol_whitelist) &#123;</span><br><span class="line">        s-&gt;protocol_whitelist = av_strdup(s-&gt;pb-&gt;protocol_whitelist);</span><br><span class="line">        if (!s-&gt;protocol_whitelist) &#123;</span><br><span class="line">            ret = AVERROR(ENOMEM);</span><br><span class="line">            goto fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!s-&gt;protocol_blacklist &amp;&amp; s-&gt;pb &amp;&amp; s-&gt;pb-&gt;protocol_blacklist) &#123;</span><br><span class="line">        s-&gt;protocol_blacklist = av_strdup(s-&gt;pb-&gt;protocol_blacklist);</span><br><span class="line">        if (!s-&gt;protocol_blacklist) &#123;</span><br><span class="line">            ret = AVERROR(ENOMEM);</span><br><span class="line">            goto fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (s-&gt;format_whitelist &amp;&amp; av_match_list(s-&gt;iformat-&gt;name, s-&gt;format_whitelist, ',') &lt;= 0) &#123;</span><br><span class="line">        av_log(s, AV_LOG_ERROR, "Format not on whitelist \'%s\'\n", s-&gt;format_whitelist);</span><br><span class="line">        ret = AVERROR(EINVAL);</span><br><span class="line">        goto fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    avio_skip(s-&gt;pb, s-&gt;skip_initial_bytes);</span><br><span class="line"></span><br><span class="line">    /* Check filename in case an image number is expected. */</span><br><span class="line">    if (s-&gt;iformat-&gt;flags &amp; AVFMT_NEEDNUMBER) &#123;</span><br><span class="line">        if (!av_filename_number_test(filename)) &#123;</span><br><span class="line">            ret = AVERROR(EINVAL);</span><br><span class="line">            goto fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s-&gt;duration = s-&gt;start_time = AV_NOPTS_VALUE;</span><br><span class="line"></span><br><span class="line">    /* Allocate private data. */</span><br><span class="line">    if (s-&gt;iformat-&gt;priv_data_size &gt; 0) &#123;</span><br><span class="line">        if (!(s-&gt;priv_data = av_mallocz(s-&gt;iformat-&gt;priv_data_size))) &#123;</span><br><span class="line">            ret = AVERROR(ENOMEM);</span><br><span class="line">            goto fail;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s-&gt;iformat-&gt;priv_class) &#123;</span><br><span class="line">            *(const AVClass **) s-&gt;priv_data = s-&gt;iformat-&gt;priv_class;</span><br><span class="line">            av_opt_set_defaults(s-&gt;priv_data);</span><br><span class="line">            if ((ret = av_opt_set_dict(s-&gt;priv_data, &amp;tmp)) &lt; 0)</span><br><span class="line">                goto fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* e.g. AVFMT_NOFILE formats will not have a AVIOContext */</span><br><span class="line">    if (s-&gt;pb)</span><br><span class="line">        ff_id3v2_read_dict(s-&gt;pb, &amp;s-&gt;internal-&gt;id3v2_meta, ID3v2_DEFAULT_MAGIC, &amp;id3v2_extra_meta);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (!(s-&gt;flags&amp;AVFMT_FLAG_PRIV_OPT)) &#123;</span><br><span class="line">        if (s-&gt;iformat-&gt;read_header2) &#123;</span><br><span class="line">            if (options)</span><br><span class="line">                av_dict_copy(&amp;tmp2, *options, 0);</span><br><span class="line"></span><br><span class="line">            if ((ret = s-&gt;iformat-&gt;read_header2(s, &amp;tmp2)) &lt; 0)</span><br><span class="line">                goto fail;</span><br><span class="line">        &#125; else if (s-&gt;iformat-&gt;read_header &amp;&amp; (ret = s-&gt;iformat-&gt;read_header(s)) &lt; 0)</span><br><span class="line">            goto fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!s-&gt;metadata) &#123;</span><br><span class="line">        s-&gt;metadata = s-&gt;internal-&gt;id3v2_meta;</span><br><span class="line">        s-&gt;internal-&gt;id3v2_meta = NULL;</span><br><span class="line">    &#125; else if (s-&gt;internal-&gt;id3v2_meta) &#123;</span><br><span class="line">        int level = AV_LOG_WARNING;</span><br><span class="line">        if (s-&gt;error_recognition &amp; AV_EF_COMPLIANT)</span><br><span class="line">            level = AV_LOG_ERROR;</span><br><span class="line">        av_log(s, level, "Discarding ID3 tags because more suitable tags were found.\n");</span><br><span class="line">        av_dict_free(&amp;s-&gt;internal-&gt;id3v2_meta);</span><br><span class="line">        if (s-&gt;error_recognition &amp; AV_EF_EXPLODE)</span><br><span class="line">            return AVERROR_INVALIDDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (id3v2_extra_meta) &#123;</span><br><span class="line">        if (!strcmp(s-&gt;iformat-&gt;name, "mp3") || !strcmp(s-&gt;iformat-&gt;name, "aac") ||</span><br><span class="line">            !strcmp(s-&gt;iformat-&gt;name, "tta")) &#123;</span><br><span class="line">            if ((ret = ff_id3v2_parse_apic(s, &amp;id3v2_extra_meta)) &lt; 0)</span><br><span class="line">                goto fail;</span><br><span class="line">            if ((ret = ff_id3v2_parse_chapters(s, &amp;id3v2_extra_meta)) &lt; 0)</span><br><span class="line">                goto fail;</span><br><span class="line">        &#125; else</span><br><span class="line">            av_log(s, AV_LOG_DEBUG, "demuxer does not support additional id3 data, skipping\n");</span><br><span class="line">    &#125;</span><br><span class="line">    ff_id3v2_free_extra_meta(&amp;id3v2_extra_meta);</span><br><span class="line"></span><br><span class="line">    if ((ret = avformat_queue_attached_pictures(s)) &lt; 0)</span><br><span class="line">        goto fail;</span><br><span class="line"></span><br><span class="line">    if (!(s-&gt;flags&amp;AVFMT_FLAG_PRIV_OPT) &amp;&amp; s-&gt;pb &amp;&amp; !s-&gt;internal-&gt;data_offset)</span><br><span class="line">        s-&gt;internal-&gt;data_offset = avio_tell(s-&gt;pb);</span><br><span class="line"></span><br><span class="line">    s-&gt;internal-&gt;raw_packet_buffer_remaining_size = RAW_PACKET_BUFFER_SIZE;</span><br><span class="line"></span><br><span class="line">    update_stream_avctx(s);</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; s-&gt;nb_streams; i++)</span><br><span class="line">        s-&gt;streams[i]-&gt;internal-&gt;orig_codec_id = s-&gt;streams[i]-&gt;codecpar-&gt;codec_id;</span><br><span class="line"></span><br><span class="line">    if (options) &#123;</span><br><span class="line">        av_dict_free(options);</span><br><span class="line">        *options = tmp;</span><br><span class="line">        av_dict_free(&amp;tmp2);</span><br><span class="line">    &#125;</span><br><span class="line">    *ps = s;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    ff_id3v2_free_extra_meta(&amp;id3v2_extra_meta);</span><br><span class="line">    av_dict_free(&amp;tmp);</span><br><span class="line">    av_dict_free(&amp;tmp2);</span><br><span class="line">    if (s-&gt;pb &amp;&amp; !(s-&gt;flags &amp; AVFMT_FLAG_CUSTOM_IO))</span><br><span class="line">        avio_closep(&amp;s-&gt;pb);</span><br><span class="line">    avformat_free_context(s);</span><br><span class="line">    *ps = NULL;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options)</code> 第一个参数是封装格式的上下文，第二个参数是文件地址，第三个参数是数据的封装格式，第四个参数是配置？</p>
<p>接下来比较重要的是 <code>init_input(s, filename, &amp;tmp)</code> ，在这里面完成了查找流媒体协议和解复用器的工作</p>
<h2 id="init-input"><a href="#init-input" class="headerlink" title="init_input"></a>init_input</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Open input file and probe the format if necessary. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init_input</span><span class="params">(AVFormatContext *s, <span class="keyword">const</span> <span class="keyword">char</span> *filename,</span><br><span class="line">                      AVDictionary **options)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    AVProbeData pd = &#123; filename, <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> score = AVPROBE_SCORE_RETRY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;pb) &#123;</span><br><span class="line">        s-&gt;flags |= AVFMT_FLAG_CUSTOM_IO;</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;iformat)</span><br><span class="line">            <span class="keyword">return</span> av_probe_input_buffer2(s-&gt;pb, &amp;s-&gt;iformat, filename,</span><br><span class="line">                                         s, <span class="number">0</span>, s-&gt;format_probesize);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE)</span><br><span class="line">            av_log(s, AV_LOG_WARNING, <span class="string">"Custom AVIOContext makes no sense and "</span></span><br><span class="line">                                      <span class="string">"will be ignored with AVFMT_NOFILE format.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((s-&gt;iformat &amp;&amp; s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE) ||</span><br><span class="line">        (!s-&gt;iformat &amp;&amp; (s-&gt;iformat = av_probe_input_format2(&amp;pd, <span class="number">0</span>, &amp;score))))</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = s-&gt;io_open(s, &amp;s-&gt;pb, filename, AVIO_FLAG_READ | s-&gt;avio_flags, options)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;iformat)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> av_probe_input_buffer2(s-&gt;pb, &amp;s-&gt;iformat, filename,</span><br><span class="line">                                 s, <span class="number">0</span>, s-&gt;format_probesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开头的 score 变量是一个判决 AVInputFormat 的分数的门限值，如果最后得到的 AVInputFormat 的分数低于该门限值，就认为没有找到合适的 AVInputFormat。FFmpeg 内部判断封装格式的原理实际上是对每种 AVInputFormat 给出一个分数，满分是 100 分，越有可能正确的 AVInputFormat 给出的分数就越高，最后选择分数最高的 AVInputFormat 作为推测结果，这里一开始的分数是 25 分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> AVPROBE_SCORE_RETRY (AVPROBE_SCORE_MAX/<span class="number">4</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> AVPROBE_SCORE_MAX       <span class="number">100</span> <span class="comment">///&lt; maximum score</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>当使用了自定义的 AVIOContext 的时候（AVFormatContext 中的 AVIOContext 不为空，即 s-&gt;pb!=NULL），如果指定了 AVInputFormat 就直接返回，如果没有指定就调用 av_probe_input_buffer2() 推测 AVInputFormat。这一情况出现的不算很多，但是当我们从内存中读取数据的时候（需要初始化自定义的 AVIOContext），就会执行这一步骤</li>
<li>在更一般的情况下，如果已经指定了 AVInputFormat，就直接返回；如果没有指定 AVInputFormat，就调用 av_probe_input_format(NULL,…) 根据文件路径判断文件格式。这里特意把 av_probe_input_format() 的第 1 个参数写成 “NULL”，是为了强调这个时候实际上并没有给函数提供输入数据，此时仅仅通过文件路径推测 AVInputFormat</li>
<li>如果发现通过文件路径判断不出来文件格式，那么就需要打开文件探测文件格式了，这个时候会首先调用 avio_open2() 打开文件，然后调用 av_probe_input_buffer2() 推测 AVInputFormat</li>
</ul>
<h3 id="av-probe-input-buffer2"><a href="#av-probe-input-buffer2" class="headerlink" title="av_probe_input_buffer2"></a>av_probe_input_buffer2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">int av_probe_input_buffer2(AVIOContext *pb, AVInputFormat **fmt,</span><br><span class="line">                          const char *filename, void *logctx,</span><br><span class="line">                          unsigned int offset, unsigned int max_probe_size)</span><br><span class="line">&#123;</span><br><span class="line">    AVProbeData pd = &#123; filename ? filename : "" &#125;;</span><br><span class="line">    uint8_t *buf = NULL;</span><br><span class="line">    int ret = 0, probe_size, buf_offset = 0;</span><br><span class="line">    int score = 0;</span><br><span class="line">    int ret2;</span><br><span class="line"></span><br><span class="line">    if (!max_probe_size)</span><br><span class="line">        max_probe_size = PROBE_BUF_MAX;</span><br><span class="line">    else if (max_probe_size &lt; PROBE_BUF_MIN) &#123;</span><br><span class="line">        av_log(logctx, AV_LOG_ERROR,</span><br><span class="line">               "Specified probe size value %u cannot be &lt; %u\n", max_probe_size, PROBE_BUF_MIN);</span><br><span class="line">        return AVERROR(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (offset &gt;= max_probe_size)</span><br><span class="line">        return AVERROR(EINVAL);</span><br><span class="line"></span><br><span class="line">    if (pb-&gt;av_class) &#123;</span><br><span class="line">        uint8_t *mime_type_opt = NULL;</span><br><span class="line">        char *semi;</span><br><span class="line">        av_opt_get(pb, "mime_type", AV_OPT_SEARCH_CHILDREN, &amp;mime_type_opt);</span><br><span class="line">        pd.mime_type = (const char *)mime_type_opt;</span><br><span class="line">        semi = pd.mime_type ? strchr(pd.mime_type, ';') : NULL;</span><br><span class="line">        if (semi) &#123;</span><br><span class="line">            *semi = '\0';</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#if 0</span><br><span class="line">    if (!*fmt &amp;&amp; pb-&gt;av_class &amp;&amp; av_opt_get(pb, "mime_type", AV_OPT_SEARCH_CHILDREN, &amp;mime_type) &gt;= 0 &amp;&amp; mime_type) &#123;</span><br><span class="line">        if (!av_strcasecmp(mime_type, "audio/aacp")) &#123;</span><br><span class="line">            *fmt = av_find_input_format("aac");</span><br><span class="line">        &#125;</span><br><span class="line">        av_freep(&amp;mime_type);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    for (probe_size = PROBE_BUF_MIN; probe_size &lt;= max_probe_size &amp;&amp; !*fmt;</span><br><span class="line">         probe_size = FFMIN(probe_size &lt;&lt; 1,</span><br><span class="line">                            FFMAX(max_probe_size, probe_size + 1))) &#123;</span><br><span class="line">        score = probe_size &lt; max_probe_size ? AVPROBE_SCORE_RETRY : 0;</span><br><span class="line"></span><br><span class="line">        /* Read probe data. */</span><br><span class="line">        if ((ret = av_reallocp(&amp;buf, probe_size + AVPROBE_PADDING_SIZE)) &lt; 0)</span><br><span class="line">            goto fail;</span><br><span class="line">        if ((ret = avio_read(pb, buf + buf_offset,</span><br><span class="line">                             probe_size - buf_offset)) &lt; 0) &#123;</span><br><span class="line">            /* Fail if error was not end of file, otherwise, lower score. */</span><br><span class="line">            if (ret != AVERROR_EOF)</span><br><span class="line">                goto fail;</span><br><span class="line"></span><br><span class="line">            score = 0;</span><br><span class="line">            ret   = 0;          /* error was end of file, nothing read */</span><br><span class="line">        &#125;</span><br><span class="line">        buf_offset += ret;</span><br><span class="line">        if (buf_offset &lt; offset)</span><br><span class="line">            continue;</span><br><span class="line">        pd.buf_size = buf_offset - offset;</span><br><span class="line">        pd.buf = &amp;buf[offset];</span><br><span class="line"></span><br><span class="line">        memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);</span><br><span class="line"></span><br><span class="line">        /* Guess file format. */</span><br><span class="line">        *fmt = av_probe_input_format2(&amp;pd, 1, &amp;score);</span><br><span class="line">        if (*fmt) &#123;</span><br><span class="line">            /* This can only be true in the last iteration. */</span><br><span class="line">            if (score &lt;= AVPROBE_SCORE_RETRY) &#123;</span><br><span class="line">                av_log(logctx, AV_LOG_WARNING,</span><br><span class="line">                       "Format %s detected only with low score of %d, "</span><br><span class="line">                       "misdetection possible!\n", (*fmt)-&gt;name, score);</span><br><span class="line">            &#125; else</span><br><span class="line">                av_log(logctx, AV_LOG_DEBUG,</span><br><span class="line">                       "Format %s probed with size=%d and score=%d\n",</span><br><span class="line">                       (*fmt)-&gt;name, probe_size, score);</span><br><span class="line">#if 0</span><br><span class="line">            FILE *f = fopen("probestat.tmp", "ab");</span><br><span class="line">            fprintf(f, "probe_size:%d format:%s score:%d filename:%s\n", probe_size, (*fmt)-&gt;name, score, filename);</span><br><span class="line">            fclose(f);</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!*fmt)</span><br><span class="line">        ret = AVERROR_INVALIDDATA;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    /* Rewind. Reuse probe buffer to avoid seeking. */</span><br><span class="line">    ret2 = ffio_rewind_with_probe_data(pb, &amp;buf, buf_offset);</span><br><span class="line">    if (ret &gt;= 0)</span><br><span class="line">        ret = ret2;</span><br><span class="line"></span><br><span class="line">    av_freep(&amp;pd.mime_type);</span><br><span class="line">    return ret &lt; 0 ? ret : score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AVIOContext *pb</code> 用于读取数据的 AVIOContext，<code>AVInputFormat **fmt</code> 输出推测出来的 AVInputFormat，<code>unsigned int offset</code> 开始推测 AVInputFormat 的偏移量，<code>unsigned int max_probe_size</code> 用于推测格式的媒体数据的最大值</p>
<p>首先需要确定用于推测格式的媒体数据的最大值 max_probe_size。max_probe_size 默认为 PROBE_BUF_MAX（PROBE_BUF_MAX 取值为 1 &lt;&lt; 20，即 1048576Byte，大约 1MB）</p>
<p>在确定了 max_probe_size 之后，函数就会进入到一个循环中（因为并不是一次性读取 max_probe_size 字节的媒体数据），调用 avio_read() 读取数据并且使用 <code>av_probe_input_format2()</code> 去推测文件格式：</p>
<h4 id="av-probe-input-format2"><a href="#av-probe-input-format2" class="headerlink" title="av_probe_input_format2"></a>av_probe_input_format2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVInputFormat *<span class="title">av_probe_input_format2</span><span class="params">(AVProbeData *pd, <span class="keyword">int</span> is_opened, <span class="keyword">int</span> *score_max)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score_ret;</span><br><span class="line">    AVInputFormat *fmt = av_probe_input_format3(pd, is_opened, &amp;score_ret);</span><br><span class="line">    <span class="keyword">if</span> (score_ret &gt; *score_max) &#123;</span><br><span class="line">        *score_max = score_ret;</span><br><span class="line">        <span class="keyword">return</span> fmt;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>av_probe_input_format3()</code> 给出了一个分数 <code>score_ret</code>，然后进行比对：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">AVInputFormat *av_probe_input_format3(AVProbeData *pd, int is_opened,</span><br><span class="line">                                      int *score_ret)</span><br><span class="line">&#123;</span><br><span class="line">    AVProbeData lpd = *pd;</span><br><span class="line">    AVInputFormat *fmt1 = NULL, *fmt;</span><br><span class="line">    int score, score_max = 0;</span><br><span class="line">    const static uint8_t zerobuffer[AVPROBE_PADDING_SIZE];</span><br><span class="line">    enum nodat &#123;</span><br><span class="line">        NO_ID3,</span><br><span class="line">        ID3_ALMOST_GREATER_PROBE,</span><br><span class="line">        ID3_GREATER_PROBE,</span><br><span class="line">        ID3_GREATER_MAX_PROBE,</span><br><span class="line">    &#125; nodat = NO_ID3;</span><br><span class="line"></span><br><span class="line">    if (!lpd.buf)</span><br><span class="line">        lpd.buf = (unsigned char *) zerobuffer;</span><br><span class="line"></span><br><span class="line">    if (lpd.buf_size &gt; 10 &amp;&amp; ff_id3v2_match(lpd.buf, ID3v2_DEFAULT_MAGIC)) &#123;</span><br><span class="line">        int id3len = ff_id3v2_tag_len(lpd.buf);</span><br><span class="line">        if (lpd.buf_size &gt; id3len + 16) &#123;</span><br><span class="line">            if (lpd.buf_size &lt; 2LL*id3len + 16)</span><br><span class="line">                nodat = ID3_ALMOST_GREATER_PROBE;</span><br><span class="line">            lpd.buf      += id3len;</span><br><span class="line">            lpd.buf_size -= id3len;</span><br><span class="line">        &#125; else if (id3len &gt;= PROBE_BUF_MAX) &#123;</span><br><span class="line">            nodat = ID3_GREATER_MAX_PROBE;</span><br><span class="line">        &#125; else</span><br><span class="line">            nodat = ID3_GREATER_PROBE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt = NULL;</span><br><span class="line">    while ((fmt1 = av_iformat_next(fmt1))) &#123;</span><br><span class="line">        if (!is_opened == !(fmt1-&gt;flags &amp; AVFMT_NOFILE) &amp;&amp; strcmp(fmt1-&gt;name, "image2"))</span><br><span class="line">            continue;</span><br><span class="line">        score = 0;</span><br><span class="line">        if (fmt1-&gt;read_probe) &#123;</span><br><span class="line">            score = fmt1-&gt;read_probe(&amp;lpd);</span><br><span class="line">            if (score)</span><br><span class="line">                av_log(NULL, AV_LOG_TRACE, "Probing %s score:%d size:%d\n", fmt1-&gt;name, score, lpd.buf_size);</span><br><span class="line">            if (fmt1-&gt;extensions &amp;&amp; av_match_ext(lpd.filename, fmt1-&gt;extensions)) &#123;</span><br><span class="line">                switch (nodat) &#123;</span><br><span class="line">                case NO_ID3:</span><br><span class="line">                    score = FFMAX(score, 1);</span><br><span class="line">                    break;</span><br><span class="line">                case ID3_GREATER_PROBE:</span><br><span class="line">                case ID3_ALMOST_GREATER_PROBE:</span><br><span class="line">                    score = FFMAX(score, AVPROBE_SCORE_EXTENSION / 2 - 1);</span><br><span class="line">                    break;</span><br><span class="line">                case ID3_GREATER_MAX_PROBE:</span><br><span class="line">                    score = FFMAX(score, AVPROBE_SCORE_EXTENSION);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (fmt1-&gt;extensions) &#123;</span><br><span class="line">            if (av_match_ext(lpd.filename, fmt1-&gt;extensions))</span><br><span class="line">                score = AVPROBE_SCORE_EXTENSION;</span><br><span class="line">        &#125;</span><br><span class="line">        if (av_match_name(lpd.mime_type, fmt1-&gt;mime_type)) &#123;</span><br><span class="line">            if (AVPROBE_SCORE_MIME &gt; score) &#123;</span><br><span class="line">                av_log(NULL, AV_LOG_DEBUG, "Probing %s score:%d increased to %d due to MIME type\n", fmt1-&gt;name, score, AVPROBE_SCORE_MIME);</span><br><span class="line">                score = AVPROBE_SCORE_MIME;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (score &gt; score_max) &#123;</span><br><span class="line">            score_max = score;</span><br><span class="line">            fmt       = fmt1;</span><br><span class="line">        &#125; else if (score == score_max)</span><br><span class="line">            fmt = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nodat == ID3_GREATER_PROBE)</span><br><span class="line">        score_max = FFMIN(AVPROBE_SCORE_EXTENSION / 2 - 1, score_max);</span><br><span class="line">    *score_ret = score_max;</span><br><span class="line"></span><br><span class="line">    return fmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>while ((fmt1 = av_iformat_next(fmt1)))</code> 循环遍历 AVInputFormat，该方法中的 <code>first_iformat</code> 链表中的头节点，并根据以下规则确定 AVInputFormat 和输入媒体数据的匹配分数</p>
<ul>
<li>如果 AVInputFormat 中包含 read_probe()，就调用 read_probe() 函数获取匹配分数（这一方法如果结果匹配的话，一般会获得 AVPROBE_SCORE_MAX 的分值，即 100 分）。如果不包含该函数，就使用 av_match_ext() 函数比较输入媒体的扩展名和 AVInputFormat 的扩展名是否匹配，如果匹配的话，设定匹配分数为 AVPROBE_SCORE_EXTENSION（即 50 分）</li>
<li>使用 av_match_name() 比较输入媒体的 mime_type 和 AVInputFormat 的 mime_type，如果匹配的话，设定匹配分数为 AVPROBE_SCORE_MIME（即 75 分）</li>
<li>如果该 AVInputFormat 的匹配分数大于此前的最大匹配分数，则记录当前的匹配分数为最大匹配分数，并且记录当前的 AVInputFormat 为最佳匹配的 AVInputFormat</li>
</ul>
<h4 id="read-probe"><a href="#read-probe" class="headerlink" title="read_probe"></a>read_probe</h4><p><code>read_probe()</code> 是用于获得匹配函数的函数指针，不同的封装格式包含不同的实现函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AVInputFormat ff_mov_demuxer = &#123;</span><br><span class="line">    .name           = <span class="string">"mov,mp4,m4a,3gp,3g2,mj2"</span>,</span><br><span class="line">    .long_name      = NULL_IF_CONFIG_SMALL(<span class="string">"QuickTime / MOV"</span>),</span><br><span class="line">    .priv_class     = &amp;mov_class,</span><br><span class="line">    .priv_data_size = <span class="keyword">sizeof</span>(MOVContext),</span><br><span class="line">    .extensions     = <span class="string">"mov,mp4,m4a,3gp,3g2,mj2"</span>,</span><br><span class="line">    .read_probe     = mov_probe,</span><br><span class="line">    .read_header    = mov_read_header,</span><br><span class="line">    .read_packet    = mov_read_packet,</span><br><span class="line">    .read_close     = mov_read_close,</span><br><span class="line">    .read_seek      = mov_read_seek,</span><br><span class="line">    .flags          = AVFMT_NO_BYTE_SEEK,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>read_probe()</code> 函数对应的是 <code>mov_probe()</code> 函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">static int mov_probe(AVProbeData *p)</span><br><span class="line">&#123;</span><br><span class="line">    int64_t offset;</span><br><span class="line">    uint32_t tag;</span><br><span class="line">    int score = 0;</span><br><span class="line">    int moov_offset = -1;</span><br><span class="line"></span><br><span class="line">    /* check file header */</span><br><span class="line">    offset = 0;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        /* ignore invalid offset */</span><br><span class="line">        if ((offset + 8) &gt; (unsigned int)p-&gt;buf_size)</span><br><span class="line">            break;</span><br><span class="line">        tag = AV_RL32(p-&gt;buf + offset + 4);</span><br><span class="line">        switch(tag) &#123;</span><br><span class="line">        /* check for obvious tags */</span><br><span class="line">        case MKTAG('m','o','o','v'):</span><br><span class="line">            moov_offset = offset + 4;</span><br><span class="line">        case MKTAG('m','d','a','t'):</span><br><span class="line">        case MKTAG('p','n','o','t'): /* detect movs with preview pics like ew.mov and april.mov */</span><br><span class="line">        case MKTAG('u','d','t','a'): /* Packet Video PVAuthor adds this and a lot of more junk */</span><br><span class="line">        case MKTAG('f','t','y','p'):</span><br><span class="line">            if (AV_RB32(p-&gt;buf+offset) &lt; 8 &amp;&amp;</span><br><span class="line">                (AV_RB32(p-&gt;buf+offset) != 1 ||</span><br><span class="line">                 offset + 12 &gt; (unsigned int)p-&gt;buf_size ||</span><br><span class="line">                 AV_RB64(p-&gt;buf+offset + 8) == 0)) &#123;</span><br><span class="line">                score = FFMAX(score, AVPROBE_SCORE_EXTENSION);</span><br><span class="line">            &#125; else if (tag == MKTAG('f','t','y','p') &amp;&amp;</span><br><span class="line">                       (   AV_RL32(p-&gt;buf + offset + 8) == MKTAG('j','p','2',' ')</span><br><span class="line">                        || AV_RL32(p-&gt;buf + offset + 8) == MKTAG('j','p','x',' ')</span><br><span class="line">                    )) &#123;</span><br><span class="line">                score = FFMAX(score, 5);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                score = AVPROBE_SCORE_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            offset = FFMAX(4, AV_RB32(p-&gt;buf+offset)) + offset;</span><br><span class="line">            break;</span><br><span class="line">        /* those are more common words, so rate then a bit less */</span><br><span class="line">        case MKTAG('e','d','i','w'): /* xdcam files have reverted first tags */</span><br><span class="line">        case MKTAG('w','i','d','e'):</span><br><span class="line">        case MKTAG('f','r','e','e'):</span><br><span class="line">        case MKTAG('j','u','n','k'):</span><br><span class="line">        case MKTAG('p','i','c','t'):</span><br><span class="line">            score  = FFMAX(score, AVPROBE_SCORE_MAX - 5);</span><br><span class="line">            offset = FFMAX(4, AV_RB32(p-&gt;buf+offset)) + offset;</span><br><span class="line">            break;</span><br><span class="line">        case MKTAG(0x82,0x82,0x7f,0x7d):</span><br><span class="line">        case MKTAG('s','k','i','p'):</span><br><span class="line">        case MKTAG('u','u','i','d'):</span><br><span class="line">        case MKTAG('p','r','f','l'):</span><br><span class="line">            /* if we only find those cause probedata is too small at least rate them */</span><br><span class="line">            score  = FFMAX(score, AVPROBE_SCORE_EXTENSION);</span><br><span class="line">            offset = FFMAX(4, AV_RB32(p-&gt;buf+offset)) + offset;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            offset = FFMAX(4, AV_RB32(p-&gt;buf+offset)) + offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(score &gt; AVPROBE_SCORE_MAX - 50 &amp;&amp; moov_offset != -1) &#123;</span><br><span class="line">        /* moov atom in the header - we should make sure that this is not a</span><br><span class="line">         * MOV-packed MPEG-PS */</span><br><span class="line">        offset = moov_offset;</span><br><span class="line"></span><br><span class="line">        while(offset &lt; (p-&gt;buf_size - 16))&#123; /* Sufficient space */</span><br><span class="line">               /* We found an actual hdlr atom */</span><br><span class="line">            if(AV_RL32(p-&gt;buf + offset     ) == MKTAG('h','d','l','r') &amp;&amp;</span><br><span class="line">               AV_RL32(p-&gt;buf + offset +  8) == MKTAG('m','h','l','r') &amp;&amp;</span><br><span class="line">               AV_RL32(p-&gt;buf + offset + 12) == MKTAG('M','P','E','G'))&#123;</span><br><span class="line">                av_log(NULL, AV_LOG_WARNING, "Found media data tag MPEG indicating this is a MOV-packed MPEG-PS.\n");</span><br><span class="line">                /* We found a media handler reference atom describing an</span><br><span class="line">                 * MPEG-PS-in-MOV, return a</span><br><span class="line">                 * low score to force expanding the probe window until</span><br><span class="line">                 * mpegps_probe finds what it needs */</span><br><span class="line">                return 5;</span><br><span class="line">            &#125;else</span><br><span class="line">                /* Keep looking */</span><br><span class="line">                offset+=2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="av-match-name"><a href="#av-match-name" class="headerlink" title="av_match_name"></a>av_match_name</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_match_name</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *names)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">int</span> len, namelen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!name || !names)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    namelen = <span class="built_in">strlen</span>(name);</span><br><span class="line">    <span class="keyword">while</span> (*names) &#123;</span><br><span class="line">        <span class="keyword">int</span> negate = <span class="string">'-'</span> == *names;</span><br><span class="line">        p = <span class="built_in">strchr</span>(names, <span class="string">','</span>);</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">            p = names + <span class="built_in">strlen</span>(names);</span><br><span class="line">        names += negate;</span><br><span class="line">        len = FFMAX(p - names, namelen);</span><br><span class="line">        <span class="keyword">if</span> (!av_strncasecmp(name, names, len) || !<span class="built_in">strncmp</span>(<span class="string">"ALL"</span>, names, FFMAX(<span class="number">3</span>, p - names)))</span><br><span class="line">            <span class="keyword">return</span> !negate;</span><br><span class="line">        names = p + (*p == <span class="string">','</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于比较两个格式的名称<em>(不区分大小写)</em></p>
<h4 id="av-match-ext"><a href="#av-match-ext" class="headerlink" title="av_match_ext"></a>av_match_ext</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_match_ext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *extensions)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!filename)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ext = <span class="built_in">strrchr</span>(filename, <span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">if</span> (ext)</span><br><span class="line">        <span class="keyword">return</span> av_match_name(ext + <span class="number">1</span>, extensions);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于比较文件的后缀</p>
<h3 id="io-open"><a href="#io-open" class="headerlink" title="io_open"></a>io_open</h3><p><code>init_input</code> 中调用了 <code>s-&gt;io_open</code> ，实际上调用的就是 <code>io_open_default</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">avformat_get_context_defaults</span><span class="params">(AVFormatContext *s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(AVFormatContext));</span><br><span class="line"></span><br><span class="line">    s-&gt;av_class = &amp;av_format_context_class;</span><br><span class="line"></span><br><span class="line">    s-&gt;io_open  = io_open_default;</span><br><span class="line">    s-&gt;io_close = io_close_default;</span><br><span class="line"></span><br><span class="line">    av_opt_set_defaults(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>io_open_default()</code> 中会调用 <code>ffio_open_whitelist()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffio_open_whitelist</span><span class="params">(AVIOContext **s, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flags,</span><br><span class="line">                         <span class="keyword">const</span> AVIOInterruptCB *int_cb, AVDictionary **options,</span><br><span class="line">                         <span class="keyword">const</span> <span class="keyword">char</span> *whitelist, <span class="keyword">const</span> <span class="keyword">char</span> *blacklist</span><br><span class="line">                        )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    URLContext *h;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    err = ffurl_open_whitelist(&amp;h, filename, flags, int_cb, options, whitelist, blacklist, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    err = ffio_fdopen(s, h);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ffurl_close(h);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着跟下去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffurl_open_whitelist</span><span class="params">(URLContext **puc, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flags,</span><br><span class="line">                         <span class="keyword">const</span> AVIOInterruptCB *int_cb, AVDictionary **options,</span><br><span class="line">                         <span class="keyword">const</span> <span class="keyword">char</span> *whitelist, <span class="keyword">const</span> <span class="keyword">char</span>* blacklist,</span><br><span class="line">                         URLContext *parent)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    AVDictionary *tmp_opts = <span class="literal">NULL</span>;</span><br><span class="line">    AVDictionaryEntry *e;</span><br><span class="line">    <span class="keyword">int</span> ret = ffurl_alloc(puc, filename, flags, int_cb);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (parent)</span><br><span class="line">        av_opt_copy(*puc, parent);</span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp;</span><br><span class="line">        (ret = av_opt_set_dict(*puc, options)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; (*puc)-&gt;prot-&gt;priv_data_class &amp;&amp;</span><br><span class="line">        (ret = av_opt_set_dict((*puc)-&gt;priv_data, options)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!options)</span><br><span class="line">        options = &amp;tmp_opts;</span><br><span class="line"></span><br><span class="line">    av_assert0(!whitelist ||</span><br><span class="line">               !(e=av_dict_get(*options, <span class="string">"protocol_whitelist"</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) ||</span><br><span class="line">               !<span class="built_in">strcmp</span>(whitelist, e-&gt;value));</span><br><span class="line">    av_assert0(!blacklist ||</span><br><span class="line">               !(e=av_dict_get(*options, <span class="string">"protocol_blacklist"</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) ||</span><br><span class="line">               !<span class="built_in">strcmp</span>(blacklist, e-&gt;value));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = av_dict_set(options, <span class="string">"protocol_whitelist"</span>, whitelist, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = av_dict_set(options, <span class="string">"protocol_blacklist"</span>, blacklist, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = av_opt_set_dict(*puc, options)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    ret = ffurl_connect(*puc, options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">    ffurl_close(*puc);</span><br><span class="line">    *puc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>ffurl_alloc()</code> 中调用了 <code>url_find_protocol()</code> 方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffurl_alloc</span><span class="params">(URLContext **puc, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flags,</span><br><span class="line">                <span class="keyword">const</span> AVIOInterruptCB *int_cb)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> URLProtocol *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    p = url_find_protocol(filename);</span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">       <span class="keyword">return</span> url_alloc_for_protocol(puc, p, filename, flags, int_cb);</span><br><span class="line"></span><br><span class="line">    *puc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (av_strstart(filename, <span class="string">"https:"</span>, <span class="literal">NULL</span>))</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">"https protocol not found, recompile FFmpeg with "</span></span><br><span class="line">                                     <span class="string">"openssl, gnutls "</span></span><br><span class="line">                                     <span class="string">"or securetransport enabled.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> AVERROR_PROTOCOL_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="url-find-protocol"><a href="#url-find-protocol" class="headerlink" title="url_find_protocol"></a>url_find_protocol</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> URL_SCHEME_CHARS                        \</span><br><span class="line">    <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>                \</span><br><span class="line">    <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>                \</span><br><span class="line">    <span class="string">"0123456789+-."</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> URLProtocol *<span class="title">url_find_protocol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> URLProtocol **protocols;</span><br><span class="line">    <span class="keyword">char</span> proto_str[<span class="number">128</span>], proto_nested[<span class="number">128</span>], *ptr;</span><br><span class="line">    <span class="keyword">size_t</span> proto_len = <span class="built_in">strspn</span>(filename, URL_SCHEME_CHARS);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filename[proto_len] != <span class="string">':'</span> &amp;&amp;</span><br><span class="line">        (<span class="built_in">strncmp</span>(filename, <span class="string">"subfile,"</span>, <span class="number">8</span>) || !<span class="built_in">strchr</span>(filename + proto_len + <span class="number">1</span>, <span class="string">':'</span>)) ||</span><br><span class="line">        is_dos_path(filename))</span><br><span class="line">        <span class="built_in">strcpy</span>(proto_str, <span class="string">"file"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        av_strlcpy(proto_str, filename,</span><br><span class="line">                   FFMIN(proto_len + <span class="number">1</span>, <span class="keyword">sizeof</span>(proto_str)));</span><br><span class="line"></span><br><span class="line">    av_strlcpy(proto_nested, proto_str, <span class="keyword">sizeof</span>(proto_nested));</span><br><span class="line">    <span class="keyword">if</span> ((ptr = <span class="built_in">strchr</span>(proto_nested, <span class="string">'+'</span>)))</span><br><span class="line">        *ptr = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    protocols = ffurl_get_protocols(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!protocols)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; protocols[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> URLProtocol *up = protocols[i];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(proto_str, up-&gt;name)) &#123;</span><br><span class="line">            av_freep(&amp;protocols);</span><br><span class="line">            <span class="keyword">return</span> up;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (up-&gt;flags &amp; URL_PROTOCOL_FLAG_NESTED_SCHEME &amp;&amp;</span><br><span class="line">            !<span class="built_in">strcmp</span>(proto_nested, up-&gt;name)) &#123;</span><br><span class="line">            av_freep(&amp;protocols);</span><br><span class="line">            <span class="keyword">return</span> up;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    av_freep(&amp;protocols);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ffurl_get_protocols 可以得到当前编译的 FFmpeg 支持的所有流媒体协议，通过 url 的 scheme 和 protocol-&gt;name 相比较，得到正确的 protocol</p>
<h4 id="URLProtocol"><a href="#URLProtocol" class="headerlink" title="URLProtocol"></a>URLProtocol</h4><p><code>url_find_protocol()</code> 方法返回一个 <code>URLProtocol</code> 变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> URLProtocol &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span>     (*url_open)( URLContext *h, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * This callback is to be used by protocols which open further nested</span><br><span class="line">     * protocols. options are then to be passed to ffurl_open()/ffurl_connect()</span><br><span class="line">     * for those nested protocols.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">int</span>     (*url_open2)(URLContext *h, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags, AVDictionary **options);</span><br><span class="line">    <span class="keyword">int</span>     (*url_accept)(URLContext *s, URLContext **c);</span><br><span class="line">    <span class="keyword">int</span>     (*url_handshake)(URLContext *c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Read data from the protocol.</span><br><span class="line">     * If data is immediately available (even less than size), EOF is</span><br><span class="line">     * reached or an error occurs (including EINTR), return immediately.</span><br><span class="line">     * Otherwise:</span><br><span class="line">     * In non-blocking mode, return AVERROR(EAGAIN) immediately.</span><br><span class="line">     * In blocking mode, wait for data/EOF/error with a short timeout (0.1s),</span><br><span class="line">     * and return AVERROR(EAGAIN) on timeout.</span><br><span class="line">     * Checking interrupt_callback, looping on EINTR and EAGAIN and until</span><br><span class="line">     * enough data has been read is left to the calling function; see</span><br><span class="line">     * retry_transfer_wrapper in avio.c.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">int</span>     (*url_read)( URLContext *h, <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> size);</span><br><span class="line">    <span class="keyword">int</span>     (*url_write)(URLContext *h, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> size);</span><br><span class="line">    <span class="keyword">int64_t</span> (*url_seek)( URLContext *h, <span class="keyword">int64_t</span> pos, <span class="keyword">int</span> whence);</span><br><span class="line">    <span class="keyword">int</span>     (*url_close)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_read_pause)(URLContext *h, <span class="keyword">int</span> pause);</span><br><span class="line">    <span class="keyword">int64_t</span> (*url_read_seek)(URLContext *h, <span class="keyword">int</span> stream_index,</span><br><span class="line">                             <span class="keyword">int64_t</span> timestamp, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> (*url_get_file_handle)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_get_multi_file_handle)(URLContext *h, <span class="keyword">int</span> **handles,</span><br><span class="line">                                     <span class="keyword">int</span> *numhandles);</span><br><span class="line">    <span class="keyword">int</span> (*url_get_short_seek)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_shutdown)(URLContext *h, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> priv_data_size;</span><br><span class="line">    <span class="keyword">const</span> AVClass *priv_data_class;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> (*url_check)(URLContext *h, <span class="keyword">int</span> mask);</span><br><span class="line">    <span class="keyword">int</span> (*url_open_dir)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_read_dir)(URLContext *h, AVIODirEntry **next);</span><br><span class="line">    <span class="keyword">int</span> (*url_close_dir)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_delete)(URLContext *h);</span><br><span class="line">    <span class="keyword">int</span> (*url_move)(URLContext *h_src, URLContext *h_dst);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *default_whitelist;</span><br><span class="line">&#125; URLProtocol;</span><br></pre></td></tr></table></figure>
<p><code>URLProtocol</code> 功能就是完成各种输入协议的读写等操作，ijkplayer 和 ffmpeg 支持的协议也有很多：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_async_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_bluray_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_cache_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_concat_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_crypto_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_data_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_ffrtmpcrypt_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_ffrtmphttp_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_file_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_ftp_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_gopher_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_hls_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_http_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_httpproxy_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_https_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_icecast_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_ijkhttphook_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_ijklongurl_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_ijkmediadatasource_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_ijksegment_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_ijktcphook_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_ijkio_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_mmsh_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_mmst_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_md5_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_pipe_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_prompeg_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_rtmp_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_rtmpe_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_rtmps_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_rtmpt_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_rtmpte_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_rtmpts_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_rtp_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_sctp_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_srtp_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_subfile_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_tee_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_tcp_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_tls_gnutls_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_tls_schannel_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_tls_securetransport_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_tls_openssl_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_udp_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_udplite_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_unix_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_librtmp_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_librtmpe_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_librtmps_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_librtmpt_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_librtmpte_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_libssh_protocol;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> URLProtocol ff_libsmbclient_protocol;</span><br></pre></td></tr></table></figure>
<h3 id="read-header"><a href="#read-header" class="headerlink" title="read_header"></a>read_header</h3><p><code>read_header()</code> 也是用于获得匹配函数的函数指针，不同的封装格式包含不同的实现函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AVInputFormat ff_mov_demuxer = &#123;</span><br><span class="line">    .name           = <span class="string">"mov,mp4,m4a,3gp,3g2,mj2"</span>,</span><br><span class="line">    .long_name      = NULL_IF_CONFIG_SMALL(<span class="string">"QuickTime / MOV"</span>),</span><br><span class="line">    .priv_class     = &amp;mov_class,</span><br><span class="line">    .priv_data_size = <span class="keyword">sizeof</span>(MOVContext),</span><br><span class="line">    .extensions     = <span class="string">"mov,mp4,m4a,3gp,3g2,mj2"</span>,</span><br><span class="line">    .read_probe     = mov_probe,</span><br><span class="line">    .read_header    = mov_read_header,</span><br><span class="line">    .read_packet    = mov_read_packet,</span><br><span class="line">    .read_close     = mov_read_close,</span><br><span class="line">    .read_seek      = mov_read_seek,</span><br><span class="line">    .flags          = AVFMT_NO_BYTE_SEEK,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>read_header()</code> 指向了 <code>mov_read_header()</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mov_read_header</span><span class="params">(AVFormatContext *s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    MOVContext *mov = s-&gt;priv_data;</span><br><span class="line">    AVIOContext *pb = s-&gt;pb;</span><br><span class="line">    <span class="keyword">int</span> j, err;</span><br><span class="line">    MOVAtom atom = &#123; AV_RL32(<span class="string">"root"</span>) &#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mov-&gt;decryption_key_len != <span class="number">0</span> &amp;&amp; mov-&gt;decryption_key_len != AES_CTR_KEY_SIZE) &#123;</span><br><span class="line">        av_log(s, AV_LOG_ERROR, <span class="string">"Invalid decryption key len %d expected %d\n"</span>,</span><br><span class="line">            mov-&gt;decryption_key_len, AES_CTR_KEY_SIZE);</span><br><span class="line">        <span class="keyword">return</span> AVERROR(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mov-&gt;fc = s;</span><br><span class="line">    mov-&gt;trak_index = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* .mov and .mp4 aren't streamable anyway (only progressive download if moov is before mdat) */</span></span><br><span class="line">    <span class="keyword">if</span> (pb-&gt;seekable &amp; AVIO_SEEKABLE_NORMAL)</span><br><span class="line">        atom.size = avio_size(pb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        atom.size = INT64_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check MOV header */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mov-&gt;moov_retry)</span><br><span class="line">        avio_seek(pb, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">if</span> ((err = mov_read_default(mov, pb, atom)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(s, AV_LOG_ERROR, <span class="string">"error reading header\n"</span>);</span><br><span class="line">        mov_read_close(s);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((pb-&gt;seekable &amp; AVIO_SEEKABLE_NORMAL) &amp;&amp; !mov-&gt;found_moov &amp;&amp; !mov-&gt;moov_retry++);</span><br><span class="line">    <span class="keyword">if</span> (!mov-&gt;found_moov) &#123;</span><br><span class="line">        av_log(s, AV_LOG_ERROR, <span class="string">"moov atom not found\n"</span>);</span><br><span class="line">        mov_read_close(s);</span><br><span class="line">        <span class="keyword">return</span> AVERROR_INVALIDDATA;</span><br><span class="line">    &#125;</span><br><span class="line">    av_log(mov-&gt;fc, AV_LOG_TRACE, <span class="string">"on_parse_exit_offset=%"</span>PRId64<span class="string">"\n"</span>, avio_tell(pb));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pb-&gt;seekable &amp; AVIO_SEEKABLE_NORMAL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mov-&gt;nb_chapter_tracks &gt; <span class="number">0</span> &amp;&amp; !mov-&gt;ignore_chapters)</span><br><span class="line">            mov_read_chapters(s);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s-&gt;nb_streams; i++)</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;streams[i]-&gt;codecpar-&gt;codec_tag == AV_RL32(<span class="string">"tmcd"</span>)) &#123;</span><br><span class="line">                mov_read_timecode_track(s, s-&gt;streams[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;streams[i]-&gt;codecpar-&gt;codec_tag == AV_RL32(<span class="string">"rtmd"</span>)) &#123;</span><br><span class="line">                mov_read_rtmd_track(s, s-&gt;streams[i]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy timecode metadata from tmcd tracks to the related video streams */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *st = s-&gt;streams[i];</span><br><span class="line">        MOVStreamContext *sc = st-&gt;priv_data;</span><br><span class="line">        <span class="keyword">if</span> (sc-&gt;timecode_track &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            AVDictionaryEntry *tcr;</span><br><span class="line">            <span class="keyword">int</span> tmcd_st_id = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; s-&gt;nb_streams; j++)</span><br><span class="line">                <span class="keyword">if</span> (s-&gt;streams[j]-&gt;id == sc-&gt;timecode_track)</span><br><span class="line">                    tmcd_st_id = j;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmcd_st_id &lt; <span class="number">0</span> || tmcd_st_id == i)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            tcr = av_dict_get(s-&gt;streams[tmcd_st_id]-&gt;metadata, <span class="string">"timecode"</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (tcr)</span><br><span class="line">                av_dict_set(&amp;st-&gt;metadata, <span class="string">"timecode"</span>, tcr-&gt;value, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    export_orphan_timecode(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *st = s-&gt;streams[i];</span><br><span class="line">        MOVStreamContext *sc = st-&gt;priv_data;</span><br><span class="line">        fix_timescale(mov, sc);</span><br><span class="line">        <span class="keyword">if</span>(st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO &amp;&amp; st-&gt;codecpar-&gt;codec_id == AV_CODEC_ID_AAC) &#123;</span><br><span class="line">            st-&gt;skip_samples = sc-&gt;start_pad;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO &amp;&amp; sc-&gt;nb_frames_for_fps &gt; <span class="number">0</span> &amp;&amp; sc-&gt;duration_for_fps &gt; <span class="number">0</span>)</span><br><span class="line">            av_reduce(&amp;st-&gt;avg_frame_rate.num, &amp;st-&gt;avg_frame_rate.den,</span><br><span class="line">                      sc-&gt;time_scale*(<span class="keyword">int64_t</span>)sc-&gt;nb_frames_for_fps, sc-&gt;duration_for_fps, INT_MAX);</span><br><span class="line">        <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;codecpar-&gt;width &lt;= <span class="number">0</span> || st-&gt;codecpar-&gt;height &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                st-&gt;codecpar-&gt;width  = sc-&gt;width;</span><br><span class="line">                st-&gt;codecpar-&gt;height = sc-&gt;height;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_id == AV_CODEC_ID_DVD_SUBTITLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((err = mov_rewrite_dvd_sub_extradata(st)) &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mov-&gt;handbrake_version &amp;&amp;</span><br><span class="line">            mov-&gt;handbrake_version &lt;= <span class="number">1000000</span>*<span class="number">0</span> + <span class="number">1000</span>*<span class="number">10</span> + <span class="number">2</span> &amp;&amp;  <span class="comment">// 0.10.2</span></span><br><span class="line">            st-&gt;codecpar-&gt;codec_id == AV_CODEC_ID_MP3</span><br><span class="line">        ) &#123;</span><br><span class="line">            av_log(s, AV_LOG_VERBOSE, <span class="string">"Forcing full parsing for mp3 stream\n"</span>);</span><br><span class="line">            st-&gt;need_parsing = AVSTREAM_PARSE_FULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mov-&gt;trex_data) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s-&gt;nb_streams; i++) &#123;</span><br><span class="line">            AVStream *st = s-&gt;streams[i];</span><br><span class="line">            MOVStreamContext *sc = st-&gt;priv_data;</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;duration &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc-&gt;data_size &gt; INT64_MAX / sc-&gt;time_scale / <span class="number">8</span>) &#123;</span><br><span class="line">                    av_log(s, AV_LOG_ERROR, <span class="string">"Overflow during bit rate calculation %"</span>PRId64<span class="string">" * 8 * %d\n"</span>,</span><br><span class="line">                           sc-&gt;data_size, sc-&gt;time_scale);</span><br><span class="line">                    mov_read_close(s);</span><br><span class="line">                    <span class="keyword">return</span> AVERROR_INVALIDDATA;</span><br><span class="line">                &#125;</span><br><span class="line">                st-&gt;codecpar-&gt;bit_rate = sc-&gt;data_size * <span class="number">8</span> * sc-&gt;time_scale / st-&gt;duration;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mov-&gt;use_mfra_for &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s-&gt;nb_streams; i++) &#123;</span><br><span class="line">            AVStream *st = s-&gt;streams[i];</span><br><span class="line">            MOVStreamContext *sc = st-&gt;priv_data;</span><br><span class="line">            <span class="keyword">if</span> (sc-&gt;duration_for_fps &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc-&gt;data_size &gt; INT64_MAX / sc-&gt;time_scale / <span class="number">8</span>) &#123;</span><br><span class="line">                    av_log(s, AV_LOG_ERROR, <span class="string">"Overflow during bit rate calculation %"</span>PRId64<span class="string">" * 8 * %d\n"</span>,</span><br><span class="line">                           sc-&gt;data_size, sc-&gt;time_scale);</span><br><span class="line">                    mov_read_close(s);</span><br><span class="line">                    <span class="keyword">return</span> AVERROR_INVALIDDATA;</span><br><span class="line">                &#125;</span><br><span class="line">                st-&gt;codecpar-&gt;bit_rate = sc-&gt;data_size * <span class="number">8</span> * sc-&gt;time_scale /</span><br><span class="line">                    sc-&gt;duration_for_fps;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mov-&gt;bitrates_count &amp;&amp; i &lt; s-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mov-&gt;bitrates[i]) &#123;</span><br><span class="line">            s-&gt;streams[i]-&gt;codecpar-&gt;bit_rate = mov-&gt;bitrates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ff_rfps_calculate(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *st = s-&gt;streams[i];</span><br><span class="line">        MOVStreamContext *sc = st-&gt;priv_data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (st-&gt;codecpar-&gt;codec_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">            err = ff_replaygain_export(st, s-&gt;metadata);</span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mov_read_close(s);</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">            <span class="keyword">if</span> (sc-&gt;display_matrix) &#123;</span><br><span class="line">                err = av_stream_add_side_data(st, AV_PKT_DATA_DISPLAYMATRIX, (<span class="keyword">uint8_t</span>*)sc-&gt;display_matrix,</span><br><span class="line">                                              <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>) * <span class="number">9</span>);</span><br><span class="line">                <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">                sc-&gt;display_matrix = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sc-&gt;stereo3d) &#123;</span><br><span class="line">                err = av_stream_add_side_data(st, AV_PKT_DATA_STEREO3D,</span><br><span class="line">                                              (<span class="keyword">uint8_t</span> *)sc-&gt;stereo3d,</span><br><span class="line">                                              <span class="keyword">sizeof</span>(*sc-&gt;stereo3d));</span><br><span class="line">                <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">                sc-&gt;stereo3d = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sc-&gt;spherical) &#123;</span><br><span class="line">                err = av_stream_add_side_data(st, AV_PKT_DATA_SPHERICAL,</span><br><span class="line">                                              (<span class="keyword">uint8_t</span> *)sc-&gt;spherical,</span><br><span class="line">                                              sc-&gt;spherical_size);</span><br><span class="line">                <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">                sc-&gt;spherical = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sc-&gt;mastering) &#123;</span><br><span class="line">                err = av_stream_add_side_data(st, AV_PKT_DATA_MASTERING_DISPLAY_METADATA,</span><br><span class="line">                                              (<span class="keyword">uint8_t</span> *)sc-&gt;mastering,</span><br><span class="line">                                              <span class="keyword">sizeof</span>(*sc-&gt;mastering));</span><br><span class="line">                <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">                sc-&gt;mastering = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sc-&gt;coll) &#123;</span><br><span class="line">                err = av_stream_add_side_data(st, AV_PKT_DATA_CONTENT_LIGHT_LEVEL,</span><br><span class="line">                                              (<span class="keyword">uint8_t</span> *)sc-&gt;coll,</span><br><span class="line">                                              sc-&gt;coll_size);</span><br><span class="line">                <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">                sc-&gt;coll = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ff_configure_buffers_for_index(s, AV_TIME_BASE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mov-&gt;fragment_index_count; i++) &#123;</span><br><span class="line">        MOVFragmentIndex *idx = mov-&gt;fragment_index_data[i];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; idx-&gt;item_count; j++)</span><br><span class="line">            <span class="keyword">if</span> (idx-&gt;items[j].moof_offset &lt;= mov-&gt;fragment.moof_offset)</span><br><span class="line">                idx-&gt;items[j].headers_read = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h2><p><img src="http://yydcdut.com/img/ijkplayer_ffmpeg_avformat_open_input.jpg" alt="雷霄骅(图解FFMPEG打开媒体的函数avformat_open_input)"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://me.csdn.net/leixiaohua1020" target="_blank" rel="external">雷霄骅 - FFMPEG</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2019/02/24/ijkplayer-ffmpeg-avformat-find-stream-info/" class="prev">上一篇</a><a href="/2019/02/17/ijkplayer-ffmpeg-av-register-all/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yydcdut.com">yydcdut</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>