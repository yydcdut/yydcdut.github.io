<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ijkplayer框架简析 -- avformat_find_stream_info · Android杂文 - yydcdut</title><meta name="description" content="ijkplayer框架简析 -- avformat_find_stream_info - yydcdut"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yydcdut.com/atom.xml" title="Android杂文 - yydcdut"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut/yydcdut.github.io/issues" target="_blank" class="nav-list-link">COMMENT</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ijkplayer框架简析 -- avformat_find_stream_info</h1><div class="post-info">2019年2月24日</div><div class="post-content"><p><code>avformat_find_stream_info()</code> 主要是读媒体文件的 packet ，然后从中提取出流的信息</p>
<a id="more"></a>
<h2 id="avformat-find-stream-info"><a href="#avformat-find-stream-info" class="headerlink" title="avformat_find_stream_info"></a>avformat_find_stream_info</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br></pre></td><td class="code"><pre><span class="line">int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)</span><br><span class="line">&#123;</span><br><span class="line">    int i, count = 0, ret = 0, j;</span><br><span class="line">    int64_t read_size;</span><br><span class="line">    AVStream *st;</span><br><span class="line">    AVCodecContext *avctx;</span><br><span class="line">    AVPacket pkt1, *pkt;</span><br><span class="line">    int64_t old_offset  = avio_tell(ic-&gt;pb);</span><br><span class="line">    // new streams might appear, no options for those</span><br><span class="line">    int orig_nb_streams = ic-&gt;nb_streams;</span><br><span class="line">    int flush_codecs;</span><br><span class="line">    int64_t max_analyze_duration = ic-&gt;max_analyze_duration;</span><br><span class="line">    int64_t max_stream_analyze_duration;</span><br><span class="line">    int64_t max_subtitle_analyze_duration;</span><br><span class="line">    int64_t probesize = ic-&gt;probesize;</span><br><span class="line">    int eof_reached = 0;</span><br><span class="line">    int *missing_streams = av_opt_ptr(ic-&gt;iformat-&gt;priv_class, ic-&gt;priv_data, "missing_streams");</span><br><span class="line"></span><br><span class="line">    flush_codecs = probesize &gt; 0;</span><br><span class="line"></span><br><span class="line">    av_opt_set(ic, "skip_clear", "1", AV_OPT_SEARCH_CHILDREN);</span><br><span class="line"></span><br><span class="line">    max_stream_analyze_duration = max_analyze_duration;</span><br><span class="line">    max_subtitle_analyze_duration = max_analyze_duration;</span><br><span class="line">    if (!max_analyze_duration) &#123;</span><br><span class="line">        max_stream_analyze_duration =</span><br><span class="line">        max_analyze_duration        = 5*AV_TIME_BASE;</span><br><span class="line">        max_subtitle_analyze_duration = 30*AV_TIME_BASE;</span><br><span class="line">        if (!strcmp(ic-&gt;iformat-&gt;name, "flv"))</span><br><span class="line">            max_stream_analyze_duration = 90*AV_TIME_BASE;</span><br><span class="line">        if (!strcmp(ic-&gt;iformat-&gt;name, "mpeg") || !strcmp(ic-&gt;iformat-&gt;name, "mpegts"))</span><br><span class="line">            max_stream_analyze_duration = 7*AV_TIME_BASE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ic-&gt;pb)</span><br><span class="line">        av_log(ic, AV_LOG_DEBUG, "Before avformat_find_stream_info() pos: %"PRId64" bytes read:%"PRId64" seeks:%d nb_streams:%d\n",</span><br><span class="line">               avio_tell(ic-&gt;pb), ic-&gt;pb-&gt;bytes_read, ic-&gt;pb-&gt;seek_count, ic-&gt;nb_streams);</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        const AVCodec *codec;</span><br><span class="line">        AVDictionary *thread_opt = NULL;</span><br><span class="line">        st = ic-&gt;streams[i];</span><br><span class="line">        avctx = st-&gt;internal-&gt;avctx;</span><br><span class="line"></span><br><span class="line">        if (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||</span><br><span class="line">            st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;</span><br><span class="line">/*            if (!st-&gt;time_base.num)</span><br><span class="line">                st-&gt;time_base = */</span><br><span class="line">            if (!avctx-&gt;time_base.num)</span><br><span class="line">                avctx-&gt;time_base = st-&gt;time_base;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* check if the caller has overridden the codec id */</span><br><span class="line">#if FF_API_LAVF_AVCTX</span><br><span class="line">FF_DISABLE_DEPRECATION_WARNINGS</span><br><span class="line">        if (st-&gt;codec-&gt;codec_id != st-&gt;internal-&gt;orig_codec_id) &#123;</span><br><span class="line">            st-&gt;codecpar-&gt;codec_id   = st-&gt;codec-&gt;codec_id;</span><br><span class="line">            st-&gt;codecpar-&gt;codec_type = st-&gt;codec-&gt;codec_type;</span><br><span class="line">            st-&gt;internal-&gt;orig_codec_id = st-&gt;codec-&gt;codec_id;</span><br><span class="line">        &#125;</span><br><span class="line">FF_ENABLE_DEPRECATION_WARNINGS</span><br><span class="line">#endif</span><br><span class="line">        // only for the split stuff</span><br><span class="line">        if (!st-&gt;parser &amp;&amp; !(ic-&gt;flags &amp; AVFMT_FLAG_NOPARSE) &amp;&amp; st-&gt;request_probe &lt;= 0) &#123;</span><br><span class="line">            st-&gt;parser = av_parser_init(st-&gt;codecpar-&gt;codec_id);</span><br><span class="line">            if (st-&gt;parser) &#123;</span><br><span class="line">                if (st-&gt;need_parsing == AVSTREAM_PARSE_HEADERS) &#123;</span><br><span class="line">                    st-&gt;parser-&gt;flags |= PARSER_FLAG_COMPLETE_FRAMES;</span><br><span class="line">                &#125; else if (st-&gt;need_parsing == AVSTREAM_PARSE_FULL_RAW) &#123;</span><br><span class="line">                    st-&gt;parser-&gt;flags |= PARSER_FLAG_USE_CODEC_TS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (st-&gt;need_parsing) &#123;</span><br><span class="line">                av_log(ic, AV_LOG_VERBOSE, "parser not found for codec "</span><br><span class="line">                       "%s, packets or times may be invalid.\n",</span><br><span class="line">                       avcodec_get_name(st-&gt;codecpar-&gt;codec_id));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (st-&gt;codecpar-&gt;codec_id != st-&gt;internal-&gt;orig_codec_id)</span><br><span class="line">            st-&gt;internal-&gt;orig_codec_id = st-&gt;codecpar-&gt;codec_id;</span><br><span class="line"></span><br><span class="line">        ret = avcodec_parameters_to_context(avctx, st-&gt;codecpar);</span><br><span class="line">        if (ret &lt; 0)</span><br><span class="line">            goto find_stream_info_err;</span><br><span class="line">        if (st-&gt;request_probe &lt;= 0)</span><br><span class="line">            st-&gt;internal-&gt;avctx_inited = 1;</span><br><span class="line"></span><br><span class="line">        codec = find_probe_decoder(ic, st, st-&gt;codecpar-&gt;codec_id);</span><br><span class="line"></span><br><span class="line">        /* Force thread count to 1 since the H.264 decoder will not extract</span><br><span class="line">         * SPS and PPS to extradata during multi-threaded decoding. */</span><br><span class="line">        av_dict_set(options ? &amp;options[i] : &amp;thread_opt, "threads", "1", 0);</span><br><span class="line"></span><br><span class="line">        if (ic-&gt;codec_whitelist)</span><br><span class="line">            av_dict_set(options ? &amp;options[i] : &amp;thread_opt, "codec_whitelist", ic-&gt;codec_whitelist, 0);</span><br><span class="line"></span><br><span class="line">        /* Ensure that subtitle_header is properly set. */</span><br><span class="line">        if (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE</span><br><span class="line">            &amp;&amp; codec &amp;&amp; !avctx-&gt;codec) &#123;</span><br><span class="line">            if (avcodec_open2(avctx, codec, options ? &amp;options[i] : &amp;thread_opt) &lt; 0)</span><br><span class="line">                av_log(ic, AV_LOG_WARNING,</span><br><span class="line">                       "Failed to open codec in %s\n",__FUNCTION__);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Try to just open decoders, in case this is enough to get parameters.</span><br><span class="line">        if (!has_codec_parameters(st, NULL) &amp;&amp; st-&gt;request_probe &lt;= 0) &#123;</span><br><span class="line">            if (codec &amp;&amp; !avctx-&gt;codec)</span><br><span class="line">                if (avcodec_open2(avctx, codec, options ? &amp;options[i] : &amp;thread_opt) &lt; 0)</span><br><span class="line">                    av_log(ic, AV_LOG_WARNING,</span><br><span class="line">                           "Failed to open codec in %s\n",__FUNCTION__);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!options)</span><br><span class="line">            av_dict_free(&amp;thread_opt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">#if FF_API_R_FRAME_RATE</span><br><span class="line">        ic-&gt;streams[i]-&gt;info-&gt;last_dts = AV_NOPTS_VALUE;</span><br><span class="line">#endif</span><br><span class="line">        ic-&gt;streams[i]-&gt;info-&gt;fps_first_dts = AV_NOPTS_VALUE;</span><br><span class="line">        ic-&gt;streams[i]-&gt;info-&gt;fps_last_dts  = AV_NOPTS_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read_size = 0;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int analyzed_all_streams;</span><br><span class="line">        if (ff_check_interrupt(&amp;ic-&gt;interrupt_callback)) &#123;</span><br><span class="line">            ret = AVERROR_EXIT;</span><br><span class="line">            av_log(ic, AV_LOG_DEBUG, "interrupted\n");</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* check if one codec still needs to be handled */</span><br><span class="line">        for (i = 0; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">            int fps_analyze_framecount = 20;</span><br><span class="line"></span><br><span class="line">            st = ic-&gt;streams[i];</span><br><span class="line">            if (!has_codec_parameters(st, NULL))</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            if (ic-&gt;metadata) &#123;</span><br><span class="line">                AVDictionaryEntry *t = av_dict_get(ic-&gt;metadata, "skip-calc-frame-rate", NULL, AV_DICT_MATCH_CASE);</span><br><span class="line">                if (t) &#123;</span><br><span class="line">                    int fps_flag = (int) strtol(t-&gt;value, NULL, 10);</span><br><span class="line">                    if (!st-&gt;r_frame_rate.num &amp;&amp; st-&gt;avg_frame_rate.num &gt; 0 &amp;&amp; st-&gt;avg_frame_rate.den &gt; 0 &amp;&amp; fps_flag &gt; 0) &#123;</span><br><span class="line">                        int avg_fps = st-&gt;avg_frame_rate.num / st-&gt;avg_frame_rate.den;</span><br><span class="line">                        if (avg_fps &gt; 0 &amp;&amp; avg_fps &lt;= 120) &#123;</span><br><span class="line">                            st-&gt;r_frame_rate.num = st-&gt;avg_frame_rate.num;</span><br><span class="line">                            st-&gt;r_frame_rate.den = st-&gt;avg_frame_rate.den;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            /* If the timebase is coarse (like the usual millisecond precision</span><br><span class="line">             * of mkv), we need to analyze more frames to reliably arrive at</span><br><span class="line">             * the correct fps. */</span><br><span class="line">            if (av_q2d(st-&gt;time_base) &gt; 0.0005)</span><br><span class="line">                fps_analyze_framecount *= 2;</span><br><span class="line">            if (!tb_unreliable(st-&gt;internal-&gt;avctx))</span><br><span class="line">                fps_analyze_framecount = 0;</span><br><span class="line">            if (ic-&gt;fps_probe_size &gt;= 0)</span><br><span class="line">                fps_analyze_framecount = ic-&gt;fps_probe_size;</span><br><span class="line">            if (st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC)</span><br><span class="line">                fps_analyze_framecount = 0;</span><br><span class="line">            /* variable fps and no guess at the real fps */</span><br><span class="line">            if (!(st-&gt;r_frame_rate.num &amp;&amp; st-&gt;avg_frame_rate.num) &amp;&amp;</span><br><span class="line">                st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">                int count = (ic-&gt;iformat-&gt;flags &amp; AVFMT_NOTIMESTAMPS) ?</span><br><span class="line">                    st-&gt;info-&gt;codec_info_duration_fields/2 :</span><br><span class="line">                    st-&gt;info-&gt;duration_count;</span><br><span class="line">                if (count &lt; fps_analyze_framecount)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!st-&gt;internal-&gt;avctx-&gt;extradata &amp;&amp;</span><br><span class="line">                (!st-&gt;internal-&gt;extract_extradata.inited ||</span><br><span class="line">                 st-&gt;internal-&gt;extract_extradata.bsf) &amp;&amp;</span><br><span class="line">                extract_extradata_check(st))</span><br><span class="line">                break;</span><br><span class="line">            if (st-&gt;first_dts == AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">                !(ic-&gt;iformat-&gt;flags &amp; AVFMT_NOTIMESTAMPS) &amp;&amp;</span><br><span class="line">                st-&gt;codec_info_nb_frames &lt; ((st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC) ? 1 : ic-&gt;max_ts_probe) &amp;&amp;</span><br><span class="line">                (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||</span><br><span class="line">                 st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO))</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        analyzed_all_streams = 0;</span><br><span class="line">        if (!missing_streams || !*missing_streams)</span><br><span class="line">        if (i == ic-&gt;nb_streams) &#123;</span><br><span class="line">            analyzed_all_streams = 1;</span><br><span class="line">            /* NOTE: If the format has no header, then we need to read some</span><br><span class="line">             * packets to get most of the streams, so we cannot stop here. */</span><br><span class="line">            if (!(ic-&gt;ctx_flags &amp; AVFMTCTX_NOHEADER)) &#123;</span><br><span class="line">                /* If we found the info for all the codecs, we can stop. */</span><br><span class="line">                ret = count;</span><br><span class="line">                av_log(ic, AV_LOG_DEBUG, "All info found\n");</span><br><span class="line">                flush_codecs = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /* We did not get all the codec info, but we read too much data. */</span><br><span class="line">        if (read_size &gt;= probesize) &#123;</span><br><span class="line">            ret = count;</span><br><span class="line">            av_log(ic, AV_LOG_DEBUG,</span><br><span class="line">                   "Probe buffer size limit of %"PRId64" bytes reached\n", probesize);</span><br><span class="line">            for (i = 0; i &lt; ic-&gt;nb_streams; i++)</span><br><span class="line">                if (!ic-&gt;streams[i]-&gt;r_frame_rate.num &amp;&amp;</span><br><span class="line">                    ic-&gt;streams[i]-&gt;info-&gt;duration_count &lt;= 1 &amp;&amp;</span><br><span class="line">                    ic-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO &amp;&amp;</span><br><span class="line">                    strcmp(ic-&gt;iformat-&gt;name, "image2"))</span><br><span class="line">                    av_log(ic, AV_LOG_WARNING,</span><br><span class="line">                           "Stream #%d: not enough frames to estimate rate; "</span><br><span class="line">                           "consider increasing probesize\n", i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* NOTE: A new stream can be added there if no header in file</span><br><span class="line">         * (AVFMTCTX_NOHEADER). */</span><br><span class="line">        ret = read_frame_internal(ic, &amp;pkt1);</span><br><span class="line">        if (ret == AVERROR(EAGAIN))</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        if (ret &lt; 0) &#123;</span><br><span class="line">            /* EOF or error*/</span><br><span class="line">            eof_reached = 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pkt = &amp;pkt1;</span><br><span class="line"></span><br><span class="line">        if (!(ic-&gt;flags &amp; AVFMT_FLAG_NOBUFFER)) &#123;</span><br><span class="line">            ret = add_to_pktbuf(&amp;ic-&gt;internal-&gt;packet_buffer, pkt,</span><br><span class="line">                                &amp;ic-&gt;internal-&gt;packet_buffer_end, 0);</span><br><span class="line">            if (ret &lt; 0)</span><br><span class="line">                goto find_stream_info_err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st = ic-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">        if (!(st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC))</span><br><span class="line">            read_size += pkt-&gt;size;</span><br><span class="line"></span><br><span class="line">        avctx = st-&gt;internal-&gt;avctx;</span><br><span class="line">        if (!st-&gt;internal-&gt;avctx_inited) &#123;</span><br><span class="line">            ret = avcodec_parameters_to_context(avctx, st-&gt;codecpar);</span><br><span class="line">            if (ret &lt; 0)</span><br><span class="line">                goto find_stream_info_err;</span><br><span class="line">            st-&gt;internal-&gt;avctx_inited = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (pkt-&gt;dts != AV_NOPTS_VALUE &amp;&amp; st-&gt;codec_info_nb_frames &gt; 1) &#123;</span><br><span class="line">            /* check for non-increasing dts */</span><br><span class="line">            if (st-&gt;info-&gt;fps_last_dts != AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">                st-&gt;info-&gt;fps_last_dts &gt;= pkt-&gt;dts) &#123;</span><br><span class="line">                av_log(ic, AV_LOG_DEBUG,</span><br><span class="line">                       "Non-increasing DTS in stream %d: packet %d with DTS "</span><br><span class="line">                       "%"PRId64", packet %d with DTS %"PRId64"\n",</span><br><span class="line">                       st-&gt;index, st-&gt;info-&gt;fps_last_dts_idx,</span><br><span class="line">                       st-&gt;info-&gt;fps_last_dts, st-&gt;codec_info_nb_frames,</span><br><span class="line">                       pkt-&gt;dts);</span><br><span class="line">                st-&gt;info-&gt;fps_first_dts =</span><br><span class="line">                st-&gt;info-&gt;fps_last_dts  = AV_NOPTS_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            /* Check for a discontinuity in dts. If the difference in dts</span><br><span class="line">             * is more than 1000 times the average packet duration in the</span><br><span class="line">             * sequence, we treat it as a discontinuity. */</span><br><span class="line">            if (st-&gt;info-&gt;fps_last_dts != AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">                st-&gt;info-&gt;fps_last_dts_idx &gt; st-&gt;info-&gt;fps_first_dts_idx &amp;&amp;</span><br><span class="line">                (pkt-&gt;dts - st-&gt;info-&gt;fps_last_dts) / 1000 &gt;</span><br><span class="line">                (st-&gt;info-&gt;fps_last_dts     - st-&gt;info-&gt;fps_first_dts) /</span><br><span class="line">                (st-&gt;info-&gt;fps_last_dts_idx - st-&gt;info-&gt;fps_first_dts_idx)) &#123;</span><br><span class="line">                av_log(ic, AV_LOG_WARNING,</span><br><span class="line">                       "DTS discontinuity in stream %d: packet %d with DTS "</span><br><span class="line">                       "%"PRId64", packet %d with DTS %"PRId64"\n",</span><br><span class="line">                       st-&gt;index, st-&gt;info-&gt;fps_last_dts_idx,</span><br><span class="line">                       st-&gt;info-&gt;fps_last_dts, st-&gt;codec_info_nb_frames,</span><br><span class="line">                       pkt-&gt;dts);</span><br><span class="line">                st-&gt;info-&gt;fps_first_dts =</span><br><span class="line">                st-&gt;info-&gt;fps_last_dts  = AV_NOPTS_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* update stored dts values */</span><br><span class="line">            if (st-&gt;info-&gt;fps_first_dts == AV_NOPTS_VALUE) &#123;</span><br><span class="line">                st-&gt;info-&gt;fps_first_dts     = pkt-&gt;dts;</span><br><span class="line">                st-&gt;info-&gt;fps_first_dts_idx = st-&gt;codec_info_nb_frames;</span><br><span class="line">            &#125;</span><br><span class="line">            st-&gt;info-&gt;fps_last_dts     = pkt-&gt;dts;</span><br><span class="line">            st-&gt;info-&gt;fps_last_dts_idx = st-&gt;codec_info_nb_frames;</span><br><span class="line">        &#125;</span><br><span class="line">        if (st-&gt;codec_info_nb_frames&gt;1) &#123;</span><br><span class="line">            int64_t t = 0;</span><br><span class="line">            int64_t limit;</span><br><span class="line"></span><br><span class="line">            if (st-&gt;time_base.den &gt; 0)</span><br><span class="line">                t = av_rescale_q(st-&gt;info-&gt;codec_info_duration, st-&gt;time_base, AV_TIME_BASE_Q);</span><br><span class="line">            if (st-&gt;avg_frame_rate.num &gt; 0)</span><br><span class="line">                t = FFMAX(t, av_rescale_q(st-&gt;codec_info_nb_frames, av_inv_q(st-&gt;avg_frame_rate), AV_TIME_BASE_Q));</span><br><span class="line"></span><br><span class="line">            if (   t == 0</span><br><span class="line">                &amp;&amp; st-&gt;codec_info_nb_frames&gt;30</span><br><span class="line">                &amp;&amp; st-&gt;info-&gt;fps_first_dts != AV_NOPTS_VALUE</span><br><span class="line">                &amp;&amp; st-&gt;info-&gt;fps_last_dts  != AV_NOPTS_VALUE)</span><br><span class="line">                t = FFMAX(t, av_rescale_q(st-&gt;info-&gt;fps_last_dts - st-&gt;info-&gt;fps_first_dts, st-&gt;time_base, AV_TIME_BASE_Q));</span><br><span class="line"></span><br><span class="line">            if (analyzed_all_streams)                                limit = max_analyze_duration;</span><br><span class="line">            else if (avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) limit = max_subtitle_analyze_duration;</span><br><span class="line">            else                                                     limit = max_stream_analyze_duration;</span><br><span class="line"></span><br><span class="line">            if (t &gt;= limit) &#123;</span><br><span class="line">                av_log(ic, AV_LOG_VERBOSE, "max_analyze_duration %"PRId64" reached at %"PRId64" microseconds st:%d\n",</span><br><span class="line">                       limit,</span><br><span class="line">                       t, pkt-&gt;stream_index);</span><br><span class="line">                if (ic-&gt;flags &amp; AVFMT_FLAG_NOBUFFER)</span><br><span class="line">                    av_packet_unref(pkt);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (pkt-&gt;duration) &#123;</span><br><span class="line">                if (avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE &amp;&amp; pkt-&gt;pts != AV_NOPTS_VALUE &amp;&amp; pkt-&gt;pts &gt;= st-&gt;start_time) &#123;</span><br><span class="line">                    st-&gt;info-&gt;codec_info_duration = FFMIN(pkt-&gt;pts - st-&gt;start_time, st-&gt;info-&gt;codec_info_duration + pkt-&gt;duration);</span><br><span class="line">                &#125; else</span><br><span class="line">                    st-&gt;info-&gt;codec_info_duration += pkt-&gt;duration;</span><br><span class="line">                st-&gt;info-&gt;codec_info_duration_fields += st-&gt;parser &amp;&amp; st-&gt;need_parsing &amp;&amp; avctx-&gt;ticks_per_frame ==2 ? st-&gt;parser-&gt;repeat_pict + 1 : 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#if FF_API_R_FRAME_RATE</span><br><span class="line">        if (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO)</span><br><span class="line">            ff_rfps_add_frame(ic, st, pkt-&gt;dts);</span><br><span class="line">#endif</span><br><span class="line">        if (!st-&gt;internal-&gt;avctx-&gt;extradata) &#123;</span><br><span class="line">            ret = extract_extradata(st, pkt);</span><br><span class="line">            if (ret &lt; 0)</span><br><span class="line">                goto find_stream_info_err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* If still no information, we try to open the codec and to</span><br><span class="line">         * decompress the frame. We try to avoid that in most cases as</span><br><span class="line">         * it takes longer and uses more memory. For MPEG-4, we need to</span><br><span class="line">         * decompress for QuickTime.</span><br><span class="line">         *</span><br><span class="line">         * If AV_CODEC_CAP_CHANNEL_CONF is set this will force decoding of at</span><br><span class="line">         * least one frame of codec data, this makes sure the codec initializes</span><br><span class="line">         * the channel configuration and does not only trust the values from</span><br><span class="line">         * the container. */</span><br><span class="line">        try_decode_frame(ic, st, pkt,</span><br><span class="line">                         (options &amp;&amp; i &lt; orig_nb_streams) ? &amp;options[i] : NULL);</span><br><span class="line"></span><br><span class="line">        if (ic-&gt;flags &amp; AVFMT_FLAG_NOBUFFER)</span><br><span class="line">            av_packet_unref(pkt);</span><br><span class="line"></span><br><span class="line">        st-&gt;codec_info_nb_frames++;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (eof_reached) &#123;</span><br><span class="line">        int stream_index;</span><br><span class="line">        for (stream_index = 0; stream_index &lt; ic-&gt;nb_streams; stream_index++) &#123;</span><br><span class="line">            st = ic-&gt;streams[stream_index];</span><br><span class="line">            avctx = st-&gt;internal-&gt;avctx;</span><br><span class="line">            if (!has_codec_parameters(st, NULL)) &#123;</span><br><span class="line">                const AVCodec *codec = find_probe_decoder(ic, st, st-&gt;codecpar-&gt;codec_id);</span><br><span class="line">                if (codec &amp;&amp; !avctx-&gt;codec) &#123;</span><br><span class="line">                    AVDictionary *opts = NULL;</span><br><span class="line">                    if (ic-&gt;codec_whitelist)</span><br><span class="line">                        av_dict_set(&amp;opts, "codec_whitelist", ic-&gt;codec_whitelist, 0);</span><br><span class="line">                    if (avcodec_open2(avctx, codec, (options &amp;&amp; stream_index &lt; orig_nb_streams) ? &amp;options[stream_index] : &amp;opts) &lt; 0)</span><br><span class="line">                        av_log(ic, AV_LOG_WARNING,</span><br><span class="line">                               "Failed to open codec in %s\n",__FUNCTION__);</span><br><span class="line">                    av_dict_free(&amp;opts);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // EOF already reached while reading the stream above.</span><br><span class="line">            // So continue with reoordering DTS with whatever delay we have.</span><br><span class="line">            if (ic-&gt;internal-&gt;packet_buffer &amp;&amp; !has_decode_delay_been_guessed(st)) &#123;</span><br><span class="line">                update_dts_from_pts(ic, stream_index, ic-&gt;internal-&gt;packet_buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (flush_codecs) &#123;</span><br><span class="line">        AVPacket empty_pkt = &#123; 0 &#125;;</span><br><span class="line">        int err = 0;</span><br><span class="line">        av_init_packet(&amp;empty_pkt);</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line"></span><br><span class="line">            st = ic-&gt;streams[i];</span><br><span class="line"></span><br><span class="line">            /* flush the decoders */</span><br><span class="line">            if (st-&gt;info-&gt;found_decoder == 1) &#123;</span><br><span class="line">                do &#123;</span><br><span class="line">                    err = try_decode_frame(ic, st, &amp;empty_pkt,</span><br><span class="line">                                            (options &amp;&amp; i &lt; orig_nb_streams)</span><br><span class="line">                                            ? &amp;options[i] : NULL);</span><br><span class="line">                &#125; while (err &gt; 0 &amp;&amp; !has_codec_parameters(st, NULL));</span><br><span class="line"></span><br><span class="line">                if (err &lt; 0) &#123;</span><br><span class="line">                    av_log(ic, AV_LOG_INFO,</span><br><span class="line">                        "decoding for stream %d failed\n", st-&gt;index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // close codecs which were opened in try_decode_frame()</span><br><span class="line">    for (i = 0; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        st = ic-&gt;streams[i];</span><br><span class="line">        avcodec_close(st-&gt;internal-&gt;avctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ff_rfps_calculate(ic);</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        st = ic-&gt;streams[i];</span><br><span class="line">        avctx = st-&gt;internal-&gt;avctx;</span><br><span class="line">        if (avctx-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">            if (avctx-&gt;codec_id == AV_CODEC_ID_RAWVIDEO &amp;&amp; !avctx-&gt;codec_tag &amp;&amp; !avctx-&gt;bits_per_coded_sample) &#123;</span><br><span class="line">                uint32_t tag= avcodec_pix_fmt_to_codec_tag(avctx-&gt;pix_fmt);</span><br><span class="line">                if (avpriv_find_pix_fmt(avpriv_get_raw_pix_fmt_tags(), tag) == avctx-&gt;pix_fmt)</span><br><span class="line">                    avctx-&gt;codec_tag= tag;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* estimate average framerate if not set by demuxer */</span><br><span class="line">            if (st-&gt;info-&gt;codec_info_duration_fields &amp;&amp;</span><br><span class="line">                !st-&gt;avg_frame_rate.num &amp;&amp;</span><br><span class="line">                st-&gt;info-&gt;codec_info_duration) &#123;</span><br><span class="line">                int best_fps      = 0;</span><br><span class="line">                double best_error = 0.01;</span><br><span class="line">                AVRational codec_frame_rate = avctx-&gt;framerate;</span><br><span class="line"></span><br><span class="line">                if (st-&gt;info-&gt;codec_info_duration        &gt;= INT64_MAX / st-&gt;time_base.num / 2||</span><br><span class="line">                    st-&gt;info-&gt;codec_info_duration_fields &gt;= INT64_MAX / st-&gt;time_base.den ||</span><br><span class="line">                    st-&gt;info-&gt;codec_info_duration        &lt; 0)</span><br><span class="line">                    continue;</span><br><span class="line">                av_reduce(&amp;st-&gt;avg_frame_rate.num, &amp;st-&gt;avg_frame_rate.den,</span><br><span class="line">                          st-&gt;info-&gt;codec_info_duration_fields * (int64_t) st-&gt;time_base.den,</span><br><span class="line">                          st-&gt;info-&gt;codec_info_duration * 2 * (int64_t) st-&gt;time_base.num, 60000);</span><br><span class="line"></span><br><span class="line">                /* Round guessed framerate to a "standard" framerate if it's</span><br><span class="line">                 * within 1% of the original estimate. */</span><br><span class="line">                for (j = 0; j &lt; MAX_STD_TIMEBASES; j++) &#123;</span><br><span class="line">                    AVRational std_fps = &#123; get_std_framerate(j), 12 * 1001 &#125;;</span><br><span class="line">                    double error       = fabs(av_q2d(st-&gt;avg_frame_rate) /</span><br><span class="line">                                              av_q2d(std_fps) - 1);</span><br><span class="line"></span><br><span class="line">                    if (error &lt; best_error) &#123;</span><br><span class="line">                        best_error = error;</span><br><span class="line">                        best_fps   = std_fps.num;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (ic-&gt;internal-&gt;prefer_codec_framerate &amp;&amp; codec_frame_rate.num &gt; 0 &amp;&amp; codec_frame_rate.den &gt; 0) &#123;</span><br><span class="line">                        error       = fabs(av_q2d(codec_frame_rate) /</span><br><span class="line">                                           av_q2d(std_fps) - 1);</span><br><span class="line">                        if (error &lt; best_error) &#123;</span><br><span class="line">                            best_error = error;</span><br><span class="line">                            best_fps   = std_fps.num;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (best_fps)</span><br><span class="line">                    av_reduce(&amp;st-&gt;avg_frame_rate.num, &amp;st-&gt;avg_frame_rate.den,</span><br><span class="line">                              best_fps, 12 * 1001, INT_MAX);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!st-&gt;r_frame_rate.num) &#123;</span><br><span class="line">                if (    avctx-&gt;time_base.den * (int64_t) st-&gt;time_base.num</span><br><span class="line">                    &lt;= avctx-&gt;time_base.num * avctx-&gt;ticks_per_frame * (int64_t) st-&gt;time_base.den) &#123;</span><br><span class="line">                    av_reduce(&amp;st-&gt;r_frame_rate.num, &amp;st-&gt;r_frame_rate.den,</span><br><span class="line">                              avctx-&gt;time_base.den, (int64_t)avctx-&gt;time_base.num * avctx-&gt;ticks_per_frame, INT_MAX);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    st-&gt;r_frame_rate.num = st-&gt;time_base.den;</span><br><span class="line">                    st-&gt;r_frame_rate.den = st-&gt;time_base.num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (st-&gt;display_aspect_ratio.num &amp;&amp; st-&gt;display_aspect_ratio.den) &#123;</span><br><span class="line">                AVRational hw_ratio = &#123; avctx-&gt;height, avctx-&gt;width &#125;;</span><br><span class="line">                st-&gt;sample_aspect_ratio = av_mul_q(st-&gt;display_aspect_ratio,</span><br><span class="line">                                                   hw_ratio);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (avctx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            if (!avctx-&gt;bits_per_coded_sample)</span><br><span class="line">                avctx-&gt;bits_per_coded_sample =</span><br><span class="line">                    av_get_bits_per_sample(avctx-&gt;codec_id);</span><br><span class="line">            // set stream disposition based on audio service type</span><br><span class="line">            switch (avctx-&gt;audio_service_type) &#123;</span><br><span class="line">            case AV_AUDIO_SERVICE_TYPE_EFFECTS:</span><br><span class="line">                st-&gt;disposition = AV_DISPOSITION_CLEAN_EFFECTS;</span><br><span class="line">                break;</span><br><span class="line">            case AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED:</span><br><span class="line">                st-&gt;disposition = AV_DISPOSITION_VISUAL_IMPAIRED;</span><br><span class="line">                break;</span><br><span class="line">            case AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED:</span><br><span class="line">                st-&gt;disposition = AV_DISPOSITION_HEARING_IMPAIRED;</span><br><span class="line">                break;</span><br><span class="line">            case AV_AUDIO_SERVICE_TYPE_COMMENTARY:</span><br><span class="line">                st-&gt;disposition = AV_DISPOSITION_COMMENT;</span><br><span class="line">                break;</span><br><span class="line">            case AV_AUDIO_SERVICE_TYPE_KARAOKE:</span><br><span class="line">                st-&gt;disposition = AV_DISPOSITION_KARAOKE;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (probesize)</span><br><span class="line">        estimate_timings(ic, old_offset);</span><br><span class="line"></span><br><span class="line">    av_opt_set(ic, "skip_clear", "0", AV_OPT_SEARCH_CHILDREN);</span><br><span class="line"></span><br><span class="line">    if (ret &gt;= 0 &amp;&amp; ic-&gt;nb_streams)</span><br><span class="line">        /* We could not have all the codec parameters before EOF. */</span><br><span class="line">        ret = -1;</span><br><span class="line">    for (i = 0; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        const char *errmsg;</span><br><span class="line">        st = ic-&gt;streams[i];</span><br><span class="line"></span><br><span class="line">        /* if no packet was ever seen, update context now for has_codec_parameters */</span><br><span class="line">        if (!st-&gt;internal-&gt;avctx_inited) &#123;</span><br><span class="line">            if (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">                st-&gt;codecpar-&gt;format == AV_SAMPLE_FMT_NONE)</span><br><span class="line">                st-&gt;codecpar-&gt;format = st-&gt;internal-&gt;avctx-&gt;sample_fmt;</span><br><span class="line">            ret = avcodec_parameters_to_context(st-&gt;internal-&gt;avctx, st-&gt;codecpar);</span><br><span class="line">            if (ret &lt; 0)</span><br><span class="line">                goto find_stream_info_err;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!has_codec_parameters(st, &amp;errmsg)) &#123;</span><br><span class="line">            char buf[256];</span><br><span class="line">            avcodec_string(buf, sizeof(buf), st-&gt;internal-&gt;avctx, 0);</span><br><span class="line">            av_log(ic, AV_LOG_WARNING,</span><br><span class="line">                   "Could not find codec parameters for stream %d (%s): %s\n"</span><br><span class="line">                   "Consider increasing the value for the 'analyzeduration' and 'probesize' options\n",</span><br><span class="line">                   i, buf, errmsg);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ret = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compute_chapters_end(ic);</span><br><span class="line"></span><br><span class="line">    /* update the stream parameters from the internal codec contexts */</span><br><span class="line">    for (i = 0; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        st = ic-&gt;streams[i];</span><br><span class="line"></span><br><span class="line">        if (st-&gt;internal-&gt;avctx_inited) &#123;</span><br><span class="line">            int orig_w = st-&gt;codecpar-&gt;width;</span><br><span class="line">            int orig_h = st-&gt;codecpar-&gt;height;</span><br><span class="line">            ret = avcodec_parameters_from_context(st-&gt;codecpar, st-&gt;internal-&gt;avctx);</span><br><span class="line">            if (ret &lt; 0)</span><br><span class="line">                goto find_stream_info_err;</span><br><span class="line">            // The decoder might reduce the video size by the lowres factor.</span><br><span class="line">            if (av_codec_get_lowres(st-&gt;internal-&gt;avctx) &amp;&amp; orig_w) &#123;</span><br><span class="line">                st-&gt;codecpar-&gt;width = orig_w;</span><br><span class="line">                st-&gt;codecpar-&gt;height = orig_h;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">#if FF_API_LAVF_AVCTX</span><br><span class="line">FF_DISABLE_DEPRECATION_WARNINGS</span><br><span class="line">        ret = avcodec_parameters_to_context(st-&gt;codec, st-&gt;codecpar);</span><br><span class="line">        if (ret &lt; 0)</span><br><span class="line">            goto find_stream_info_err;</span><br><span class="line"></span><br><span class="line">        // The old API (AVStream.codec) "requires" the resolution to be adjusted</span><br><span class="line">        // by the lowres factor.</span><br><span class="line">        if (av_codec_get_lowres(st-&gt;internal-&gt;avctx) &amp;&amp; st-&gt;internal-&gt;avctx-&gt;width) &#123;</span><br><span class="line">            av_codec_set_lowres(st-&gt;codec, av_codec_get_lowres(st-&gt;internal-&gt;avctx));</span><br><span class="line">            st-&gt;codec-&gt;width = st-&gt;internal-&gt;avctx-&gt;width;</span><br><span class="line">            st-&gt;codec-&gt;height = st-&gt;internal-&gt;avctx-&gt;height;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (st-&gt;codec-&gt;codec_tag != MKTAG('t','m','c','d')) &#123;</span><br><span class="line">            st-&gt;codec-&gt;time_base = st-&gt;internal-&gt;avctx-&gt;time_base;</span><br><span class="line">            st-&gt;codec-&gt;ticks_per_frame = st-&gt;internal-&gt;avctx-&gt;ticks_per_frame;</span><br><span class="line">        &#125;</span><br><span class="line">        st-&gt;codec-&gt;framerate = st-&gt;avg_frame_rate;</span><br><span class="line"></span><br><span class="line">        if (st-&gt;internal-&gt;avctx-&gt;subtitle_header) &#123;</span><br><span class="line">            st-&gt;codec-&gt;subtitle_header = av_malloc(st-&gt;internal-&gt;avctx-&gt;subtitle_header_size);</span><br><span class="line">            if (!st-&gt;codec-&gt;subtitle_header)</span><br><span class="line">                goto find_stream_info_err;</span><br><span class="line">            st-&gt;codec-&gt;subtitle_header_size = st-&gt;internal-&gt;avctx-&gt;subtitle_header_size;</span><br><span class="line">            memcpy(st-&gt;codec-&gt;subtitle_header, st-&gt;internal-&gt;avctx-&gt;subtitle_header,</span><br><span class="line">                   st-&gt;codec-&gt;subtitle_header_size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Fields unavailable in AVCodecParameters</span><br><span class="line">        st-&gt;codec-&gt;coded_width = st-&gt;internal-&gt;avctx-&gt;coded_width;</span><br><span class="line">        st-&gt;codec-&gt;coded_height = st-&gt;internal-&gt;avctx-&gt;coded_height;</span><br><span class="line">        st-&gt;codec-&gt;properties = st-&gt;internal-&gt;avctx-&gt;properties;</span><br><span class="line">FF_ENABLE_DEPRECATION_WARNINGS</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        st-&gt;internal-&gt;avctx_inited = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">find_stream_info_err:</span><br><span class="line">    for (i = 0; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        st = ic-&gt;streams[i];</span><br><span class="line">        if (st-&gt;info)</span><br><span class="line">            av_freep(&amp;st-&gt;info-&gt;duration_error);</span><br><span class="line">        av_freep(&amp;ic-&gt;streams[i]-&gt;info);</span><br><span class="line">        av_bsf_free(&amp;ic-&gt;streams[i]-&gt;internal-&gt;extract_extradata.bsf);</span><br><span class="line">        av_packet_free(&amp;ic-&gt;streams[i]-&gt;internal-&gt;extract_extradata.pkt);</span><br><span class="line">    &#125;</span><br><span class="line">    if (ic-&gt;pb)</span><br><span class="line">        av_log(ic, AV_LOG_DEBUG, "After avformat_find_stream_info() pos: %"PRId64" bytes read:%"PRId64" seeks:%d frames:%d\n",</span><br><span class="line">               avio_tell(ic-&gt;pb), ic-&gt;pb-&gt;bytes_read, ic-&gt;pb-&gt;seek_count, count);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回值大于等于 0 为正常执行，整个执行过程大概分为几部：</p>
<ul>
<li>声明了 <code>AVStream</code> 结构体来存储媒体流的信息</li>
<li>通过 <code>codec = find_probe_decoder(ic, st, st-&gt;codecpar-&gt;codec_id);</code> 来查找解码器</li>
<li>通过 <code>avcodec_open2(avctx, codec, options ? &amp;options[i] : &amp;thread_opt)</code> 来打开解码器</li>
<li>通过 <code>read_frame_internal(ic, &amp;pkt1)</code> 读取一帧 AVPacket 数据 <em>(A new stream can be added there if no header in file)</em></li>
<li>通过 <code>try_decode_frame(ic, st, pkt, (options &amp;&amp; i &lt; orig_nb_streams) ? &amp;options[i] : NULL);</code> 来解码 <em>(If still no information, we try to open the codec and to decompress the frame. We try to avoid that in most cases as  it takes longer and uses more memory. For MPEG-4, we need to decompress for QuickTime.)</em></li>
</ul>
<h2 id="find-probe-decoder"><a href="#find-probe-decoder" class="headerlink" title="find_probe_decoder"></a>find_probe_decoder</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static const AVCodec *find_probe_decoder(AVFormatContext *s, const AVStream *st, enum AVCodecID codec_id)</span><br><span class="line">&#123;</span><br><span class="line">    const AVCodec *codec;</span><br><span class="line"></span><br><span class="line">#if CONFIG_H264_DECODER</span><br><span class="line">    /* Other parts of the code assume this decoder to be used for h264,</span><br><span class="line">     * so force it if possible. */</span><br><span class="line">    if (codec_id == AV_CODEC_ID_H264)</span><br><span class="line">        return avcodec_find_decoder_by_name("h264");</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    codec = find_decoder(s, st, codec_id);</span><br><span class="line">    if (!codec)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    if (codec-&gt;capabilities &amp; AV_CODEC_CAP_AVOID_PROBING) &#123;</span><br><span class="line">        const AVCodec *probe_codec = NULL;</span><br><span class="line">        while (probe_codec = av_codec_next(probe_codec)) &#123;</span><br><span class="line">            if (probe_codec-&gt;id == codec_id &amp;&amp;</span><br><span class="line">                    av_codec_is_decoder(probe_codec) &amp;&amp;</span><br><span class="line">                    !(probe_codec-&gt;capabilities &amp; (AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_EXPERIMENTAL))) &#123;</span><br><span class="line">                return probe_codec;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return codec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部调用的是 <code>find_decoder()</code> :</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static const AVCodec *find_decoder(AVFormatContext *s, const AVStream *st, enum AVCodecID codec_id)</span><br><span class="line">&#123;</span><br><span class="line">#if FF_API_LAVF_AVCTX</span><br><span class="line">FF_DISABLE_DEPRECATION_WARNINGS</span><br><span class="line">    if (st-&gt;codec-&gt;codec)</span><br><span class="line">        return st-&gt;codec-&gt;codec;</span><br><span class="line">FF_ENABLE_DEPRECATION_WARNINGS</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    switch (st-&gt;codecpar-&gt;codec_type) &#123;</span><br><span class="line">    case AVMEDIA_TYPE_VIDEO:</span><br><span class="line">        if (s-&gt;video_codec)    return s-&gt;video_codec;</span><br><span class="line">        break;</span><br><span class="line">    case AVMEDIA_TYPE_AUDIO:</span><br><span class="line">        if (s-&gt;audio_codec)    return s-&gt;audio_codec;</span><br><span class="line">        break;</span><br><span class="line">    case AVMEDIA_TYPE_SUBTITLE:</span><br><span class="line">        if (s-&gt;subtitle_codec) return s-&gt;subtitle_codec;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return avcodec_find_decoder(codec_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 AVStream 包含了解码器，那么返回对应的 AVCodec，如果没有，则进到 <code>avcodec_find_decoder()</code> 当中</p>
<h3 id="avcodec-find-decoder"><a href="#avcodec-find-decoder" class="headerlink" title="avcodec_find_decoder"></a>avcodec_find_decoder</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVCodec *<span class="title">avcodec_find_decoder</span><span class="params">(<span class="keyword">enum</span> AVCodecID id)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find_encdec(id, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> AVCodec *<span class="title">find_encdec</span><span class="params">(<span class="keyword">enum</span> AVCodecID id, <span class="keyword">int</span> encoder)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    AVCodec *p, *experimental = <span class="literal">NULL</span>;</span><br><span class="line">    p = first_avcodec;</span><br><span class="line">    id= remap_deprecated_codec_id(id);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((encoder ? av_codec_is_encoder(p) : av_codec_is_decoder(p)) &amp;&amp;</span><br><span class="line">            p-&gt;id == id) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;capabilities &amp; AV_CODEC_CAP_EXPERIMENTAL &amp;&amp; !experimental) &#123;</span><br><span class="line">                experimental = p;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> experimental;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>avcodec_find_decoder()</code> 方法利用 AVCodecID 查找 AVCodec，并将找到的 AVCodec 返回，其调用的是 <code>find_encdec()</code> 方法，其中 <code>first_avcodec</code> 便是注册的时候的那个链表的头，循环遍历并比较输入的 ID 和每一个编码器的 ID，直到找到 ID 取值相等的编码器；<code>remap_deprecated_codec_id()</code> 用于将一些过时的编码器 ID 映射到新的编码器 ID</p>
<h2 id="avcodec-open2"><a href="#avcodec-open2" class="headerlink" title="avcodec_open2"></a>avcodec_open2</h2><p><code>avcodec_open2()</code> 主要作用是初始化一个视音频编解码器的 AVCodecContext</p>
<h2 id="read-frame-internal"><a href="#read-frame-internal" class="headerlink" title="read_frame_internal"></a>read_frame_internal</h2><p><code>av_read_frame()</code> 内部实际上就是调用的 <code>read_frame_internal()</code></p>
<h2 id="try-decode-frame"><a href="#try-decode-frame" class="headerlink" title="try_decode_frame"></a>try_decode_frame</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* returns 1 or 0 if or if not decoded data was returned, or a negative error */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_decode_frame</span><span class="params">(AVFormatContext *s, AVStream *st, AVPacket *avpkt,</span><br><span class="line">                            AVDictionary **options)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    AVCodecContext *avctx = st-&gt;internal-&gt;avctx;</span><br><span class="line">    <span class="keyword">const</span> AVCodec *codec;</span><br><span class="line">    <span class="keyword">int</span> got_picture = <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    AVFrame *frame = av_frame_alloc();</span><br><span class="line">    AVSubtitle subtitle;</span><br><span class="line">    AVPacket pkt = *avpkt;</span><br><span class="line">    <span class="keyword">int</span> do_skip_frame = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">enum</span> AVDiscard skip_frame;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frame)</span><br><span class="line">        <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!avcodec_is_open(avctx) &amp;&amp;</span><br><span class="line">        st-&gt;info-&gt;found_decoder &lt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (st-&gt;codecpar-&gt;codec_id != -st-&gt;info-&gt;found_decoder || !st-&gt;codecpar-&gt;codec_id)) &#123;</span><br><span class="line">        AVDictionary *thread_opt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        codec = find_probe_decoder(s, st, st-&gt;codecpar-&gt;codec_id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!codec) &#123;</span><br><span class="line">            st-&gt;info-&gt;found_decoder = -st-&gt;codecpar-&gt;codec_id;</span><br><span class="line">            ret                     = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Force thread count to 1 since the H.264 decoder will not extract</span><br><span class="line">         * SPS and PPS to extradata during multi-threaded decoding. */</span></span><br><span class="line">        av_dict_set(options ? options : &amp;thread_opt, <span class="string">"threads"</span>, <span class="string">"1"</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;codec_whitelist)</span><br><span class="line">            av_dict_set(options ? options : &amp;thread_opt, <span class="string">"codec_whitelist"</span>, s-&gt;codec_whitelist, <span class="number">0</span>);</span><br><span class="line">        ret = avcodec_open2(avctx, codec, options ? options : &amp;thread_opt);</span><br><span class="line">        <span class="keyword">if</span> (!options)</span><br><span class="line">            av_dict_free(&amp;thread_opt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            st-&gt;info-&gt;found_decoder = -avctx-&gt;codec_id;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        st-&gt;info-&gt;found_decoder = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!st-&gt;info-&gt;found_decoder)</span><br><span class="line">        st-&gt;info-&gt;found_decoder = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;info-&gt;found_decoder &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avpriv_codec_get_cap_skip_frame_fill_param(avctx-&gt;codec)) &#123;</span><br><span class="line">        do_skip_frame = <span class="number">1</span>;</span><br><span class="line">        skip_frame = avctx-&gt;skip_frame;</span><br><span class="line">        avctx-&gt;skip_frame = AVDISCARD_ALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pkt.size &gt; <span class="number">0</span> || (!pkt.data &amp;&amp; got_picture)) &amp;&amp;</span><br><span class="line">           ret &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (!has_codec_parameters(st, <span class="literal">NULL</span>) || !has_decode_delay_been_guessed(st) ||</span><br><span class="line">            (!st-&gt;codec_info_nb_frames &amp;&amp;</span><br><span class="line">             (avctx-&gt;codec-&gt;capabilities &amp; AV_CODEC_CAP_CHANNEL_CONF)))) &#123;</span><br><span class="line">        got_picture = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||</span><br><span class="line">            avctx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            ret = avcodec_send_packet(avctx, &amp;pkt);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != AVERROR(EAGAIN) &amp;&amp; ret != AVERROR_EOF)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">                pkt.size = <span class="number">0</span>;</span><br><span class="line">            ret = avcodec_receive_frame(avctx, frame);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">                got_picture = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)</span><br><span class="line">                ret = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;</span><br><span class="line">            ret = avcodec_decode_subtitle2(avctx, &amp;subtitle,</span><br><span class="line">                                           &amp;got_picture, &amp;pkt);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">                pkt.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (got_picture)</span><br><span class="line">                st-&gt;nb_decoded_frames++;</span><br><span class="line">            ret       = got_picture;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pkt.data &amp;&amp; !got_picture)</span><br><span class="line">        ret = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">if</span> (do_skip_frame) &#123;</span><br><span class="line">        avctx-&gt;skip_frame = skip_frame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_frame_free(&amp;frame);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断视音频流的解码器是否已经打开，如果没有打开的话，先打开相应的解码器 <code>find_probe_decoder</code></li>
<li>根据视音频流类型的不同，调用不同的解码函数进行解码<ul>
<li>如果是音视频，调用 <code>avcodec_send_packet()</code><ul>
<li>视频流调用 <code>avcodec_decode_video2()</code></li>
<li>音频流调用 <code>avcodec_decode_audio4()</code></li>
</ul>
</li>
<li>字幕流调用 <code>avcodec_decode_subtitle2()</code></li>
</ul>
</li>
<li>解码的循环会一直持续下去直到满足了 while() 的所有条件。</li>
</ul>
<h2 id="estimate-timings"><a href="#estimate-timings" class="headerlink" title="estimate_timings"></a>estimate_timings</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static void estimate_timings(AVFormatContext *ic, int64_t old_offset)</span><br><span class="line">&#123;</span><br><span class="line">    int64_t file_size;</span><br><span class="line"></span><br><span class="line">    /* get the file size, if possible */</span><br><span class="line">    if (ic-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE) &#123;</span><br><span class="line">        file_size = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        file_size = avio_size(ic-&gt;pb);</span><br><span class="line">        file_size = FFMAX(0, file_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((!strcmp(ic-&gt;iformat-&gt;name, "mpeg") ||</span><br><span class="line">         !strcmp(ic-&gt;iformat-&gt;name, "mpegts")) &amp;&amp;</span><br><span class="line">        file_size &amp;&amp; (ic-&gt;pb-&gt;seekable &amp; AVIO_SEEKABLE_NORMAL)) &#123;</span><br><span class="line">        /* get accurate estimate from the PTSes */</span><br><span class="line">        estimate_timings_from_pts(ic, old_offset);</span><br><span class="line">        ic-&gt;duration_estimation_method = AVFMT_DURATION_FROM_PTS;</span><br><span class="line">    &#125; else if (has_duration(ic)) &#123;</span><br><span class="line">        /* at least one component has timings - we use them for all</span><br><span class="line">         * the components */</span><br><span class="line">        fill_all_stream_timings(ic);</span><br><span class="line">        ic-&gt;duration_estimation_method = AVFMT_DURATION_FROM_STREAM;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* less precise: use bitrate info */</span><br><span class="line">        estimate_timings_from_bit_rate(ic);</span><br><span class="line">        ic-&gt;duration_estimation_method = AVFMT_DURATION_FROM_BITRATE;</span><br><span class="line">    &#125;</span><br><span class="line">    update_stream_timings(ic);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        int i;</span><br><span class="line">        AVStream av_unused *st;</span><br><span class="line">        for (i = 0; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">            st = ic-&gt;streams[i];</span><br><span class="line">            av_log(ic, AV_LOG_TRACE, "stream %d: start_time: %0.3f duration: %0.3f\n", i,</span><br><span class="line">                   (double) st-&gt;start_time * av_q2d(st-&gt;time_base),</span><br><span class="line">                   (double) st-&gt;duration   * av_q2d(st-&gt;time_base));</span><br><span class="line">        &#125;</span><br><span class="line">        av_log(ic, AV_LOG_TRACE,</span><br><span class="line">                "format: start_time: %0.3f duration: %0.3f bitrate=%"PRId64" kb/s\n",</span><br><span class="line">                (double) ic-&gt;start_time / AV_TIME_BASE,</span><br><span class="line">                (double) ic-&gt;duration   / AV_TIME_BASE,</span><br><span class="line">                (int64_t)ic-&gt;bit_rate / 1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>estimate_timings()</code> 位于 <code>avformat_find_stream_info()</code> 最后面，用于估算 AVFormatContext 以及 AVStream 的时长 duration，有 3 种估算方法：</p>
<ul>
<li>通过 pts（显示时间戳）：该方法调用 <code>estimate_timings_from_pts()</code>，它的基本思想就是读取视音频流中的结束位置 AVPacket 的 PTS 和起始位置 AVPacket 的 PTS，两者相减得到时长信息</li>
<li>通过已知流的时长：该方法调用 <code>fill_all_stream_timings()</code>，当有些视音频流有时长信息的时候，直接赋值给其他视音频流</li>
<li>通过 bitrate（码率）：该方法调用 <code>estimate_timings_from_bit_rate()</code>，它的基本思想就是获得整个文件大小，以及整个文件的 bitrate，两者相除之后得到时长信息</li>
</ul>
<h2 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h2><p><img src="http://yydcdut.com/img/ijkplayer_ffmpeg_avformat_find_stream_info.png" alt="dancing_night(https://blog.csdn.net/dancing_night)"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://me.csdn.net/leixiaohua1020" target="_blank" rel="external">雷霄骅 - FFMPEG</a></li>
<li><a href="https://blog.csdn.net/dancing_night" target="_blank" rel="external">dancing_night - FFMPEG</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2019/03/03/ijkplayer-ffmpeg-avcodec-open2/" class="prev">PREV</a><a href="/2019/02/23/ijkplayer-ffmpeg-avformat-open-input/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yydcdut.com">yydcdut</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>