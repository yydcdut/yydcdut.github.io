<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ijkplayer框架简析 -- 音视频同步 · Android杂文 - yydcdut</title><meta name="description" content="ijkplayer框架简析 -- 音视频同步 - yydcdut"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yydcdut.com/atom.xml" title="Android杂文 - yydcdut"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut/yydcdut.github.io/issues" target="_blank" class="nav-list-link">COMMENT</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ijkplayer框架简析 -- 音视频同步</h1><div class="post-info">2019年7月6日</div><div class="post-content"><p>音频和视频是在独自线程中进行解码播放的，需要一个同步的操作来保证时间节点的一致性</p>
<a id="more"></a>
<h2 id="音视频的同步策略"><a href="#音视频的同步策略" class="headerlink" title="音视频的同步策略"></a>音视频的同步策略</h2><ul>
<li>音频为主时钟（视频同步到音频）</li>
<li>视频为主时钟（音频同步到视频）</li>
<li>外部时钟（系统时间）为主时钟（视频、音频同步到外部时钟）</li>
<li>音视频各自为主时钟（视频和音频各自输出，不作同步处理）</li>
</ul>
<p>在 ffplay 中实现了上述前 3 种的同步策略，默认以『音频为主时钟』</p>
<p>由<code>sync</code>参数控制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">"sync"</span>, HAS_ARG | OPT_EXPERT, &#123; .func_arg = opt_sync &#125;, <span class="string">"set audio-video sync. type (type=audio/video/ext)"</span>, <span class="string">"type"</span> &#125;,</span><br></pre></td></tr></table></figure>
<p>引起音视频不同步的原因主要有两种：一种是音频和视频的数据量不一致而且编码算法不同所引起的解码时间差导致的不同步</p>
<h2 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Clock &#123;</span><br><span class="line">    <span class="keyword">double</span> pts;           <span class="comment">/* clock base */</span></span><br><span class="line">    <span class="keyword">double</span> pts_drift;     <span class="comment">/* clock base minus time at which we updated the clock */</span></span><br><span class="line">    <span class="keyword">double</span> last_updated;</span><br><span class="line">    <span class="keyword">double</span> speed;</span><br><span class="line">    <span class="keyword">int</span> serial;           <span class="comment">/* clock is based on a packet with this serial */</span></span><br><span class="line">    <span class="keyword">int</span> paused;</span><br><span class="line">    <span class="keyword">int</span> *queue_serial;    <span class="comment">/* pointer to the current packet queue serial, used for obsolete clock detection */</span></span><br><span class="line">&#125; Clock;</span><br></pre></td></tr></table></figure>
<h4 id="pts"><a href="#pts" class="headerlink" title="pts"></a>pts</h4><p>pts 是 presentation timestamp 的缩写，即显示时间戳，用于标记一个帧的呈现时刻，在这里是 double 类型，其实就是已经转化为秒为单位的 pts 值，实际上 pts 的单位由 timebase 决定，timebase 的类型是结构体 AVRational（用于表示分数）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AVRational&#123;</span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">///&lt; Numerator</span></span><br><span class="line">    <span class="keyword">int</span> den; <span class="comment">///&lt; Denominator</span></span><br><span class="line">&#125; AVRational;</span><br></pre></td></tr></table></figure>
<p>如<code>timebase = {1, 1000}</code> 表示千分之一秒，那么 pts = 1000，即为 1 秒，那么这一帧就需要在第一秒的时候呈现在 ffplay 中，将 pts 转化为秒，一般做法是：<code>pts * av_q2d(timebase)</code></p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>如果视频播放过快，则重复播放上一帧，以等待音频；如果视频播放过慢，则丢帧追赶音频</p>
<p><img src="http://yydcdut.com/img/ijkplayer_video_audio_sync.png" alt="http://upload-images.jianshu.io/upload_images/12588979-04f95496a8e7b325.png"></p>
<p>在 <strong>stream_open</strong> 方法中，会对 clock 进行初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> VideoState *<span class="title">stream_open</span><span class="params">(FFPlayer *ffp, <span class="keyword">const</span> <span class="keyword">char</span> *filename, AVInputFormat *iformat)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    init_clock(&amp;is-&gt;vidclk, &amp;is-&gt;videoq.serial);</span><br><span class="line">    init_clock(&amp;is-&gt;audclk, &amp;is-&gt;audioq.serial);</span><br><span class="line">    init_clock(&amp;is-&gt;extclk, &amp;is-&gt;extclk.serial);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="视频数据"><a href="#视频数据" class="headerlink" title="视频数据"></a>视频数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ffplay_video_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    AVFrame *frame = av_frame_alloc();</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ret = get_video_frame(ffp, frame);</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">						<span class="comment">// 计算出当前帧的播放时间</span></span><br><span class="line">            pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;<span class="function">pts * <span class="title">av_q2d</span><span class="params">(tb)</span></span>;</span><br><span class="line">            pts = pts * <span class="number">1000</span>;</span><br><span class="line">						<span class="comment">// ...</span></span><br><span class="line">      			<span class="comment">// 在此方法中压入 frame_queue 这个队列中</span></span><br><span class="line">            ret = queue_picture(ffp, frame, pts, duration, frame-&gt;pkt_pos, is-&gt;viddec.pkt_serial);</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <strong>get_video_frame</strong> 获取解码的数据后，计算出 pts 也就是当前帧的播放时间 ，pts 的计算方式是 frame-&gt;pts * av_q2d(tb) 其中 tb 是 AVRational 结构体，是一个 timebase</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">queue_picture</span><span class="params">(FFPlayer *ffp, AVFrame *src_frame, <span class="keyword">double</span> pts, <span class="keyword">double</span> duration, int64_t pos, <span class="keyword">int</span> serial)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Frame *vp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 frame_queue 中获取一个可写的 Frame, 如果没有则 wait 等待 signal</span></span><br><span class="line">    <span class="keyword">if</span> (!(vp = frame_queue_peek_writable(&amp;is-&gt;pictq)))</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 修改 frame_queue 中的 size</span></span><br><span class="line">    frame_queue_push(&amp;is-&gt;pictq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AVFrame 的每次写入都要从 frame_queue 中获取一个 Frame</p>
<h3 id="音频数据"><a href="#音频数据" class="headerlink" title="音频数据"></a>音频数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">audio_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    AVFrame *frame = av_frame_alloc();</span><br><span class="line">    Frame *af;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      	<span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> ((got_frame = decoder_decode_frame(ffp, &amp;is-&gt;auddec, frame, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> the_end;</span><br><span class="line">        <span class="keyword">if</span> (got_frame) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> (!(af = frame_queue_peek_writable(&amp;is-&gt;sampq)))</span><br><span class="line">                <span class="keyword">goto</span> the_end;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            av_frame_move_ref(af-&gt;frame, frame);</span><br><span class="line">            frame_queue_push(&amp;is-&gt;sampq);</span><br><span class="line">          	<span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (ret &gt;= <span class="number">0</span> || ret == AVERROR(EAGAIN) || ret == AVERROR_EOF);</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程和视频解码的差不多，同样是将解码出来的 AVFrame 赋值到 Frame 中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">audio_decode_frame</span><span class="params">(FFPlayer *ffp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!(af = frame_queue_peek_readable(&amp;is-&gt;sampq)))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* update the audio clock with the pts */</span></span><br><span class="line">    <span class="keyword">if</span> (!isnan(af-&gt;pts))</span><br><span class="line">        is-&gt;audio_clock = af-&gt;pts + (<span class="keyword">double</span>) af-&gt;frame-&gt;nb_samples / af-&gt;frame-&gt;sample_rate;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        is-&gt;audio_clock = NAN;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在音频播放的方法里，每播放一帧都会得到这一帧的播放时间, 将其保存在 Video_State 这个结构体的 audio_clock 中，而音视频同步的计算是利用到此结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sdl_audio_callback</span><span class="params">(<span class="keyword">void</span> *opaque, Uint8 *stream, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    audio_size = audio_decode_frame(ffp);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  	<span class="comment">/* Let's assume the audio driver that is used by SDL has two periods. */</span></span><br><span class="line">    <span class="keyword">if</span> (!isnan(is-&gt;audio_clock)) &#123;</span><br><span class="line">        set_clock_at(&amp;is-&gt;audclk, </span><br><span class="line">                     is-&gt;audio_clock - (<span class="keyword">double</span>)(is-&gt;audio_write_buf_size) / is-&gt;audio_tgt.bytes_per_sec - SDL_AoutGetLatencySeconds(ffp-&gt;aout), </span><br><span class="line">                     is-&gt;audio_clock_serial, </span><br><span class="line">                     ffp-&gt;audio_callback_time / <span class="number">1000000.0</span>);</span><br><span class="line">        sync_clock_to_slave(&amp;is-&gt;extclk, &amp;is-&gt;audclk);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将得到的 audio_clock 通过一系列处理，保存到 Clock 结构体里面，其中 <code>set_clock_at</code> 的第二个参数最后得到的结果是当前帧播放的秒数</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">static int video_refresh_thread(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    FFPlayer *ffp = arg;</span><br><span class="line">    VideoState *is = ffp-&gt;is;</span><br><span class="line">    double remaining_time = 0.0;</span><br><span class="line">    while (!is-&gt;abort_request) &#123;</span><br><span class="line">        if (remaining_time &gt; 0.0)</span><br><span class="line">            av_usleep((int)(int64_t)(remaining_time * 1000000.0));</span><br><span class="line">        remaining_time = REFRESH_RATE;</span><br><span class="line">        if (is-&gt;show_mode != SHOW_MODE_NONE &amp;&amp; (!is-&gt;paused || is-&gt;force_refresh))</span><br><span class="line">            video_refresh(ffp, &amp;remaining_time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* called to display each frame */</span><br><span class="line">static void video_refresh(FFPlayer *opaque, double *remaining_time)</span><br><span class="line">&#123;</span><br><span class="line">    FFPlayer *ffp = opaque;</span><br><span class="line">    VideoState *is = ffp-&gt;is;</span><br><span class="line">    double time;</span><br><span class="line"></span><br><span class="line">    Frame *sp, *sp2;</span><br><span class="line"></span><br><span class="line">    if (!is-&gt;paused &amp;&amp; get_master_sync_type(is) == AV_SYNC_EXTERNAL_CLOCK &amp;&amp; is-&gt;realtime)</span><br><span class="line">        check_external_clock_speed(is);</span><br><span class="line"></span><br><span class="line">    if (!ffp-&gt;display_disable &amp;&amp; is-&gt;show_mode != SHOW_MODE_VIDEO &amp;&amp; is-&gt;audio_st) &#123;</span><br><span class="line">        time = av_gettime_relative() / 1000000.0;</span><br><span class="line">        if (is-&gt;force_refresh || is-&gt;last_vis_time + ffp-&gt;rdftspeed &lt; time) &#123;</span><br><span class="line">            video_display2(ffp);</span><br><span class="line">            is-&gt;last_vis_time = time;</span><br><span class="line">        &#125;</span><br><span class="line">        *remaining_time = FFMIN(*remaining_time, is-&gt;last_vis_time + ffp-&gt;rdftspeed - time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (is-&gt;video_st) &#123;</span><br><span class="line">retry:</span><br><span class="line">        if (frame_queue_nb_remaining(&amp;is-&gt;pictq) == 0) &#123;</span><br><span class="line">            // nothing to do, no picture to display in the queue</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            double last_duration, duration, delay;</span><br><span class="line">            Frame *vp, *lastvp; // lastvp上一帧，vp当前帧 ，nextvp下一帧</span><br><span class="line"></span><br><span class="line">            /* dequeue the picture */</span><br><span class="line">            lastvp = frame_queue_peek_last(&amp;is-&gt;pictq);</span><br><span class="line">            vp = frame_queue_peek(&amp;is-&gt;pictq);</span><br><span class="line"></span><br><span class="line">            if (vp-&gt;serial != is-&gt;videoq.serial) &#123;</span><br><span class="line">                frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">                goto retry;</span><br><span class="line">            &#125;</span><br><span class="line">						// 跳帧处理</span><br><span class="line">            if (lastvp-&gt;serial != vp-&gt;serial)</span><br><span class="line">                is-&gt;frame_timer = av_gettime_relative() / 1000000.0;</span><br><span class="line"></span><br><span class="line">            if (is-&gt;paused)</span><br><span class="line">                goto display;</span><br><span class="line"></span><br><span class="line">            /* compute nominal last_duration */</span><br><span class="line">            last_duration = vp_duration(is, lastvp, vp); // 计算上一帧的持续时长</span><br><span class="line">          	// 计算当前需要delay的时间</span><br><span class="line">            delay = compute_target_delay(ffp, last_duration, is);</span><br><span class="line">						// 取系统时刻</span><br><span class="line">            time= av_gettime_relative()/1000000.0;</span><br><span class="line">            if (isnan(is-&gt;frame_timer) || time &lt; is-&gt;frame_timer)</span><br><span class="line">                is-&gt;frame_timer = time;</span><br><span class="line">            if (time &lt; is-&gt;frame_timer + delay) &#123; // 如果上一帧显示时长未满，重复显示上一帧</span><br><span class="line">                *remaining_time = FFMIN(is-&gt;frame_timer + delay - time, *remaining_time);</span><br><span class="line">                goto display;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            is-&gt;frame_timer += delay; // frame_timer 更新为上一帧结束时刻，也是当前帧开始时刻</span><br><span class="line">            if (delay &gt; 0 &amp;&amp; time - is-&gt;frame_timer &gt; AV_SYNC_THRESHOLD_MAX)</span><br><span class="line">                is-&gt;frame_timer = time; //如果与系统时间的偏离太大，则修正为系统时间</span><br><span class="line"></span><br><span class="line">            SDL_LockMutex(is-&gt;pictq.mutex);</span><br><span class="line">            if (!isnan(vp-&gt;pts))</span><br><span class="line">                update_video_pts(is, vp-&gt;pts, vp-&gt;pos, vp-&gt;serial); // 修改 Clock,下次同步计算处理</span><br><span class="line">            SDL_UnlockMutex(is-&gt;pictq.mutex);</span><br><span class="line"></span><br><span class="line">          	// 丢帧逻辑</span><br><span class="line">            if (frame_queue_nb_remaining(&amp;is-&gt;pictq) &gt; 1) &#123;</span><br><span class="line">                Frame *nextvp = frame_queue_peek_next(&amp;is-&gt;pictq);</span><br><span class="line">                duration = vp_duration(is, vp, nextvp); // 当前帧显示时长</span><br><span class="line">                if(!is-&gt;step &amp;&amp; (ffp-&gt;framedrop &gt; 0 || (ffp-&gt;framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &amp;&amp; time &gt; is-&gt;frame_timer + duration) &#123; // 如果系统时间已经大于当前帧，则丢弃当前帧</span><br><span class="line">                    frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">                  	// 回到函数开始位置，继续重试</span><br><span class="line">                    goto retry;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">	</span><br><span class="line">          	// ... </span><br><span class="line">          </span><br><span class="line">            frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">            is-&gt;force_refresh = 1;</span><br><span class="line"></span><br><span class="line">            SDL_LockMutex(ffp-&gt;is-&gt;play_mutex);</span><br><span class="line">            if (is-&gt;step) &#123;</span><br><span class="line">                is-&gt;step = 0;</span><br><span class="line">                if (!is-&gt;paused)</span><br><span class="line">                    stream_update_pause_l(ffp);</span><br><span class="line">            &#125;</span><br><span class="line">            SDL_UnlockMutex(ffp-&gt;is-&gt;play_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">display:</span><br><span class="line">        /* display picture */</span><br><span class="line">        if (!ffp-&gt;display_disable &amp;&amp; is-&gt;force_refresh &amp;&amp; is-&gt;show_mode == SHOW_MODE_VIDEO &amp;&amp; is-&gt;pictq.rindex_shown)</span><br><span class="line">          	// 渲染视频</span><br><span class="line">            video_display2(ffp);</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就到了视频的渲染了，视频渲染的线程是 video_refresh_thread , <code>remaining_time</code> 是视频渲染线程需要 sleep 的时间也就是同步时间，单位是 us</p>
<p><img src="http://yydcdut.com/img/ijkplayer_video_audio_sync_video_refresh.jpg" alt="https://pic2.zhimg.com/v2-6316d7bd07a4cc541da4866b632aa559_r.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* display the current picture, if any */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">video_display2</span><span class="params">(FFPlayer *ffp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    VideoState *is = ffp-&gt;is;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;video_st)</span><br><span class="line">        video_image_display2(ffp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">video_image_display2</span><span class="params">(FFPlayer *ffp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    VideoState *is = ffp-&gt;is;</span><br><span class="line">    Frame *vp;</span><br><span class="line">    Frame *sp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    vp = frame_queue_peek_last(&amp;is-&gt;pictq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vp-&gt;bmp) &#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (ffp-&gt;render_wait_start &amp;&amp; !ffp-&gt;start_on_prepared &amp;&amp; is-&gt;pause_req) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ffp-&gt;first_video_frame_rendered) &#123;</span><br><span class="line">                ffp-&gt;first_video_frame_rendered = <span class="number">1</span>;</span><br><span class="line">                ffp_notify_msg1(ffp, FFP_MSG_VIDEO_RENDERING_START);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (is-&gt;pause_req &amp;&amp; !is-&gt;abort_request) &#123;</span><br><span class="line">                SDL_Delay(<span class="number">20</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 渲染图像</span></span><br><span class="line">        SDL_VoutDisplayYUVOverlay(ffp-&gt;vout, vp-&gt;bmp);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/96217ec4356e" target="_blank" rel="external">ijkplayer 音视频同步流程分析</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2019/07/07/okhttp-analyse/" class="prev">PREV</a><a href="/2019/03/30/ijkplayer-stream-open/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yydcdut.com">yydcdut</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>