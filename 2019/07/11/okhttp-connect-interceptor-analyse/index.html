<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> OkHttp - ConnectInterceptor源码简析 · Android杂文 - yydcdut</title><meta name="description" content="OkHttp - ConnectInterceptor源码简析 - yydcdut"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yydcdut.com/atom.xml" title="Android杂文 - yydcdut"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut/yydcdut.github.io/issues" target="_blank" class="nav-list-link">COMMENT</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">OkHttp - ConnectInterceptor源码简析</h1><div class="post-info">2019年7月11日</div><div class="post-content"><blockquote>
<p>Github: <a href="https://github.com/square/okhttp" target="_blank" rel="external">okhttp</a>      分析版本：<a href="https://github.com/square/okhttp/tree/930d4d07d836aef3c2681867d6ab9e73c23aacfb" target="_blank" rel="external">930d4d0</a></p>
</blockquote>
<p>Opens a connection to the target server and proceeds to the next interceptor</p>
<a id="more"></a>
<h3 id="intercept-chain-Interceptor-Chain"><a href="#intercept-chain-Interceptor-Chain" class="headerlink" title="intercept(chain: Interceptor.Chain)"></a>intercept(chain: Interceptor.Chain)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span></span>(<span class="variable"><span class="keyword">val</span> client</span>: OkHttpClient) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">  @Throws(IOException::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="typename">Interceptor.Chain</span>)</span>: Response &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> realChain</span> = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> request</span> = realChain.request()</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> transmitter</span> = realChain.transmitter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> doExtensiveHealthChecks</span> = request.method != <span class="string">"GET"</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> exchange</span> = transmitter.newExchange(chain, doExtensiveHealthChecks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>doExtensiveHealthChecks</code> 为非 GET 请求</li>
<li>通过 <code>transmitter.newExchange()</code> 来创建 <code>Exchange</code></li>
<li><code>realChain.proceed()</code> 告知下一个拦截器开始去执行</li>
</ul>
<h3 id="Transmitter-newExchange-chain-Interceptor-Chain-doExtensiveHealthChecks-Boolean"><a href="#Transmitter-newExchange-chain-Interceptor-Chain-doExtensiveHealthChecks-Boolean" class="headerlink" title="Transmitter#newExchange(chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean)"></a>Transmitter#newExchange(chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transmitter</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> client</span>: OkHttpClient,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> call</span>: Call</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">/** Returns a new exchange to carry a new request and response. */</span></span><br><span class="line">  internal <span class="function"><span class="keyword">fun</span> <span class="title">newExchange</span><span class="params">(chain: <span class="typename">Interceptor.Chain, doExtensiveHealthChecks: Boolean</span>)</span>: Exchange &#123;</span></span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      check(!noMoreExchanges) &#123; <span class="string">"released"</span> &#125;</span><br><span class="line">      check(exchange == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="string">"cannot make a new request because the previous response is still open: "</span> +</span><br><span class="line">            <span class="string">"please call response.close()"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> codec</span> = exchangeFinder!!.find(client, chain, doExtensiveHealthChecks)</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> result</span> = Exchange(this, call, eventListener, exchangeFinder!!, codec)</span><br><span class="line"></span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      this.exchange = result</span><br><span class="line">      this.exchangeRequestDone = <span class="literal">false</span></span><br><span class="line">      this.exchangeResponseDone = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>exchangeFinder!!.find()</code> 来创建 <code>ExchangeCodec</code></p>
<h3 id="ExchangeFinder-find-client-OkHttpClient-chain-Interceptor-Chain-doExtensiveHealthChecks-Boolean"><a href="#ExchangeFinder-find-client-OkHttpClient-chain-Interceptor-Chain-doExtensiveHealthChecks-Boolean" class="headerlink" title="ExchangeFinder#find(client: OkHttpClient, chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean)"></a>ExchangeFinder#find(client: OkHttpClient, chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExchangeFinder</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> transmitter</span>: Transmitter,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> connectionPool</span>: RealConnectionPool,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> address</span>: Address,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> call</span>: Call,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> eventListener</span>: EventListener</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">(</span><br><span class="line">    client: <span class="typename">OkHttpClient,</span><br><span class="line">    chain: Interceptor.Chain,</span><br><span class="line">    doExtensiveHealthChecks: Boolean</span></span><br><span class="line">  )</span>: ExchangeCodec &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> connectTimeout</span> = chain.connectTimeoutMillis()</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> readTimeout</span> = chain.readTimeoutMillis()</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> writeTimeout</span> = chain.writeTimeoutMillis()</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> pingIntervalMillis</span> = client.pingIntervalMillis()</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> connectionRetryEnabled</span> = client.retryOnConnectionFailure()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 寻找一个链接（在链接池中寻找或者在新创建一个连接）</span></span><br><span class="line">      <span class="variable"><span class="keyword">val</span> resultConnection</span> = findHealthyConnection(</span><br><span class="line">          connectTimeout = connectTimeout,</span><br><span class="line">          readTimeout = readTimeout,</span><br><span class="line">          writeTimeout = writeTimeout,</span><br><span class="line">          pingIntervalMillis = pingIntervalMillis,</span><br><span class="line">          connectionRetryEnabled = connectionRetryEnabled,</span><br><span class="line">          doExtensiveHealthChecks = doExtensiveHealthChecks</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">return</span> resultConnection.newCodec(client, chain)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">      trackFailure()</span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      trackFailure()</span><br><span class="line">      <span class="keyword">throw</span> RouteException(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>findHealthyConnection()</code> 找到一条『健康』的链接，然后通过 <code>RealConnection#newCodec()</code> 来创建 <code>ExchangeCodec</code></p>
<h3 id="ExchangeFinder-findHealthyConnection-connectTimeout-Int-readTimeout-Int-writeTimeout-Int-pingIntervalMillis-Int-connectionRetryEnabled-Boolean-doExtensiveHealthChecks-Boolean"><a href="#ExchangeFinder-findHealthyConnection-connectTimeout-Int-readTimeout-Int-writeTimeout-Int-pingIntervalMillis-Int-connectionRetryEnabled-Boolean-doExtensiveHealthChecks-Boolean" class="headerlink" title="ExchangeFinder#findHealthyConnection(connectTimeout: Int, readTimeout: Int, writeTimeout: Int, pingIntervalMillis: Int, connectionRetryEnabled: Boolean, doExtensiveHealthChecks: Boolean)"></a>ExchangeFinder#findHealthyConnection(connectTimeout: Int, readTimeout: Int, writeTimeout: Int, pingIntervalMillis: Int, connectionRetryEnabled: Boolean, doExtensiveHealthChecks: Boolean)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExchangeFinder</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> transmitter</span>: Transmitter,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> connectionPool</span>: RealConnectionPool,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> address</span>: Address,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> call</span>: Call,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> eventListener</span>: EventListener</span><br><span class="line">) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated</span><br><span class="line">   * until a healthy connection is found.</span><br><span class="line">   */</span></span><br><span class="line">  @Throws(IOException::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findHealthyConnection</span><span class="params">(</span><br><span class="line">    connectTimeout: <span class="typename">Int,</span><br><span class="line">    readTimeout: Int,</span><br><span class="line">    writeTimeout: Int,</span><br><span class="line">    pingIntervalMillis: Int,</span><br><span class="line">    connectionRetryEnabled: Boolean,</span><br><span class="line">    doExtensiveHealthChecks: Boolean</span></span><br><span class="line">  )</span>: RealConnection &#123;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 循环查找一个链接</span></span><br><span class="line">      <span class="variable"><span class="keyword">val</span> candidate</span> = findConnection(</span><br><span class="line">          connectTimeout = connectTimeout,</span><br><span class="line">          readTimeout = readTimeout,</span><br><span class="line">          writeTimeout = writeTimeout,</span><br><span class="line">          pingIntervalMillis = pingIntervalMillis,</span><br><span class="line">          connectionRetryEnabled = connectionRetryEnabled</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果是新链接，跳过 healthy 判断直接返回</span></span><br><span class="line">      <span class="comment">// If this is a brand new connection, we can skip the extensive health checks.</span></span><br><span class="line">      synchronized(connectionPool) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate.successCount == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> candidate</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这条链接是否可用</span></span><br><span class="line">      <span class="comment">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span></span><br><span class="line">      <span class="comment">// isn't, take it out of the pool and start again.</span></span><br><span class="line">      <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">        candidate.noNewExchanges() <span class="comment">// 禁止这条链接，将 noNewExchanges 置为 true</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> candidate</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findHealthyConnection()</code> 是负责死循环去检测获取到的 <code>RealConnection</code> 是否可用，如果是新创建的则跳过检测，当 <code>RealConnection</code> 不可用的话就继续去调用 findConnection 去重新获取一个连接</p>
<h3 id="ExchangeFinder-findConnection-connectTimeout-Int-readTimeout-Int-writeTimeout-Int-pingIntervalMillis-Int-connectionRetryEnabled-Boolean"><a href="#ExchangeFinder-findConnection-connectTimeout-Int-readTimeout-Int-writeTimeout-Int-pingIntervalMillis-Int-connectionRetryEnabled-Boolean" class="headerlink" title="ExchangeFinder#findConnection(connectTimeout: Int, readTimeout: Int, writeTimeout: Int, pingIntervalMillis: Int, connectionRetryEnabled: Boolean)"></a>ExchangeFinder#findConnection(connectTimeout: Int, readTimeout: Int, writeTimeout: Int, pingIntervalMillis: Int, connectionRetryEnabled: Boolean)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExchangeFinder</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> transmitter</span>: Transmitter,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> connectionPool</span>: RealConnectionPool,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> address</span>: Address,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> call</span>: Call,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> eventListener</span>: EventListener</span><br><span class="line">) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Returns a connection to host a new stream. This prefers the existing connection if it exists,</span><br><span class="line">   * then the pool, finally building a new connection.</span><br><span class="line">   */</span></span><br><span class="line">  @Throws(IOException::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findConnection</span><span class="params">(</span><br><span class="line">    connectTimeout: <span class="typename">Int,</span><br><span class="line">    readTimeout: Int,</span><br><span class="line">    writeTimeout: Int,</span><br><span class="line">    pingIntervalMillis: Int,</span><br><span class="line">    connectionRetryEnabled: Boolean</span></span><br><span class="line">  )</span>: RealConnection &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> foundPooledConnection</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> result</span>: RealConnection? = <span class="literal">null</span></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> selectedRoute</span>: Route? = <span class="literal">null</span></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> releasedConnection</span>: RealConnection?</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> toClose</span>: Socket?</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled) <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>) <span class="comment">// 取消了</span></span><br><span class="line">      hasStreamFailure = <span class="literal">false</span> <span class="comment">// This is a fresh attempt.</span></span><br><span class="line"></span><br><span class="line">      releasedConnection = transmitter.connection</span><br><span class="line">      <span class="comment">// 若不可用了，则关闭</span></span><br><span class="line">      toClose = <span class="keyword">if</span> (transmitter.connection != <span class="literal">null</span> &amp;&amp; transmitter.connection!!.noNewExchanges) &#123;</span><br><span class="line">        transmitter.releaseConnectionNoEvents()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从 transmitter 获取</span></span><br><span class="line">      <span class="keyword">if</span> (transmitter.connection != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We had an already-allocated connection and it's good.</span></span><br><span class="line">        result = transmitter.connection</span><br><span class="line">        releasedConnection = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从链接池中取，取到赋值给 transmitter</span></span><br><span class="line">        <span class="comment">// Attempt to get a connection from the pool.</span></span><br><span class="line">        <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, <span class="literal">null</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">          foundPooledConnection = <span class="literal">true</span></span><br><span class="line">          result = transmitter.connection</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 路由</span></span><br><span class="line">          selectedRoute = nextRouteToTry</span><br><span class="line">          nextRouteToTry = <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retryCurrentRoute()) &#123;</span><br><span class="line">          selectedRoute = transmitter.connection!!.route()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放没用的 connection</span></span><br><span class="line">    toClose?.closeQuietly()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (releasedConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">      eventListener.connectionReleased(call, releasedConnection!!)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果找到复用的，则使用这条链接，回调</span></span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 找到一条可复用的链接</span></span><br><span class="line">      <span class="comment">// If we found an already-allocated or pooled connection, we're done.</span></span><br><span class="line">      <span class="keyword">return</span> result!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换路由再在链接池里面找，如果有则返回</span></span><br><span class="line">    <span class="comment">// If we need a route selection, make one. This is a blocking operation.</span></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> newRouteSelection</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (selectedRoute == <span class="literal">null</span> &amp;&amp; (routeSelection == <span class="literal">null</span> || !routeSelection!!.hasNext())) &#123;</span><br><span class="line">      newRouteSelection = <span class="literal">true</span></span><br><span class="line">      routeSelection = routeSelector.next()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> routes</span>: List<span class="type">&lt;Route&gt;</span>? = <span class="literal">null</span></span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled) <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">        <span class="comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class="line">        <span class="comment">// the pool. This could match due to connection coalescing.</span></span><br><span class="line">        routes = routeSelection!!.routes</span><br><span class="line">        <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(</span><br><span class="line">                address, transmitter, routes, <span class="literal">false</span>)) &#123;</span><br><span class="line">          foundPooledConnection = <span class="literal">true</span></span><br><span class="line">          result = transmitter.connection</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">        <span class="comment">// 没找到则创建一条</span></span><br><span class="line">        <span class="keyword">if</span> (selectedRoute == <span class="literal">null</span>) &#123;</span><br><span class="line">          selectedRoute = routeSelection!!.next()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span></span><br><span class="line">        <span class="comment">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span></span><br><span class="line">        result = RealConnection(connectionPool, selectedRoute!!)</span><br><span class="line">        connectingConnection = result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we found a pooled connection on the 2nd time around, we're done.</span></span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result!!)</span><br><span class="line">      <span class="keyword">return</span> result!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立链接</span></span><br><span class="line">    <span class="comment">// Do TCP + TLS handshakes. This is a blocking operation.</span></span><br><span class="line">    result!!.connect(</span><br><span class="line">        connectTimeout,</span><br><span class="line">        readTimeout,</span><br><span class="line">        writeTimeout,</span><br><span class="line">        pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled,</span><br><span class="line">        call,</span><br><span class="line">        eventListener</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 将这条路由从错误缓存中清除</span></span><br><span class="line">    connectionPool.routeDatabase.connected(result!!.route())</span><br><span class="line"></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> socket</span>: Socket? = <span class="literal">null</span></span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      connectingConnection = <span class="literal">null</span></span><br><span class="line">      <span class="comment">// 检测一下，若多并发情况下同 address 下导致创建多个，则将当前这个释放掉</span></span><br><span class="line">      <span class="comment">// Last attempt at connection coalescing, which only occurs if we attempted multiple</span></span><br><span class="line">      <span class="comment">// concurrent connections to the same host.</span></span><br><span class="line">      <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// We lost the race! Close the connection we created and return the pooled connection.</span></span><br><span class="line">        result!!.noNewExchanges = <span class="literal">true</span></span><br><span class="line">        socket = result!!.socket()</span><br><span class="line">        result = transmitter.connection</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将这个请求加入链接池</span></span><br><span class="line">        connectionPool.put(result!!)</span><br><span class="line">        transmitter.acquireConnectionNoEvents(result!!)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放掉 socket</span></span><br><span class="line">    socket?.closeQuietly()</span><br><span class="line"></span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    <span class="keyword">return</span> result!!</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RealConnectionPool-transmitterAcquirePooledConnection-address-Address-transmitter-Transmitter-routes-List-requireMultiplexed-Boolean"><a href="#RealConnectionPool-transmitterAcquirePooledConnection-address-Address-transmitter-Transmitter-routes-List-requireMultiplexed-Boolean" class="headerlink" title="RealConnectionPool#transmitterAcquirePooledConnection(address: Address, transmitter: Transmitter, routes: List?, requireMultiplexed: Boolean)"></a>RealConnectionPool#transmitterAcquirePooledConnection(address: Address, transmitter: Transmitter, routes: List<route>?, requireMultiplexed: Boolean)</route></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealConnectionPool</span></span>(</span><br><span class="line">  <span class="comment">/** The maximum number of idle connections for each address. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> maxIdleConnections</span>: <span class="typename">Int</span>,</span><br><span class="line">  keepAliveDuration: <span class="typename">Long</span>,</span><br><span class="line">  timeUnit: TimeUnit</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Attempts to acquire a recycled connection to `address` for `transmitter`. Returns true if a</span><br><span class="line">   * connection was acquired.</span><br><span class="line">   *</span><br><span class="line">   * If `routes` is non-null these are the resolved routes (ie. IP addresses) for the connection.</span><br><span class="line">   * This is used to coalesce related domains to the same HTTP/2 connection, such as `square.com`</span><br><span class="line">   * and `square.ca`.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">transmitterAcquirePooledConnection</span><span class="params">(</span><br><span class="line">    address: <span class="typename">Address,</span><br><span class="line">    transmitter: Transmitter,</span><br><span class="line">    routes: List&lt;Route&gt;?,</span><br><span class="line">    requireMultiplexed: Boolean</span></span><br><span class="line">  )</span>: Boolean &#123;</span></span><br><span class="line">    assert(Thread.holdsLock(this))</span><br><span class="line">    <span class="keyword">for</span> (connection <span class="keyword">in</span> connections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (requireMultiplexed &amp;&amp; !connection.isMultiplexed) <span class="keyword">continue</span></span><br><span class="line">      <span class="keyword">if</span> (!connection.isEligible(address, routes)) <span class="keyword">continue</span></span><br><span class="line">      transmitter.acquireConnectionNoEvents(connection)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历 pool 中的 connections(ArrayQueue)，如果链接是可以复用的则将这个连接返回</p>
<h3 id="RealConnection-isEligible-address-Address-routes-List"><a href="#RealConnection-isEligible-address-Address-routes-List" class="headerlink" title="RealConnection#isEligible(address: Address, routes: List?)"></a>RealConnection#isEligible(address: Address, routes: List<route>?)</route></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealConnection</span></span>(</span><br><span class="line">  <span class="variable"><span class="keyword">val</span> connectionPool</span>: RealConnectionPool,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> route</span>: Route</span><br><span class="line">) : Http2Connection.Listener(), Connection &#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Returns true if this connection can carry a stream allocation to `address`. If non-null</span><br><span class="line">   * `route` is the resolved route for a connection.</span><br><span class="line">   */</span></span><br><span class="line">  internal <span class="function"><span class="keyword">fun</span> <span class="title">isEligible</span><span class="params">(address: <span class="typename">Address, routes: List&lt;Route&gt;?</span>)</span>: Boolean &#123;</span></span><br><span class="line">    <span class="comment">// 如果当前这次连接的最大并发数达到上限，返回 false</span></span><br><span class="line">    <span class="comment">// If this connection is not accepting new exchanges, we're done.</span></span><br><span class="line">    <span class="keyword">if</span> (transmitters.size &gt;= allocationLimit || noNewExchanges) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两个 address 的其他参数不相同，返回 false</span></span><br><span class="line">    <span class="comment">// If the non-host fields of the address don't overlap, we're done.</span></span><br><span class="line">    <span class="keyword">if</span> (!this.route.address().equalsNonHost(address)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两个 address 的 url 的 host 相同，返回 true,</span></span><br><span class="line">    <span class="comment">// If the host exactly matches, we're done: this connection can carry the address.</span></span><br><span class="line">    <span class="keyword">if</span> (address.url.host == this.route().address().url.host) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// This connection is a perfect match.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果上面的不符合，在下面的情况下可以合并链接</span></span><br><span class="line">    <span class="comment">// At this point we don't have a hostname match. But we still be able to carry the request if</span></span><br><span class="line">    <span class="comment">// our connection coalescing requirements are met. See also:</span></span><br><span class="line">    <span class="comment">// https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding</span></span><br><span class="line">    <span class="comment">// https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先这个链接需要时 HTTP/2</span></span><br><span class="line">    <span class="comment">// 1. This connection must be HTTP/2.</span></span><br><span class="line">    <span class="keyword">if</span> (http2Connection == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一 IP</span></span><br><span class="line">    <span class="comment">// 2. The routes must share an IP address.</span></span><br><span class="line">    <span class="keyword">if</span> (routes == <span class="literal">null</span> || !routeMatchesAny(routes)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个连接的服务器证书必须覆盖新的主机</span></span><br><span class="line">    <span class="comment">// 3. This connection's server certificate's must cover the new host.</span></span><br><span class="line">    <span class="keyword">if</span> (address.hostnameVerifier !== OkHostnameVerifier) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (!supportsUrl(address.url)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 证书将必须匹配主机</span></span><br><span class="line">    <span class="comment">// 4. Certificate pinning must match the host.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      address.certificatePinner!!.check(address.url.host, handshake()!!.peerCertificates)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_: SSLPeerUnverifiedException) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// The caller's address can be carried by this connection.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当前的链接的最大并发数不能达到上限，否则不能复用</li>
<li>两个链接的 address 的参数不相同，不能复用</li>
<li>两个链接的 url 的 host 相同则可以复用</li>
<li>合并<ul>
<li>这个链接需要是 HTTP/2</li>
<li>IP 的 address 要相同</li>
<li>这个链接的服务器证书必须覆盖新的主机</li>
<li>证书将必须匹配主机</li>
</ul>
</li>
</ul>
<h3 id="RealConnection-newCodec-client-OkHttpClient-chain-Interceptor-Chain"><a href="#RealConnection-newCodec-client-OkHttpClient-chain-Interceptor-Chain" class="headerlink" title="RealConnection#newCodec(client: OkHttpClient, chain: Interceptor.Chain)"></a>RealConnection#newCodec(client: OkHttpClient, chain: Interceptor.Chain)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealConnection</span></span>(</span><br><span class="line">  <span class="variable"><span class="keyword">val</span> connectionPool</span>: RealConnectionPool,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> route</span>: Route</span><br><span class="line">) : Http2Connection.Listener(), Connection &#123;</span><br><span class="line">  @Throws(SocketException::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">  internal <span class="function"><span class="keyword">fun</span> <span class="title">newCodec</span><span class="params">(client: <span class="typename">OkHttpClient, chain: Interceptor.Chain</span>)</span>: ExchangeCodec &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> socket</span> = this.socket!!</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> source</span> = this.source!!</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> sink</span> = this.sink!!</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> http2Connection</span> = this.http2Connection</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (http2Connection != <span class="literal">null</span>) &#123;</span><br><span class="line">      Http2ExchangeCodec(client, this, chain, http2Connection)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      socket.soTimeout = chain.readTimeoutMillis()</span><br><span class="line">      source.timeout().timeout(chain.readTimeoutMillis().toLong(), MILLISECONDS)</span><br><span class="line">      sink.timeout().timeout(chain.writeTimeoutMillis().toLong(), MILLISECONDS)</span><br><span class="line">      Http1ExchangeCodec(client, this, source, sink)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断是 Http 还是 Http2，然后根据策略模式返回</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/07/12/okhttp-call-server-interceptor-analyse/" class="prev">PREV</a><a href="/2019/07/10/okhttp-cache-interceptor-analyse/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yydcdut.com">yydcdut</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>