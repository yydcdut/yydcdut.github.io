<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> OkHttp源码解析 · Android杂文 - yydcdut</title><meta name="description" content="OkHttp源码解析 - yydcdut"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yydcdut.com/atom.xml" title="Android杂文 - yydcdut"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut/yydcdut.github.io/issues" target="_blank" class="nav-list-link">COMMENT</a></li><li class="nav-list-item"><a href="https://github.com/yydcdut" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">OkHttp源码解析</h1><div class="post-info">2019年7月7日</div><div class="post-content"><blockquote>
<p>Github: <a href="https://github.com/square/okhttp" target="_blank" rel="external">okhttp</a>      分析版本：<a href="https://github.com/square/okhttp/tree/930d4d07d836aef3c2681867d6ab9e73c23aacfb" target="_blank" rel="external">930d4d0</a></p>
</blockquote>
<p>An HTTP client for Android, Kotlin, and Java.</p>
<a id="more"></a>
<p>OkHttp is an HTTP client that’s efficient by default:</p>
<ul>
<li>HTTP/2 support allows all requests to the same host to share a socket.</li>
<li>Connection pooling reduces request latency (if HTTP/2 isn’t available).</li>
<li>Transparent GZIP shrinks download sizes.</li>
<li>Response caching avoids the network completely for repeat requests.</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Get-a-URL"><a href="#Get-a-URL" class="headerlink" title="Get a URL"></a>Get a URL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetExample</span> </span>&#123;</span><br><span class="line">  OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(url)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">      <span class="keyword">return</span> response.body().string();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    GetExample example = <span class="keyword">new</span> GetExample();</span><br><span class="line">    String response = example.run(<span class="string">"https://raw.github.com/square/okhttp/master/README.md"</span>);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Post-to-a-Server"><a href="#Post-to-a-Server" class="headerlink" title="Post to a Server"></a>Post to a Server</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType JSON = MediaType.get(<span class="string">"application/json; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">  OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">post</span><span class="params">(String url, String json)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RequestBody body = RequestBody.create(json, JSON);</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(url)</span><br><span class="line">        .post(body)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">      <span class="keyword">return</span> response.body().string();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">bowlingJson</span><span class="params">(String player1, String player2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&#123;'winCondition':'HIGH_SCORE',"</span></span><br><span class="line">        + <span class="string">"'name':'Bowling',"</span></span><br><span class="line">        + <span class="string">"'round':4,"</span></span><br><span class="line">        + <span class="string">"'lastSaved':1367702411696,"</span></span><br><span class="line">        + <span class="string">"'dateStarted':1367702378785,"</span></span><br><span class="line">        + <span class="string">"'players':["</span></span><br><span class="line">        + <span class="string">"&#123;'name':'"</span> + player1 + <span class="string">"','history':[10,8,6,7,8],'color':-13388315,'total':39&#125;,"</span></span><br><span class="line">        + <span class="string">"&#123;'name':'"</span> + player2 + <span class="string">"','history':[6,10,5,10,10],'color':-48060,'total':41&#125;"</span></span><br><span class="line">        + <span class="string">"]&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    PostExample example = <span class="keyword">new</span> PostExample();</span><br><span class="line">    String json = example.bowlingJson(<span class="string">"Jesse"</span>, <span class="string">"Jake"</span>);</span><br><span class="line">    String response = example.post(<span class="string">"http://www.roundsapp.com/post"</span>, json);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p><a href="https://square.github.io/okhttp/" target="_blank" rel="external">okhttp</a></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br></pre></td></tr></table></figure>
<p>根据名字我们就能看出，OkHttpClient 为 OkHttp 的客户端，在使用的时候首先要做的就是要创建这样一个客户端</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="title">internal</span> <span class="title">constructor</span></span>(</span><br><span class="line">  builder: Builder</span><br><span class="line">) : Cloneable, Call.Factory, WebSocket.Factory &#123;</span><br><span class="line">  constructor() : this(Builder())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认构造方法使用的是默认配置的 Builder：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="title">constructor</span></span>() &#123;</span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> dispatcher</span>: Dispatcher = Dispatcher() <span class="comment">// 调度器</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> proxy</span>: Proxy? = <span class="literal">null</span> <span class="comment">// 代理</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> protocols</span>: List<span class="type">&lt;Protocol&gt;</span> = DEFAULT_PROTOCOLS <span class="comment">// 协议</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> connectionSpecs</span>: List<span class="type">&lt;ConnectionSpec&gt;</span> = DEFAULT_CONNECTION_SPECS <span class="comment">// 传输层版本和连接协议</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">val</span> interceptors</span>: MutableList<span class="type">&lt;Interceptor&gt;</span> = mutableListOf() <span class="comment">// 拦截器</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">val</span> networkInterceptors</span>: MutableList<span class="type">&lt;Interceptor&gt;</span> = mutableListOf() <span class="comment">// 网络拦截器</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> eventListenerFactory</span>: EventListener.Factory = EventListener.NONE.asFactory()</span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> proxySelector</span>: ProxySelector = ProxySelector.getDefault() ?: NullProxySelector() <span class="comment">// 代理选择器</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> cookieJar</span>: CookieJar = CookieJar.NO_COOKIES <span class="comment">// cookie</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> cache</span>: Cache? = <span class="literal">null</span> <span class="comment">// cache 缓存</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> internalCache</span>: InternalCache? = <span class="literal">null</span> <span class="comment">// 内部缓存</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> socketFactory</span>: SocketFactory = SocketFactory.getDefault() <span class="comment">// socket 工厂</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> sslSocketFactory</span>: SSLSocketFactory? = <span class="literal">null</span> <span class="comment">// socket工厂 用于https</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> certificateChainCleaner</span>: CertificateChainCleaner? = <span class="literal">null</span> <span class="comment">// 验证确认响应书，适用HTTPS 请求连接的主机名</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> hostnameVerifier</span>: HostnameVerifier = OkHostnameVerifier <span class="comment">// 主机名字确认</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> certificatePinner</span>: CertificatePinner = CertificatePinner.DEFAULT <span class="comment">// 证书链</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> proxyAuthenticator</span>: Authenticator = Authenticator.NONE <span class="comment">// 代理身份验证</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> authenticator</span>: Authenticator = Authenticator.NONE <span class="comment">// 身份验证</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> connectionPool</span>: ConnectionPool = ConnectionPool() <span class="comment">//链接复用池</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> dns</span>: Dns = Dns.SYSTEM <span class="comment">// DNS</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> followSslRedirects</span>: <span class="typename">Boolean</span> = <span class="literal">true</span> <span class="comment">// 重定向</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> followRedirects</span>: <span class="typename">Boolean</span> = <span class="literal">true</span> <span class="comment">// 本地重定向</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> retryOnConnectionFailure</span>: <span class="typename">Boolean</span> = <span class="literal">true</span> <span class="comment">// 重试连接失败</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> callTimeout</span>: <span class="typename">Int</span> = <span class="number">0</span> <span class="comment">// 请求超时</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> connectTimeout</span>: <span class="typename">Int</span> = <span class="number">10000</span> <span class="comment">// 连接超时</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> readTimeout</span>: <span class="typename">Int</span> = <span class="number">10000</span> <span class="comment">// 读取超时</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> writeTimeout</span>: <span class="typename">Int</span> = <span class="number">10000</span> <span class="comment">// 写入超时</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">var</span> pingInterval</span>: <span class="typename">Int</span> = <span class="number">0</span> <span class="comment">// Web socket and HTTP/2 ping interval</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span>: OkHttpClient = <span class="title">OkHttpClient</span><span class="params">(this)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>okhttp 的最佳表现就是创建一个 OkHttpClient 实例，并将其重用到所有的 http 请求调用上之所以所有请求公用一个  OkHttpClient，因为每个 OkHttpClient 都有自己的的连接池和线程池，这样的话可以重用连接和线程可减少延迟并节省内存</p>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(url)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<p>发送一个 HTTP 请求类要构建一个 Request 对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span> <span class="title">internal</span> <span class="title">constructor</span></span>(</span><br><span class="line">  @<span class="keyword">get</span>:JvmName(<span class="string">"url"</span>) <span class="variable"><span class="keyword">val</span> url</span>: HttpUrl, <span class="comment">// 请求地址</span></span><br><span class="line">  @<span class="keyword">get</span>:JvmName(<span class="string">"method"</span>) <span class="variable"><span class="keyword">val</span> method</span>: String, <span class="comment">// 请求方法[GET/POST/PUT/PATCH/...]</span></span><br><span class="line">  @<span class="keyword">get</span>:JvmName(<span class="string">"headers"</span>) <span class="variable"><span class="keyword">val</span> headers</span>: Headers, <span class="comment">// 请求头</span></span><br><span class="line">  @<span class="keyword">get</span>:JvmName(<span class="string">"body"</span>) <span class="variable"><span class="keyword">val</span> body</span>: RequestBody?, <span class="comment">// 请求体</span></span><br><span class="line">  internal <span class="variable"><span class="keyword">val</span> tags</span>: Map<span class="type">&lt;Class&lt;*&gt;</span>, Any&gt; <span class="comment">// 请求标签</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    internal <span class="variable"><span class="keyword">var</span> url</span>: HttpUrl? = <span class="literal">null</span></span><br><span class="line">    internal <span class="variable"><span class="keyword">var</span> method</span>: String</span><br><span class="line">    internal <span class="variable"><span class="keyword">var</span> headers</span>: Headers.Builder</span><br><span class="line">    internal <span class="variable"><span class="keyword">var</span> body</span>: RequestBody? = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    constructor() &#123;</span><br><span class="line">      this.method = <span class="string">"GET"</span></span><br><span class="line">      this.headers = Headers.Builder()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Sets the URL target of this request.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@throws</span> IllegalArgumentException if [url] is not a valid HTTP or HTTPS URL. Avoid this</span><br><span class="line">     *     exception by calling [HttpUrl.parse]; it returns null for invalid URLs.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">url</span><span class="params">(url: <span class="typename">String</span>)</span>: Builder &#123;</span></span><br><span class="line">      <span class="comment">// Silently replace web socket URLs with HTTP URLs.</span></span><br><span class="line">      <span class="variable"><span class="keyword">val</span> finalUrl</span>: String = <span class="keyword">when</span> &#123;</span><br><span class="line">        url.startsWith(<span class="string">"ws:"</span>, ignoreCase = <span class="literal">true</span>) -&gt; &#123;</span><br><span class="line">          <span class="string">"http:$&#123;url.substring(3)&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">        url.startsWith(<span class="string">"wss:"</span>, ignoreCase = <span class="literal">true</span>) -&gt; &#123;</span><br><span class="line">          <span class="string">"https:$&#123;url.substring(4)&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; url</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> url(finalUrl.toHttpUrl())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span>: Request &#123;</span></span><br><span class="line">      <span class="keyword">return</span> Request(</span><br><span class="line">          checkNotNull(url) &#123; <span class="string">"url == null"</span> &#125;,</span><br><span class="line">          method,</span><br><span class="line">          headers.build(),</span><br><span class="line">          body,</span><br><span class="line">          tags.toImmutableMap()</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Request 也是通过 Builder 形式来创建的</p>
<h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call call = client.newCall(request);</span><br></pre></td></tr></table></figure>
<p>Call 即调用是一个准备好去执行的请求 Request</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">interface Call : Cloneable &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">()</span>: Request</span></span><br><span class="line"></span><br><span class="line">  @Throws(IOException::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span>: Response</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="typename">Callback</span>)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">isExecuted</span><span class="params">()</span>: Boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">isCanceled</span><span class="params">()</span>: Boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">timeout</span><span class="params">()</span>: Timeout</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">clone</span><span class="params">()</span>: Call</span></span><br><span class="line"></span><br><span class="line">  interface Factory &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="typename">Request</span>)</span>: Call</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>request()</code>: 返回的是原始的请求，也即调用 OkHttpClient 中的 newCall() 中设置的 Request</li>
<li><code>execute()</code>: 同步请求方法，阻塞式方法</li>
<li><code>enqueue(responseCallback: Callback)</code>: 异步请求方法，通过调度器 dispatcher 定义了该方法请求何时被运行</li>
<li><code>cancel()</code>: 取消请求</li>
<li><code>isExecuted()</code>: 请求是否已经执行</li>
<li><code>isCanceled()</code>: 请求是否已取消</li>
<li><code>timeout()</code>: 超时</li>
</ul>
<p>OkHttpClient 实现了 Call.Factory，使用工厂模式将构建的细节交给具体实现，顶层只需要拿到 Call 对象即可</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="title">internal</span> <span class="title">constructor</span></span>(</span><br><span class="line">  builder: Builder</span><br><span class="line">) : Cloneable, Call.Factory, WebSocket.Factory &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** Prepares the [request] to be executed at some point in the future. */</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="typename">Request</span>)</span>: Call &#123;</span></span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(this, request, <span class="literal">false</span> <span class="comment">/* for web socket */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看 RealCall 中的 newRealCall 方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="title">private</span> <span class="title">constructor</span></span>(</span><br><span class="line">  <span class="variable"><span class="keyword">val</span> client</span>: OkHttpClient,</span><br><span class="line">  <span class="comment">/** The application's original request unadulterated by redirects or auth headers. */</span></span><br><span class="line">  <span class="variable"><span class="keyword">val</span> originalRequest</span>: Request,</span><br><span class="line">  <span class="variable"><span class="keyword">val</span> forWebSocket</span>: <span class="typename">Boolean</span></span><br><span class="line">) : Call &#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * There is a cycle between the [Call] and [Transmitter] that makes this awkward.</span><br><span class="line">   * This is set after immediately after creating the call instance.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">private</span> lateinit <span class="variable"><span class="keyword">var</span> transmitter</span>: Transmitter</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newRealCall</span><span class="params">(</span><br><span class="line">      client: <span class="typename">OkHttpClient,</span><br><span class="line">      originalRequest: Request,</span><br><span class="line">      forWebSocket: Boolean</span></span><br><span class="line">    )</span>: RealCall &#123;</span></span><br><span class="line">      <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">      <span class="keyword">return</span> RealCall(client, originalRequest, forWebSocket).apply &#123;</span><br><span class="line">        transmitter = Transmitter(client, this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RealCall 为具体产品，实现了 Call 接口；其中 Transmitter 是 OkHttp 的应用层和网络层的一个桥梁类，包含了连接，请求，响应和流</p>
<h4 id="Transmitter"><a href="#Transmitter" class="headerlink" title="Transmitter"></a>Transmitter</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transmitter</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> client</span>: OkHttpClient,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> call</span>: Call</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> connectionPool</span>: RealConnectionPool = client.connectionPool().delegate</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> eventListener</span>: EventListener = client.eventListenerFactory().create(call)</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> timeout</span> = <span class="keyword">object</span> : AsyncTimeout() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">timedOut</span><span class="params">()</span> &#123;</span></span><br><span class="line">      cancel()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.apply &#123;</span><br><span class="line">    timeout(client.callTimeoutMillis().toLong(), MILLISECONDS)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建 Transmitter 对象的时候设置了相关指标的监听器和 ConnectionPool</p>
<h4 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="title">private</span> <span class="title">constructor</span></span>(</span><br><span class="line">  <span class="variable"><span class="keyword">val</span> client</span>: OkHttpClient,</span><br><span class="line">  <span class="comment">/** The application's original request unadulterated by redirects or auth headers. */</span></span><br><span class="line">  <span class="variable"><span class="keyword">val</span> originalRequest</span>: Request,</span><br><span class="line">  <span class="variable"><span class="keyword">val</span> forWebSocket</span>: <span class="typename">Boolean</span></span><br><span class="line">) : Call &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span>: Response &#123;</span></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      check(!executed) &#123; <span class="string">"Already Executed"</span> &#125;</span><br><span class="line">      executed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.timeoutEnter()</span><br><span class="line">    transmitter.callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      client.dispatcher().executed(this)</span><br><span class="line">      <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher().finished(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>同步代码块，内部是做一个判断，判断是否已经执行execute方法，如果执行了抛出异常</li>
<li>超时计时，最终调用的是 <code>AsyncTimeout</code> 类中的  <code>enter()</code> 方法</li>
<li>请求开始的相关操作<ul>
<li><code>getStackTraceForCloseable()</code>：应该是追踪捕捉一些堆栈信息</li>
<li>调用 EventListener 的 callStart() 方法</li>
</ul>
</li>
<li>将请求 call 添加到调度器中的同步双端队列中</li>
<li>通过拦截器链获取响应并返回</li>
<li>请求结束时候回收移除同步请求</li>
</ul>
<h4 id="getResponseWithInterceptorChain"><a href="#getResponseWithInterceptorChain" class="headerlink" title="getResponseWithInterceptorChain()"></a>getResponseWithInterceptorChain()</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="title">private</span> <span class="title">constructor</span></span>(</span><br><span class="line">  <span class="variable"><span class="keyword">val</span> client</span>: OkHttpClient,</span><br><span class="line">  <span class="comment">/** The application's original request unadulterated by redirects or auth headers. */</span></span><br><span class="line">  <span class="variable"><span class="keyword">val</span> originalRequest</span>: Request,</span><br><span class="line">  <span class="variable"><span class="keyword">val</span> forWebSocket</span>: <span class="typename">Boolean</span></span><br><span class="line">) : Call &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  @Throws(IOException::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span>: Response &#123;</span></span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> interceptors</span> = ArrayList<span class="type">&lt;Interceptor&gt;</span>()</span><br><span class="line">    interceptors.addAll(client.interceptors())</span><br><span class="line">    interceptors.add(RetryAndFollowUpInterceptor(client)) <span class="comment">// 失败重试以及重定向</span></span><br><span class="line">    interceptors.add(BridgeInterceptor(client.cookieJar())) <span class="comment">// 用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应</span></span><br><span class="line">    interceptors.add(CacheInterceptor(client.internalCache())) <span class="comment">// 读取缓存直接返回、更新缓存</span></span><br><span class="line">    interceptors.add(ConnectInterceptor(client)) <span class="comment">// 和服务器建立连接</span></span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors())</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(CallServerInterceptor(forWebSocket)) <span class="comment">// 向服务器发送请求数据、从服务器读取响应数据</span></span><br><span class="line"></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> chain</span> = RealInterceptorChain(interceptors, transmitter, <span class="literal">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, this, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis())</span><br><span class="line"></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> calledNoMoreExchanges</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="variable"><span class="keyword">val</span> response</span> = chain.proceed(originalRequest)</span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled) &#123;</span><br><span class="line">        response.closeQuietly()</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">throw</span> transmitter.noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">        transmitter.noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将自定义的拦截器和 okhttp 本身存在的拦截器添加到拦截器的集合</li>
<li>创建一个拦截器链对象 Interceptor.Chain</li>
<li>调用拦截器链对象的 <code>proceed()</code> ，开启链式调用请求，并最终返回响应 <code>response</code></li>
<li>结束请求，调用 <code>Transmitter</code> 对象的 <code>noMoreExchanges()</code> ，释放请求连接</li>
</ul>
<blockquote>
<p>Interceptor 使用的是责任链模式</p>
</blockquote>
<h4 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue()"></a>enqueue()</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="title">private</span> <span class="title">constructor</span></span>(</span><br><span class="line">  <span class="variable"><span class="keyword">val</span> client</span>: OkHttpClient,</span><br><span class="line">  <span class="comment">/** The application's original request unadulterated by redirects or auth headers. */</span></span><br><span class="line">  <span class="variable"><span class="keyword">val</span> originalRequest</span>: Request,</span><br><span class="line">  <span class="variable"><span class="keyword">val</span> forWebSocket</span>: <span class="typename">Boolean</span></span><br><span class="line">) : Call &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="typename">Callback</span>)</span> &#123;</span></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      check(!executed) &#123; <span class="string">"Already Executed"</span> &#125;</span><br><span class="line">      executed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.callStart()</span><br><span class="line">    client.dispatcher().enqueue(AsyncCall(responseCallback))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用的是 <code>Dispatcher</code> 中的 <code>enqueue()</code> </p>
<h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><h4 id="executed-call-RealCall"><a href="#executed-call-RealCall" class="headerlink" title="executed(call: RealCall)"></a>executed(call: RealCall)</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> <span class="title">constructor</span></span>() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** Running synchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> runningSyncCalls</span> = ArrayDeque<span class="type">&lt;RealCall&gt;</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** Used by `Call#execute` to signal it is in-flight. */</span></span><br><span class="line">  @Synchronized internal <span class="function"><span class="keyword">fun</span> <span class="title">executed</span><span class="params">(call: <span class="typename">RealCall</span>)</span> &#123;</span></span><br><span class="line">    runningSyncCalls.add(call)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接将将 call 添加到正在执行的请求队列中去，runningSyncCalls 为正在请求的同步队列</p>
<h4 id="enqueue-call-AsyncCall"><a href="#enqueue-call-AsyncCall" class="headerlink" title="enqueue(call: AsyncCall)"></a>enqueue(call: AsyncCall)</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> <span class="title">constructor</span></span>() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** Ready async calls in the order they'll be run. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> readyAsyncCalls</span> = ArrayDeque<span class="type">&lt;AsyncCall&gt;</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  internal <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="typename">AsyncCall</span>)</span> &#123;</span></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span></span><br><span class="line">      <span class="comment">// the same host.</span></span><br><span class="line">      <span class="keyword">if</span> (!call.<span class="keyword">get</span>().forWebSocket) &#123;</span><br><span class="line">        <span class="variable"><span class="keyword">val</span> existingCall</span> = findExistingCallWithHost(call.host())</span><br><span class="line">        <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装到一个 AsyncCall 中传递进来，添加到正在等待的异步队列 readyAsyncCalls 中去，接着继续调用 <code>promoteAndExecute()</code> 方法执行相关操作</p>
<h4 id="promoteAndExecute"><a href="#promoteAndExecute" class="headerlink" title="promoteAndExecute()"></a>promoteAndExecute()</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> <span class="title">constructor</span></span>() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Promotes eligible calls from [readyAsyncCalls] to [runningAsyncCalls] and runs them on the</span><br><span class="line">   * executor service. Must not be called with synchronization because executing calls can call</span><br><span class="line">   * into user code.</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@return</span> true if the dispatcher is currently running calls.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span>: Boolean &#123;</span></span><br><span class="line">    assert(!Thread.holdsLock(this))</span><br><span class="line"></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> executableCalls</span> = ArrayList<span class="type">&lt;AsyncCall&gt;</span>()</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> isRunning</span>: <span class="typename">Boolean</span></span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      <span class="variable"><span class="keyword">val</span> i</span> = readyAsyncCalls.iterator()</span><br><span class="line">      <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">        <span class="variable"><span class="keyword">val</span> asyncCall</span> = i.next()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size &gt;= this.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line">        <span class="keyword">if</span> (asyncCall.callsPerHost().<span class="keyword">get</span>() &gt;= this.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">        i.remove()</span><br><span class="line">        asyncCall.callsPerHost().incrementAndGet()</span><br><span class="line">        executableCalls.add(asyncCall)</span><br><span class="line">        runningAsyncCalls.add(asyncCall)</span><br><span class="line">      &#125;</span><br><span class="line">      isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">      <span class="variable"><span class="keyword">val</span> asyncCall</span> = executableCalls[i]</span><br><span class="line">      asyncCall.executeOn(executorService())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isRunning</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Synchronized <span class="function"><span class="keyword">fun</span> <span class="title">executorService</span><span class="params">()</span>: ExecutorService &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="literal">null</span>) &#123;</span><br><span class="line">      executorService = ThreadPoolExecutor(<span class="number">0</span>, <span class="typename">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          SynchronousQueue(), threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="literal">false</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService!!</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个集合用于添加储存可以执行的 Call</li>
<li>遍历准备好的异步请求队列 readyAsyncCalls</li>
<li>检验正在运行的异步请求队列 runningAsyncCalls 的大小数量是否超过了最大请求数 <code>maxRequests</code>，如果超过了最大的请求个数，直接跳出循环</li>
<li>校验异步请求每个主机的请求数是否超过主机最大请求数 <code>maxRequestsPerHost</code>，若超过，则跳过这次循环</li>
<li>将遍历到的第一个 AsyncCall 添加到可执行的集合 executableCalls 和正在运行的异步请求队列 runningAsyncCalls 中去，同时，在 readyAsyncCalls 将这条数据移除，并将主机请求数量 +1</li>
<li>待循环遍历结束，获取正在运行的请求数量，判断是否存在正在运行的请求</li>
<li>对 readyAsyncCalls 循环遍历结束后，会得到一个可运行的 executableCalls 集合，遍历该集合，将集合中的 AsyncCall 依次调用执行</li>
</ul>
<h3 id="AsyncCall"><a href="#AsyncCall" class="headerlink" title="AsyncCall"></a>AsyncCall</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="title">private</span> <span class="title">constructor</span></span>(</span><br><span class="line">  <span class="variable"><span class="keyword">val</span> client</span>: OkHttpClient,</span><br><span class="line">  <span class="comment">/** The application's original request unadulterated by redirects or auth headers. */</span></span><br><span class="line">  <span class="variable"><span class="keyword">val</span> originalRequest</span>: Request,</span><br><span class="line">  <span class="variable"><span class="keyword">val</span> forWebSocket</span>: <span class="typename">Boolean</span></span><br><span class="line">) : Call &#123;</span><br><span class="line">  internal inner <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> responseCallback</span>: Callback</span><br><span class="line">  ) : Runnable &#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Attempt to enqueue this async call on [executorService]. This will attempt to clean up</span><br><span class="line">     * if the executor has been shut down by reporting the call as failed.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="typename">ExecutorService</span>)</span> &#123;</span></span><br><span class="line">      assert(!Thread.holdsLock(client.dispatcher()))</span><br><span class="line">      <span class="variable"><span class="keyword">var</span> success</span> = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.execute(this)</span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">        <span class="variable"><span class="keyword">val</span> ioException</span> = InterruptedIOException(<span class="string">"executor rejected"</span>)</span><br><span class="line">        ioException.initCause(e)</span><br><span class="line">        transmitter.noMoreExchanges(ioException)</span><br><span class="line">        responseCallback.onFailure(this@RealCall, ioException)</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          client.dispatcher().finished(this) <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span> &#123;</span></span><br><span class="line">      threadName(<span class="string">"OkHttp $&#123;redactedUrl()&#125;"</span>) &#123;</span><br><span class="line">        <span class="variable"><span class="keyword">var</span> signalledCallback</span> = <span class="literal">false</span></span><br><span class="line">        transmitter.timeoutEnter()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="variable"><span class="keyword">val</span> response</span> = getResponseWithInterceptorChain()</span><br><span class="line">          signalledCallback = <span class="literal">true</span></span><br><span class="line">          responseCallback.onResponse(this@RealCall, response)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">          <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">            <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">            Platform.<span class="keyword">get</span>().log(INFO, <span class="string">"Callback failure for $&#123;toLoggableString()&#125;"</span>, e)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseCallback.onFailure(this@RealCall, e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          client.dispatcher().finished(this)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又回到了 <code>getResponseWithInterceptorChain()</code> 中</p>
<h3 id="RealInterceptorChain"><a href="#RealInterceptorChain" class="headerlink" title="RealInterceptorChain"></a>RealInterceptorChain</h3><p>所有的 interceptor 都整合到了 <code>RealInterceptorChain</code> 中，执行拦截器链方法 <code>proceed()</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealInterceptorChain</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> interceptors</span>: List<span class="type">&lt;Interceptor&gt;</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> transmitter</span>: Transmitter,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> exchange</span>: Exchange?,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> index</span>: <span class="typename">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> request</span>: Request,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> call</span>: Call,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> connectTimeout</span>: <span class="typename">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> readTimeout</span>: <span class="typename">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> writeTimeout</span>: <span class="typename">Int</span></span><br><span class="line">) : Interceptor.Chain &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="typename">Request</span>)</span>: Response &#123;</span></span><br><span class="line">    <span class="keyword">return</span> proceed(request, transmitter, exchange)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Throws(IOException::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="typename">Request, transmitter: Transmitter, exchange: Exchange?</span>)</span>: Response &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size) <span class="keyword">throw</span> AssertionError()</span><br><span class="line"></span><br><span class="line">    calls++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">    check(this.exchange == <span class="literal">null</span> || this.exchange.connection()!!.supportsUrl(request.url)) &#123;</span><br><span class="line">      <span class="string">"network interceptor $&#123;interceptors[index - 1]&#125; must retain the same host and port"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">    check(this.exchange == <span class="literal">null</span> || calls <span class="type">&lt;= 1) &#123;</span><br><span class="line">      "network interceptor $&#123;interceptors[index - 1]&#125; must call proceed() exactly once"</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call the next interceptor in the chain.</span><br><span class="line">    val next = RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">        index + 1, request, call, connectTimeout, readTimeout, writeTimeout)</span><br><span class="line">    val interceptor = interceptors[index]</span><br><span class="line"></span><br><span class="line">    @Suppress("USELESS_ELVIS")</span><br><span class="line">    val response = interceptor.intercept(next) ?: throw NullPointerException(</span><br><span class="line">        "interceptor $interceptor returned null")</span><br><span class="line"></span><br><span class="line">    // Confirm that the next interceptor made its required call to chain.proceed().</span><br><span class="line">    check(exchange == null || index + 1 &gt;</span>= interceptors.size || next.calls == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="string">"network interceptor $interceptor must call proceed() exactly once"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check(response.body() != <span class="literal">null</span>) &#123; <span class="string">"interceptor $interceptor returned a response with no body"</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化的时候，会将所有拦截器组成的集合传递过来，同时将请求 <code>Request</code> 和 <code>Call</code> 也会传递过来，<code>index</code> 参数，最开始传入的是 0，<code>exchange</code> 参数，如果是应用拦截器，connection 必须是 null；如果是网络拦截器，connection 必须不为 null</p>
<ul>
<li>首先判断 index 是否大于总的拦截器个数，大于抛出 AssertionError()</li>
<li>对 calls 进行 +1 操作</li>
<li>判断是否是一个网络拦截器，并且判断其 host 和 port 是否一致</li>
<li>判断是否是一个网络拦截器，如果是判断是否该网络拦截器的 proceed 方法调用次数是否超过一次</li>
<li>继续创建一个新的拦截器链对象，此时传入的 index 会进行 index+1 操作，表示开始真正的调用相关拦截器操作</li>
<li>调用拦截器的 intercept 方法，将新的拦截器链对象塞进去</li>
<li>返回 response 后进行校验</li>
</ul>
<p><img src="http://yydcdut.com/img/okhttp_interceptors.jpg" alt="http://yydcdut.com/img/okhttp_interceptors.jpg"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/index.html" target="_blank" rel="external">拆轮子系列：拆 OkHttp</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2019/07/08/okhttp-retry-and-follow-up-interceptor-analyse/" class="prev">PREV</a><a href="/2019/07/06/ijkplayer-video-audio-sync/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yydcdut.com">yydcdut</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>